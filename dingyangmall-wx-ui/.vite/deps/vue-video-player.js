import "./chunk-G6SCE5T5.js";
import {
  computed,
  defineComponent,
  h,
  normalizeClass,
  onBeforeUnmount,
  onMounted,
  readonly,
  ref,
  shallowRef,
  toRaw,
  watch
} from "./chunk-IJVGRPBG.js";
import {
  __commonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/global/window.js
var require_window = __commonJS({
  "node_modules/global/window.js"(exports, module) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module.exports = win;
  }
});

// browser-external:min-document
var require_min_document = __commonJS({
  "browser-external:min-document"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "min-document" has been externalized for browser compatibility. Cannot access "min-document.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/global/document.js
var require_document = __commonJS({
  "node_modules/global/document.js"(exports, module) {
    var topLevel = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
    var minDoc = require_min_document();
    var doccy;
    if (typeof document !== "undefined") {
      doccy = document;
    } else {
      doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
      if (!doccy) {
        doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
      }
    }
    module.exports = doccy;
  }
});

// node_modules/keycode/index.js
var require_keycode = __commonJS({
  "node_modules/keycode/index.js"(exports, module) {
    function keyCode(searchInput) {
      if (searchInput && "object" === typeof searchInput) {
        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
        if (hasKeyCode) searchInput = hasKeyCode;
      }
      if ("number" === typeof searchInput) return names[searchInput];
      var search = String(searchInput);
      var foundNamedKey = codes[search.toLowerCase()];
      if (foundNamedKey) return foundNamedKey;
      var foundNamedKey = aliases[search.toLowerCase()];
      if (foundNamedKey) return foundNamedKey;
      if (search.length === 1) return search.charCodeAt(0);
      return void 0;
    }
    keyCode.isEventKey = function isEventKey(event, nameOrCode) {
      if (event && "object" === typeof event) {
        var keyCode2 = event.which || event.keyCode || event.charCode;
        if (keyCode2 === null || keyCode2 === void 0) {
          return false;
        }
        if (typeof nameOrCode === "string") {
          var foundNamedKey = codes[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode2;
          }
          var foundNamedKey = aliases[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode2;
          }
        } else if (typeof nameOrCode === "number") {
          return nameOrCode === keyCode2;
        }
        return false;
      }
    };
    exports = module.exports = keyCode;
    var codes = exports.code = exports.codes = {
      "backspace": 8,
      "tab": 9,
      "enter": 13,
      "shift": 16,
      "ctrl": 17,
      "alt": 18,
      "pause/break": 19,
      "caps lock": 20,
      "esc": 27,
      "space": 32,
      "page up": 33,
      "page down": 34,
      "end": 35,
      "home": 36,
      "left": 37,
      "up": 38,
      "right": 39,
      "down": 40,
      "insert": 45,
      "delete": 46,
      "command": 91,
      "left command": 91,
      "right command": 93,
      "numpad *": 106,
      "numpad +": 107,
      "numpad -": 109,
      "numpad .": 110,
      "numpad /": 111,
      "num lock": 144,
      "scroll lock": 145,
      "my computer": 182,
      "my calculator": 183,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    var aliases = exports.aliases = {
      "windows": 91,
      "⇧": 16,
      "⌥": 18,
      "⌃": 17,
      "⌘": 91,
      "ctl": 17,
      "control": 17,
      "option": 18,
      "pause": 19,
      "break": 19,
      "caps": 20,
      "return": 13,
      "escape": 27,
      "spc": 32,
      "spacebar": 32,
      "pgup": 33,
      "pgdn": 34,
      "ins": 45,
      "del": 46,
      "cmd": 91
    };
    for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;
    for (i = 48; i < 58; i++) codes[i - 48] = i;
    var i;
    for (i = 1; i < 13; i++) codes["f" + i] = i + 111;
    for (i = 0; i < 10; i++) codes["numpad " + i] = i + 96;
    var names = exports.names = exports.title = {};
    for (i in codes) names[codes[i]] = i;
    for (alias in aliases) {
      codes[alias] = aliases[alias];
    }
    var alias;
  }
});

// node_modules/safe-json-parse/tuple.js
var require_tuple = __commonJS({
  "node_modules/safe-json-parse/tuple.js"(exports, module) {
    module.exports = SafeParseTuple;
    function SafeParseTuple(obj, reviver) {
      var json;
      var error = null;
      try {
        json = JSON.parse(obj, reviver);
      } catch (err) {
        error = err;
      }
      return [error, json];
    }
  }
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends2() {
      return module.exports = _extends2 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n[r2] = t2[r2]);
        }
        return n;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends2.apply(null, arguments);
    }
    module.exports = _extends2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/is-function/index.js
var require_is_function = __commonJS({
  "node_modules/is-function/index.js"(exports, module) {
    module.exports = isFunction;
    var toString2 = Object.prototype.toString;
    function isFunction(fn) {
      if (!fn) {
        return false;
      }
      var string = toString2.call(fn);
      return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && // IE8 and below
      (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
    }
  }
});

// node_modules/@videojs/xhr/lib/http-handler.js
var require_http_handler = __commonJS({
  "node_modules/@videojs/xhr/lib/http-handler.js"(exports, module) {
    "use strict";
    var window7 = require_window();
    var httpResponseHandler = function httpResponseHandler2(callback2, decodeResponseBody) {
      if (decodeResponseBody === void 0) {
        decodeResponseBody = false;
      }
      return function(err, response, responseBody) {
        if (err) {
          callback2(err);
          return;
        }
        if (response.statusCode >= 400 && response.statusCode <= 599) {
          var cause = responseBody;
          if (decodeResponseBody) {
            if (window7.TextDecoder) {
              var charset = getCharset(response.headers && response.headers["content-type"]);
              try {
                cause = new TextDecoder(charset).decode(responseBody);
              } catch (e) {
              }
            } else {
              cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
            }
          }
          callback2({
            cause
          });
          return;
        }
        callback2(null, responseBody);
      };
    };
    function getCharset(contentTypeHeader) {
      if (contentTypeHeader === void 0) {
        contentTypeHeader = "";
      }
      return contentTypeHeader.toLowerCase().split(";").reduce(function(charset, contentType) {
        var _contentType$split = contentType.split("="), type2 = _contentType$split[0], value = _contentType$split[1];
        if (type2.trim() === "charset") {
          return value.trim();
        }
        return charset;
      }, "utf-8");
    }
    module.exports = httpResponseHandler;
  }
});

// node_modules/@videojs/xhr/lib/index.js
var require_lib = __commonJS({
  "node_modules/@videojs/xhr/lib/index.js"(exports, module) {
    "use strict";
    var window7 = require_window();
    var _extends2 = require_extends();
    var isFunction = require_is_function();
    createXHR.httpHandler = require_http_handler();
    var parseHeaders = function parseHeaders2(headers) {
      var result = {};
      if (!headers) {
        return result;
      }
      headers.trim().split("\n").forEach(function(row) {
        var index = row.indexOf(":");
        var key = row.slice(0, index).trim().toLowerCase();
        var value = row.slice(index + 1).trim();
        if (typeof result[key] === "undefined") {
          result[key] = value;
        } else if (Array.isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [result[key], value];
        }
      });
      return result;
    };
    module.exports = createXHR;
    module.exports.default = createXHR;
    createXHR.XMLHttpRequest = window7.XMLHttpRequest || noop2;
    createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window7.XDomainRequest;
    forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
      createXHR[method === "delete" ? "del" : method] = function(uri, options, callback2) {
        options = initParams(uri, options, callback2);
        options.method = method.toUpperCase();
        return _createXHR(options);
      };
    });
    function forEachArray(array, iterator) {
      for (var i = 0; i < array.length; i++) {
        iterator(array[i]);
      }
    }
    function isEmpty(obj) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) return false;
      }
      return true;
    }
    function initParams(uri, options, callback2) {
      var params = uri;
      if (isFunction(options)) {
        callback2 = options;
        if (typeof uri === "string") {
          params = {
            uri
          };
        }
      } else {
        params = _extends2({}, options, {
          uri
        });
      }
      params.callback = callback2;
      return params;
    }
    function createXHR(uri, options, callback2) {
      options = initParams(uri, options, callback2);
      return _createXHR(options);
    }
    function _createXHR(options) {
      if (typeof options.callback === "undefined") {
        throw new Error("callback argument missing");
      }
      var called = false;
      var callback2 = function cbOnce(err, response, body2) {
        if (!called) {
          called = true;
          options.callback(err, response, body2);
        }
      };
      function readystatechange() {
        if (xhr.readyState === 4) {
          setTimeout(loadFunc, 0);
        }
      }
      function getBody() {
        var body2 = void 0;
        if (xhr.response) {
          body2 = xhr.response;
        } else {
          body2 = xhr.responseText || getXml(xhr);
        }
        if (isJson) {
          try {
            body2 = JSON.parse(body2);
          } catch (e) {
          }
        }
        return body2;
      }
      function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if (!(evt instanceof Error)) {
          evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
        }
        evt.statusCode = 0;
        return callback2(evt, failureResponse);
      }
      function loadFunc() {
        if (aborted) return;
        var status;
        clearTimeout(timeoutTimer);
        if (options.useXDR && xhr.status === void 0) {
          status = 200;
        } else {
          status = xhr.status === 1223 ? 204 : xhr.status;
        }
        var response = failureResponse;
        var err = null;
        if (status !== 0) {
          response = {
            body: getBody(),
            statusCode: status,
            method,
            headers: {},
            url: uri,
            rawRequest: xhr
          };
          if (xhr.getAllResponseHeaders) {
            response.headers = parseHeaders(xhr.getAllResponseHeaders());
          }
        } else {
          err = new Error("Internal XMLHttpRequest Error");
        }
        return callback2(err, response, response.body);
      }
      var xhr = options.xhr || null;
      if (!xhr) {
        if (options.cors || options.useXDR) {
          xhr = new createXHR.XDomainRequest();
        } else {
          xhr = new createXHR.XMLHttpRequest();
        }
      }
      var key;
      var aborted;
      var uri = xhr.url = options.uri || options.url;
      var method = xhr.method = options.method || "GET";
      var body = options.body || options.data;
      var headers = xhr.headers = options.headers || {};
      var sync = !!options.sync;
      var isJson = false;
      var timeoutTimer;
      var failureResponse = {
        body: void 0,
        headers: {},
        statusCode: 0,
        method,
        url: uri,
        rawRequest: xhr
      };
      if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
        if (method !== "GET" && method !== "HEAD") {
          headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
          body = JSON.stringify(options.json === true ? body : options.json);
        }
      }
      xhr.onreadystatechange = readystatechange;
      xhr.onload = loadFunc;
      xhr.onerror = errorFunc;
      xhr.onprogress = function() {
      };
      xhr.onabort = function() {
        aborted = true;
      };
      xhr.ontimeout = errorFunc;
      xhr.open(method, uri, !sync, options.username, options.password);
      if (!sync) {
        xhr.withCredentials = !!options.withCredentials;
      }
      if (!sync && options.timeout > 0) {
        timeoutTimer = setTimeout(function() {
          if (aborted) return;
          aborted = true;
          xhr.abort("timeout");
          var e = new Error("XMLHttpRequest timeout");
          e.code = "ETIMEDOUT";
          errorFunc(e);
        }, options.timeout);
      }
      if (xhr.setRequestHeader) {
        for (key in headers) {
          if (headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object");
      }
      if ("responseType" in options) {
        xhr.responseType = options.responseType;
      }
      if ("beforeSend" in options && typeof options.beforeSend === "function") {
        options.beforeSend(xhr);
      }
      xhr.send(body || null);
      return xhr;
    }
    function getXml(xhr) {
      try {
        if (xhr.responseType === "document") {
          return xhr.responseXML;
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
          return xhr.responseXML;
        }
      } catch (e) {
      }
      return null;
    }
    function noop2() {
    }
  }
});

// node_modules/videojs-vtt.js/lib/vtt.js
var require_vtt = __commonJS({
  "node_modules/videojs-vtt.js/lib/vtt.js"(exports, module) {
    var document3 = require_document();
    var _objCreate = Object.create || /* @__PURE__ */ function() {
      function F() {
      }
      return function(o) {
        if (arguments.length !== 1) {
          throw new Error("Object.create shim only accepts one parameter.");
        }
        F.prototype = o;
        return new F();
      };
    }();
    function ParsingError(errorData, message) {
      this.name = "ParsingError";
      this.code = errorData.code;
      this.message = message || errorData.message;
    }
    ParsingError.prototype = _objCreate(Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    ParsingError.Errors = {
      BadSignature: {
        code: 0,
        message: "Malformed WebVTT signature."
      },
      BadTimeStamp: {
        code: 1,
        message: "Malformed time stamp."
      }
    };
    function parseTimeStamp(input) {
      function computeSeconds(h3, m3, s, f2) {
        return (h3 | 0) * 3600 + (m3 | 0) * 60 + (s | 0) + (f2 | 0) / 1e3;
      }
      var m2 = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
      if (!m2) {
        return null;
      }
      if (m2[3]) {
        return computeSeconds(m2[1], m2[2], m2[3].replace(":", ""), m2[4]);
      } else if (m2[1] > 59) {
        return computeSeconds(m2[1], m2[2], 0, m2[4]);
      } else {
        return computeSeconds(0, m2[1], m2[2], m2[4]);
      }
    }
    function Settings() {
      this.values = _objCreate(null);
    }
    Settings.prototype = {
      // Only accept the first assignment to any key.
      set: function(k2, v2) {
        if (!this.get(k2) && v2 !== "") {
          this.values[k2] = v2;
        }
      },
      // Return the value for a key, or a default value.
      // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
      // a number of possible default values as properties where 'defaultKey' is
      // the key of the property that will be chosen; otherwise it's assumed to be
      // a single value.
      get: function(k2, dflt, defaultKey) {
        if (defaultKey) {
          return this.has(k2) ? this.values[k2] : dflt[defaultKey];
        }
        return this.has(k2) ? this.values[k2] : dflt;
      },
      // Check whether we have a value for a key.
      has: function(k2) {
        return k2 in this.values;
      },
      // Accept a setting if its one of the given alternatives.
      alt: function(k2, v2, a) {
        for (var n = 0; n < a.length; ++n) {
          if (v2 === a[n]) {
            this.set(k2, v2);
            break;
          }
        }
      },
      // Accept a setting if its a valid (signed) integer.
      integer: function(k2, v2) {
        if (/^-?\d+$/.test(v2)) {
          this.set(k2, parseInt(v2, 10));
        }
      },
      // Accept a setting if its a valid percentage.
      percent: function(k2, v2) {
        var m2;
        if (m2 = v2.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
          v2 = parseFloat(v2);
          if (v2 >= 0 && v2 <= 100) {
            this.set(k2, v2);
            return true;
          }
        }
        return false;
      }
    };
    function parseOptions(input, callback2, keyValueDelim, groupDelim) {
      var groups = groupDelim ? input.split(groupDelim) : [input];
      for (var i in groups) {
        if (typeof groups[i] !== "string") {
          continue;
        }
        var kv = groups[i].split(keyValueDelim);
        if (kv.length !== 2) {
          continue;
        }
        var k2 = kv[0].trim();
        var v2 = kv[1].trim();
        callback2(k2, v2);
      }
    }
    function parseCue(input, cue, regionList) {
      var oInput = input;
      function consumeTimeStamp() {
        var ts2 = parseTimeStamp(input);
        if (ts2 === null) {
          throw new ParsingError(
            ParsingError.Errors.BadTimeStamp,
            "Malformed timestamp: " + oInput
          );
        }
        input = input.replace(/^[^\sa-zA-Z-]+/, "");
        return ts2;
      }
      function consumeCueSettings(input2, cue2) {
        var settings = new Settings();
        parseOptions(input2, function(k2, v2) {
          switch (k2) {
            case "region":
              for (var i = regionList.length - 1; i >= 0; i--) {
                if (regionList[i].id === v2) {
                  settings.set(k2, regionList[i].region);
                  break;
                }
              }
              break;
            case "vertical":
              settings.alt(k2, v2, ["rl", "lr"]);
              break;
            case "line":
              var vals = v2.split(","), vals0 = vals[0];
              settings.integer(k2, vals0);
              settings.percent(k2, vals0) ? settings.set("snapToLines", false) : null;
              settings.alt(k2, vals0, ["auto"]);
              if (vals.length === 2) {
                settings.alt("lineAlign", vals[1], ["start", "center", "end"]);
              }
              break;
            case "position":
              vals = v2.split(",");
              settings.percent(k2, vals[0]);
              if (vals.length === 2) {
                settings.alt("positionAlign", vals[1], ["start", "center", "end"]);
              }
              break;
            case "size":
              settings.percent(k2, v2);
              break;
            case "align":
              settings.alt(k2, v2, ["start", "center", "end", "left", "right"]);
              break;
          }
        }, /:/, /\s/);
        cue2.region = settings.get("region", null);
        cue2.vertical = settings.get("vertical", "");
        try {
          cue2.line = settings.get("line", "auto");
        } catch (e) {
        }
        cue2.lineAlign = settings.get("lineAlign", "start");
        cue2.snapToLines = settings.get("snapToLines", true);
        cue2.size = settings.get("size", 100);
        try {
          cue2.align = settings.get("align", "center");
        } catch (e) {
          cue2.align = settings.get("align", "middle");
        }
        try {
          cue2.position = settings.get("position", "auto");
        } catch (e) {
          cue2.position = settings.get("position", {
            start: 0,
            left: 0,
            center: 50,
            middle: 50,
            end: 100,
            right: 100
          }, cue2.align);
        }
        cue2.positionAlign = settings.get("positionAlign", {
          start: "start",
          left: "start",
          center: "center",
          middle: "center",
          end: "end",
          right: "end"
        }, cue2.align);
      }
      function skipWhitespace() {
        input = input.replace(/^\s+/, "");
      }
      skipWhitespace();
      cue.startTime = consumeTimeStamp();
      skipWhitespace();
      if (input.substr(0, 3) !== "-->") {
        throw new ParsingError(
          ParsingError.Errors.BadTimeStamp,
          "Malformed time stamp (time stamps must be separated by '-->'): " + oInput
        );
      }
      input = input.substr(3);
      skipWhitespace();
      cue.endTime = consumeTimeStamp();
      skipWhitespace();
      consumeCueSettings(input, cue);
    }
    var TEXTAREA_ELEMENT = document3.createElement && document3.createElement("textarea");
    var TAG_NAME = {
      c: "span",
      i: "i",
      b: "b",
      u: "u",
      ruby: "ruby",
      rt: "rt",
      v: "span",
      lang: "span"
    };
    var DEFAULT_COLOR_CLASS = {
      white: "rgba(255,255,255,1)",
      lime: "rgba(0,255,0,1)",
      cyan: "rgba(0,255,255,1)",
      red: "rgba(255,0,0,1)",
      yellow: "rgba(255,255,0,1)",
      magenta: "rgba(255,0,255,1)",
      blue: "rgba(0,0,255,1)",
      black: "rgba(0,0,0,1)"
    };
    var TAG_ANNOTATION = {
      v: "title",
      lang: "lang"
    };
    var NEEDS_PARENT = {
      rt: "ruby"
    };
    function parseContent(window7, input) {
      function nextToken() {
        if (!input) {
          return null;
        }
        function consume(result) {
          input = input.substr(result.length);
          return result;
        }
        var m3 = input.match(/^([^<]*)(<[^>]*>?)?/);
        return consume(m3[1] ? m3[1] : m3[2]);
      }
      function unescape2(s) {
        TEXTAREA_ELEMENT.innerHTML = s;
        s = TEXTAREA_ELEMENT.textContent;
        TEXTAREA_ELEMENT.textContent = "";
        return s;
      }
      function shouldAdd(current2, element) {
        return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current2.localName;
      }
      function createElement(type2, annotation) {
        var tagName = TAG_NAME[type2];
        if (!tagName) {
          return null;
        }
        var element = window7.document.createElement(tagName);
        var name = TAG_ANNOTATION[type2];
        if (name && annotation) {
          element[name] = annotation.trim();
        }
        return element;
      }
      var rootDiv = window7.document.createElement("div"), current = rootDiv, t2, tagStack = [];
      while ((t2 = nextToken()) !== null) {
        if (t2[0] === "<") {
          if (t2[1] === "/") {
            if (tagStack.length && tagStack[tagStack.length - 1] === t2.substr(2).replace(">", "")) {
              tagStack.pop();
              current = current.parentNode;
            }
            continue;
          }
          var ts2 = parseTimeStamp(t2.substr(1, t2.length - 2));
          var node;
          if (ts2) {
            node = window7.document.createProcessingInstruction("timestamp", ts2);
            current.appendChild(node);
            continue;
          }
          var m2 = t2.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
          if (!m2) {
            continue;
          }
          node = createElement(m2[1], m2[3]);
          if (!node) {
            continue;
          }
          if (!shouldAdd(current, node)) {
            continue;
          }
          if (m2[2]) {
            var classes = m2[2].split(".");
            classes.forEach(function(cl) {
              var bgColor = /^bg_/.test(cl);
              var colorName = bgColor ? cl.slice(3) : cl;
              if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
                var propName = bgColor ? "background-color" : "color";
                var propValue = DEFAULT_COLOR_CLASS[colorName];
                node.style[propName] = propValue;
              }
            });
            node.className = classes.join(" ");
          }
          tagStack.push(m2[1]);
          current.appendChild(node);
          current = node;
          continue;
        }
        current.appendChild(window7.document.createTextNode(unescape2(t2)));
      }
      return rootDiv;
    }
    var strongRTLRanges = [
      [1470, 1470],
      [1472, 1472],
      [1475, 1475],
      [1478, 1478],
      [1488, 1514],
      [1520, 1524],
      [1544, 1544],
      [1547, 1547],
      [1549, 1549],
      [1563, 1563],
      [1566, 1610],
      [1645, 1647],
      [1649, 1749],
      [1765, 1766],
      [1774, 1775],
      [1786, 1805],
      [1807, 1808],
      [1810, 1839],
      [1869, 1957],
      [1969, 1969],
      [1984, 2026],
      [2036, 2037],
      [2042, 2042],
      [2048, 2069],
      [2074, 2074],
      [2084, 2084],
      [2088, 2088],
      [2096, 2110],
      [2112, 2136],
      [2142, 2142],
      [2208, 2208],
      [2210, 2220],
      [8207, 8207],
      [64285, 64285],
      [64287, 64296],
      [64298, 64310],
      [64312, 64316],
      [64318, 64318],
      [64320, 64321],
      [64323, 64324],
      [64326, 64449],
      [64467, 64829],
      [64848, 64911],
      [64914, 64967],
      [65008, 65020],
      [65136, 65140],
      [65142, 65276],
      [67584, 67589],
      [67592, 67592],
      [67594, 67637],
      [67639, 67640],
      [67644, 67644],
      [67647, 67669],
      [67671, 67679],
      [67840, 67867],
      [67872, 67897],
      [67903, 67903],
      [67968, 68023],
      [68030, 68031],
      [68096, 68096],
      [68112, 68115],
      [68117, 68119],
      [68121, 68147],
      [68160, 68167],
      [68176, 68184],
      [68192, 68223],
      [68352, 68405],
      [68416, 68437],
      [68440, 68466],
      [68472, 68479],
      [68608, 68680],
      [126464, 126467],
      [126469, 126495],
      [126497, 126498],
      [126500, 126500],
      [126503, 126503],
      [126505, 126514],
      [126516, 126519],
      [126521, 126521],
      [126523, 126523],
      [126530, 126530],
      [126535, 126535],
      [126537, 126537],
      [126539, 126539],
      [126541, 126543],
      [126545, 126546],
      [126548, 126548],
      [126551, 126551],
      [126553, 126553],
      [126555, 126555],
      [126557, 126557],
      [126559, 126559],
      [126561, 126562],
      [126564, 126564],
      [126567, 126570],
      [126572, 126578],
      [126580, 126583],
      [126585, 126588],
      [126590, 126590],
      [126592, 126601],
      [126603, 126619],
      [126625, 126627],
      [126629, 126633],
      [126635, 126651],
      [1114109, 1114109]
    ];
    function isStrongRTLChar(charCode) {
      for (var i = 0; i < strongRTLRanges.length; i++) {
        var currentRange = strongRTLRanges[i];
        if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
          return true;
        }
      }
      return false;
    }
    function determineBidi(cueDiv) {
      var nodeStack = [], text = "", charCode;
      if (!cueDiv || !cueDiv.childNodes) {
        return "ltr";
      }
      function pushNodes(nodeStack2, node) {
        for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
          nodeStack2.push(node.childNodes[i2]);
        }
      }
      function nextTextNode(nodeStack2) {
        if (!nodeStack2 || !nodeStack2.length) {
          return null;
        }
        var node = nodeStack2.pop(), text2 = node.textContent || node.innerText;
        if (text2) {
          var m2 = text2.match(/^.*(\n|\r)/);
          if (m2) {
            nodeStack2.length = 0;
            return m2[0];
          }
          return text2;
        }
        if (node.tagName === "ruby") {
          return nextTextNode(nodeStack2);
        }
        if (node.childNodes) {
          pushNodes(nodeStack2, node);
          return nextTextNode(nodeStack2);
        }
      }
      pushNodes(nodeStack, cueDiv);
      while (text = nextTextNode(nodeStack)) {
        for (var i = 0; i < text.length; i++) {
          charCode = text.charCodeAt(i);
          if (isStrongRTLChar(charCode)) {
            return "rtl";
          }
        }
      }
      return "ltr";
    }
    function computeLinePos(cue) {
      if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {
        return cue.line;
      }
      if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
        return -1;
      }
      var track = cue.track, trackList = track.textTrackList, count = 0;
      for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
        if (trackList[i].mode === "showing") {
          count++;
        }
      }
      return ++count * -1;
    }
    function StyleBox() {
    }
    StyleBox.prototype.applyStyles = function(styles, div) {
      div = div || this.div;
      for (var prop in styles) {
        if (styles.hasOwnProperty(prop)) {
          div.style[prop] = styles[prop];
        }
      }
    };
    StyleBox.prototype.formatStyle = function(val, unit) {
      return val === 0 ? 0 : val + unit;
    };
    function CueStyleBox(window7, cue, styleOptions) {
      StyleBox.call(this);
      this.cue = cue;
      this.cueDiv = parseContent(window7, cue.text);
      var styles = {
        color: "rgba(255, 255, 255, 1)",
        backgroundColor: "rgba(0, 0, 0, 0.8)",
        position: "relative",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        display: "inline",
        writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
        unicodeBidi: "plaintext"
      };
      this.applyStyles(styles, this.cueDiv);
      this.div = window7.document.createElement("div");
      styles = {
        direction: determineBidi(this.cueDiv),
        writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
        unicodeBidi: "plaintext",
        textAlign: cue.align === "middle" ? "center" : cue.align,
        font: styleOptions.font,
        whiteSpace: "pre-line",
        position: "absolute"
      };
      this.applyStyles(styles);
      this.div.appendChild(this.cueDiv);
      var textPos = 0;
      switch (cue.positionAlign) {
        case "start":
        case "line-left":
          textPos = cue.position;
          break;
        case "center":
          textPos = cue.position - cue.size / 2;
          break;
        case "end":
        case "line-right":
          textPos = cue.position - cue.size;
          break;
      }
      if (cue.vertical === "") {
        this.applyStyles({
          left: this.formatStyle(textPos, "%"),
          width: this.formatStyle(cue.size, "%")
        });
      } else {
        this.applyStyles({
          top: this.formatStyle(textPos, "%"),
          height: this.formatStyle(cue.size, "%")
        });
      }
      this.move = function(box) {
        this.applyStyles({
          top: this.formatStyle(box.top, "px"),
          bottom: this.formatStyle(box.bottom, "px"),
          left: this.formatStyle(box.left, "px"),
          right: this.formatStyle(box.right, "px"),
          height: this.formatStyle(box.height, "px"),
          width: this.formatStyle(box.width, "px")
        });
      };
    }
    CueStyleBox.prototype = _objCreate(StyleBox.prototype);
    CueStyleBox.prototype.constructor = CueStyleBox;
    function BoxPosition(obj) {
      var lh, height2, width2, top;
      if (obj.div) {
        height2 = obj.div.offsetHeight;
        width2 = obj.div.offsetWidth;
        top = obj.div.offsetTop;
        var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
        obj = obj.div.getBoundingClientRect();
        lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
      }
      this.left = obj.left;
      this.right = obj.right;
      this.top = obj.top || top;
      this.height = obj.height || height2;
      this.bottom = obj.bottom || top + (obj.height || height2);
      this.width = obj.width || width2;
      this.lineHeight = lh !== void 0 ? lh : obj.lineHeight;
    }
    BoxPosition.prototype.move = function(axis, toMove) {
      toMove = toMove !== void 0 ? toMove : this.lineHeight;
      switch (axis) {
        case "+x":
          this.left += toMove;
          this.right += toMove;
          break;
        case "-x":
          this.left -= toMove;
          this.right -= toMove;
          break;
        case "+y":
          this.top += toMove;
          this.bottom += toMove;
          break;
        case "-y":
          this.top -= toMove;
          this.bottom -= toMove;
          break;
      }
    };
    BoxPosition.prototype.overlaps = function(b2) {
      return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
    };
    BoxPosition.prototype.overlapsAny = function(boxes) {
      for (var i = 0; i < boxes.length; i++) {
        if (this.overlaps(boxes[i])) {
          return true;
        }
      }
      return false;
    };
    BoxPosition.prototype.within = function(container) {
      return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
    };
    BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
      switch (axis) {
        case "+x":
          return this.left < container.left;
        case "-x":
          return this.right > container.right;
        case "+y":
          return this.top < container.top;
        case "-y":
          return this.bottom > container.bottom;
      }
    };
    BoxPosition.prototype.intersectPercentage = function(b2) {
      var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y2 = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y2;
      return intersectArea / (this.height * this.width);
    };
    BoxPosition.prototype.toCSSCompatValues = function(reference) {
      return {
        top: this.top - reference.top,
        bottom: reference.bottom - this.bottom,
        left: this.left - reference.left,
        right: reference.right - this.right,
        height: this.height,
        width: this.width
      };
    };
    BoxPosition.getSimpleBoxPosition = function(obj) {
      var height2 = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
      var width2 = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
      var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
      obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
      var ret = {
        left: obj.left,
        right: obj.right,
        top: obj.top || top,
        height: obj.height || height2,
        bottom: obj.bottom || top + (obj.height || height2),
        width: obj.width || width2
      };
      return ret;
    };
    function moveBoxToLinePosition(window7, styleBox, containerBox, boxPositions) {
      function findBestPosition(b2, axis2) {
        var bestPosition2, specifiedPosition = new BoxPosition(b2), percentage = 1;
        for (var i = 0; i < axis2.length; i++) {
          while (b2.overlapsOppositeAxis(containerBox, axis2[i]) || b2.within(containerBox) && b2.overlapsAny(boxPositions)) {
            b2.move(axis2[i]);
          }
          if (b2.within(containerBox)) {
            return b2;
          }
          var p = b2.intersectPercentage(containerBox);
          if (percentage > p) {
            bestPosition2 = new BoxPosition(b2);
            percentage = p;
          }
          b2 = new BoxPosition(specifiedPosition);
        }
        return bestPosition2 || specifiedPosition;
      }
      var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
      if (cue.snapToLines) {
        var size;
        switch (cue.vertical) {
          case "":
            axis = ["+y", "-y"];
            size = "height";
            break;
          case "rl":
            axis = ["+x", "-x"];
            size = "width";
            break;
          case "lr":
            axis = ["-x", "+x"];
            size = "width";
            break;
        }
        var step = boxPosition.lineHeight, position = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
        if (Math.abs(position) > maxPosition) {
          position = position < 0 ? -1 : 1;
          position *= Math.ceil(maxPosition / step) * step;
        }
        if (linePos < 0) {
          position += cue.vertical === "" ? containerBox.height : containerBox.width;
          axis = axis.reverse();
        }
        boxPosition.move(initialAxis, position);
      } else {
        var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
        switch (cue.lineAlign) {
          case "center":
            linePos -= calculatedPercentage / 2;
            break;
          case "end":
            linePos -= calculatedPercentage;
            break;
        }
        switch (cue.vertical) {
          case "":
            styleBox.applyStyles({
              top: styleBox.formatStyle(linePos, "%")
            });
            break;
          case "rl":
            styleBox.applyStyles({
              left: styleBox.formatStyle(linePos, "%")
            });
            break;
          case "lr":
            styleBox.applyStyles({
              right: styleBox.formatStyle(linePos, "%")
            });
            break;
        }
        axis = ["+y", "-x", "+x", "-y"];
        boxPosition = new BoxPosition(styleBox);
      }
      var bestPosition = findBestPosition(boxPosition, axis);
      styleBox.move(bestPosition.toCSSCompatValues(containerBox));
    }
    function WebVTT2() {
    }
    WebVTT2.StringDecoder = function() {
      return {
        decode: function(data) {
          if (!data) {
            return "";
          }
          if (typeof data !== "string") {
            throw new Error("Error - expected string data.");
          }
          return decodeURIComponent(encodeURIComponent(data));
        }
      };
    };
    WebVTT2.convertCueToDOMTree = function(window7, cuetext) {
      if (!window7 || !cuetext) {
        return null;
      }
      return parseContent(window7, cuetext);
    };
    var FONT_SIZE_PERCENT = 0.05;
    var FONT_STYLE = "sans-serif";
    var CUE_BACKGROUND_PADDING = "1.5%";
    WebVTT2.processCues = function(window7, cues, overlay) {
      if (!window7 || !cues || !overlay) {
        return null;
      }
      while (overlay.firstChild) {
        overlay.removeChild(overlay.firstChild);
      }
      var paddedOverlay = window7.document.createElement("div");
      paddedOverlay.style.position = "absolute";
      paddedOverlay.style.left = "0";
      paddedOverlay.style.right = "0";
      paddedOverlay.style.top = "0";
      paddedOverlay.style.bottom = "0";
      paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
      overlay.appendChild(paddedOverlay);
      function shouldCompute(cues2) {
        for (var i2 = 0; i2 < cues2.length; i2++) {
          if (cues2[i2].hasBeenReset || !cues2[i2].displayState) {
            return true;
          }
        }
        return false;
      }
      if (!shouldCompute(cues)) {
        for (var i = 0; i < cues.length; i++) {
          paddedOverlay.appendChild(cues[i].displayState);
        }
        return;
      }
      var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
      var styleOptions = {
        font: fontSize + "px " + FONT_STYLE
      };
      (function() {
        var styleBox, cue;
        for (var i2 = 0; i2 < cues.length; i2++) {
          cue = cues[i2];
          styleBox = new CueStyleBox(window7, cue, styleOptions);
          paddedOverlay.appendChild(styleBox.div);
          moveBoxToLinePosition(window7, styleBox, containerBox, boxPositions);
          cue.displayState = styleBox.div;
          boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
        }
      })();
    };
    WebVTT2.Parser = function(window7, vttjs, decoder) {
      if (!decoder) {
        decoder = vttjs;
        vttjs = {};
      }
      if (!vttjs) {
        vttjs = {};
      }
      this.window = window7;
      this.vttjs = vttjs;
      this.state = "INITIAL";
      this.buffer = "";
      this.decoder = decoder || new TextDecoder("utf8");
      this.regionList = [];
    };
    WebVTT2.Parser.prototype = {
      // If the error is a ParsingError then report it to the consumer if
      // possible. If it's not a ParsingError then throw it like normal.
      reportOrThrowError: function(e) {
        if (e instanceof ParsingError) {
          this.onparsingerror && this.onparsingerror(e);
        } else {
          throw e;
        }
      },
      parse: function(data) {
        var self2 = this;
        if (data) {
          self2.buffer += self2.decoder.decode(data, { stream: true });
        }
        function collectNextLine() {
          var buffer = self2.buffer;
          var pos = 0;
          while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
            ++pos;
          }
          var line2 = buffer.substr(0, pos);
          if (buffer[pos] === "\r") {
            ++pos;
          }
          if (buffer[pos] === "\n") {
            ++pos;
          }
          self2.buffer = buffer.substr(pos);
          return line2;
        }
        function parseRegion(input) {
          var settings = new Settings();
          parseOptions(input, function(k2, v2) {
            switch (k2) {
              case "id":
                settings.set(k2, v2);
                break;
              case "width":
                settings.percent(k2, v2);
                break;
              case "lines":
                settings.integer(k2, v2);
                break;
              case "regionanchor":
              case "viewportanchor":
                var xy = v2.split(",");
                if (xy.length !== 2) {
                  break;
                }
                var anchor = new Settings();
                anchor.percent("x", xy[0]);
                anchor.percent("y", xy[1]);
                if (!anchor.has("x") || !anchor.has("y")) {
                  break;
                }
                settings.set(k2 + "X", anchor.get("x"));
                settings.set(k2 + "Y", anchor.get("y"));
                break;
              case "scroll":
                settings.alt(k2, v2, ["up"]);
                break;
            }
          }, /=/, /\s/);
          if (settings.has("id")) {
            var region = new (self2.vttjs.VTTRegion || self2.window.VTTRegion)();
            region.width = settings.get("width", 100);
            region.lines = settings.get("lines", 3);
            region.regionAnchorX = settings.get("regionanchorX", 0);
            region.regionAnchorY = settings.get("regionanchorY", 100);
            region.viewportAnchorX = settings.get("viewportanchorX", 0);
            region.viewportAnchorY = settings.get("viewportanchorY", 100);
            region.scroll = settings.get("scroll", "");
            self2.onregion && self2.onregion(region);
            self2.regionList.push({
              id: settings.get("id"),
              region
            });
          }
        }
        function parseTimestampMap(input) {
          var settings = new Settings();
          parseOptions(input, function(k2, v2) {
            switch (k2) {
              case "MPEGT":
                settings.integer(k2 + "S", v2);
                break;
              case "LOCA":
                settings.set(k2 + "L", parseTimeStamp(v2));
                break;
            }
          }, /[^\d]:/, /,/);
          self2.ontimestampmap && self2.ontimestampmap({
            "MPEGTS": settings.get("MPEGTS"),
            "LOCAL": settings.get("LOCAL")
          });
        }
        function parseHeader(input) {
          if (input.match(/X-TIMESTAMP-MAP/)) {
            parseOptions(input, function(k2, v2) {
              switch (k2) {
                case "X-TIMESTAMP-MAP":
                  parseTimestampMap(v2);
                  break;
              }
            }, /=/);
          } else {
            parseOptions(input, function(k2, v2) {
              switch (k2) {
                case "Region":
                  parseRegion(v2);
                  break;
              }
            }, /:/);
          }
        }
        try {
          var line;
          if (self2.state === "INITIAL") {
            if (!/\r\n|\n/.test(self2.buffer)) {
              return this;
            }
            line = collectNextLine();
            var m2 = line.match(/^WEBVTT([ \t].*)?$/);
            if (!m2 || !m2[0]) {
              throw new ParsingError(ParsingError.Errors.BadSignature);
            }
            self2.state = "HEADER";
          }
          var alreadyCollectedLine = false;
          while (self2.buffer) {
            if (!/\r\n|\n/.test(self2.buffer)) {
              return this;
            }
            if (!alreadyCollectedLine) {
              line = collectNextLine();
            } else {
              alreadyCollectedLine = false;
            }
            switch (self2.state) {
              case "HEADER":
                if (/:/.test(line)) {
                  parseHeader(line);
                } else if (!line) {
                  self2.state = "ID";
                }
                continue;
              case "NOTE":
                if (!line) {
                  self2.state = "ID";
                }
                continue;
              case "ID":
                if (/^NOTE($|[ \t])/.test(line)) {
                  self2.state = "NOTE";
                  break;
                }
                if (!line) {
                  continue;
                }
                self2.cue = new (self2.vttjs.VTTCue || self2.window.VTTCue)(0, 0, "");
                try {
                  self2.cue.align = "center";
                } catch (e) {
                  self2.cue.align = "middle";
                }
                self2.state = "CUE";
                if (line.indexOf("-->") === -1) {
                  self2.cue.id = line;
                  continue;
                }
              case "CUE":
                try {
                  parseCue(line, self2.cue, self2.regionList);
                } catch (e) {
                  self2.reportOrThrowError(e);
                  self2.cue = null;
                  self2.state = "BADCUE";
                  continue;
                }
                self2.state = "CUETEXT";
                continue;
              case "CUETEXT":
                var hasSubstring = line.indexOf("-->") !== -1;
                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                  self2.oncue && self2.oncue(self2.cue);
                  self2.cue = null;
                  self2.state = "ID";
                  continue;
                }
                if (self2.cue.text) {
                  self2.cue.text += "\n";
                }
                self2.cue.text += line.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
                continue;
              case "BADCUE":
                if (!line) {
                  self2.state = "ID";
                }
                continue;
            }
          }
        } catch (e) {
          self2.reportOrThrowError(e);
          if (self2.state === "CUETEXT" && self2.cue && self2.oncue) {
            self2.oncue(self2.cue);
          }
          self2.cue = null;
          self2.state = self2.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
        }
        return this;
      },
      flush: function() {
        var self2 = this;
        try {
          self2.buffer += self2.decoder.decode();
          if (self2.cue || self2.state === "HEADER") {
            self2.buffer += "\n\n";
            self2.parse();
          }
          if (self2.state === "INITIAL") {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }
        } catch (e) {
          self2.reportOrThrowError(e);
        }
        self2.onflush && self2.onflush();
        return this;
      }
    };
    module.exports = WebVTT2;
  }
});

// node_modules/videojs-vtt.js/lib/vttcue.js
var require_vttcue = __commonJS({
  "node_modules/videojs-vtt.js/lib/vttcue.js"(exports, module) {
    var autoKeyword = "auto";
    var directionSetting = {
      "": 1,
      "lr": 1,
      "rl": 1
    };
    var alignSetting = {
      "start": 1,
      "center": 1,
      "end": 1,
      "left": 1,
      "right": 1,
      "auto": 1,
      "line-left": 1,
      "line-right": 1
    };
    function findDirectionSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var dir = directionSetting[value.toLowerCase()];
      return dir ? value.toLowerCase() : false;
    }
    function findAlignSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var align = alignSetting[value.toLowerCase()];
      return align ? value.toLowerCase() : false;
    }
    function VTTCue(startTime, endTime, text) {
      this.hasBeenReset = false;
      var _id = "";
      var _pauseOnExit = false;
      var _startTime = startTime;
      var _endTime = endTime;
      var _text = text;
      var _region = null;
      var _vertical = "";
      var _snapToLines = true;
      var _line = "auto";
      var _lineAlign = "start";
      var _position = "auto";
      var _positionAlign = "auto";
      var _size = 100;
      var _align = "center";
      Object.defineProperties(this, {
        "id": {
          enumerable: true,
          get: function() {
            return _id;
          },
          set: function(value) {
            _id = "" + value;
          }
        },
        "pauseOnExit": {
          enumerable: true,
          get: function() {
            return _pauseOnExit;
          },
          set: function(value) {
            _pauseOnExit = !!value;
          }
        },
        "startTime": {
          enumerable: true,
          get: function() {
            return _startTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Start time must be set to a number.");
            }
            _startTime = value;
            this.hasBeenReset = true;
          }
        },
        "endTime": {
          enumerable: true,
          get: function() {
            return _endTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("End time must be set to a number.");
            }
            _endTime = value;
            this.hasBeenReset = true;
          }
        },
        "text": {
          enumerable: true,
          get: function() {
            return _text;
          },
          set: function(value) {
            _text = "" + value;
            this.hasBeenReset = true;
          }
        },
        "region": {
          enumerable: true,
          get: function() {
            return _region;
          },
          set: function(value) {
            _region = value;
            this.hasBeenReset = true;
          }
        },
        "vertical": {
          enumerable: true,
          get: function() {
            return _vertical;
          },
          set: function(value) {
            var setting = findDirectionSetting(value);
            if (setting === false) {
              throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
            }
            _vertical = setting;
            this.hasBeenReset = true;
          }
        },
        "snapToLines": {
          enumerable: true,
          get: function() {
            return _snapToLines;
          },
          set: function(value) {
            _snapToLines = !!value;
            this.hasBeenReset = true;
          }
        },
        "line": {
          enumerable: true,
          get: function() {
            return _line;
          },
          set: function(value) {
            if (typeof value !== "number" && value !== autoKeyword) {
              throw new SyntaxError("Line: an invalid number or illegal string was specified.");
            }
            _line = value;
            this.hasBeenReset = true;
          }
        },
        "lineAlign": {
          enumerable: true,
          get: function() {
            return _lineAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              console.warn("lineAlign: an invalid or illegal string was specified.");
            } else {
              _lineAlign = setting;
              this.hasBeenReset = true;
            }
          }
        },
        "position": {
          enumerable: true,
          get: function() {
            return _position;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Position must be between 0 and 100.");
            }
            _position = value;
            this.hasBeenReset = true;
          }
        },
        "positionAlign": {
          enumerable: true,
          get: function() {
            return _positionAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              console.warn("positionAlign: an invalid or illegal string was specified.");
            } else {
              _positionAlign = setting;
              this.hasBeenReset = true;
            }
          }
        },
        "size": {
          enumerable: true,
          get: function() {
            return _size;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Size must be between 0 and 100.");
            }
            _size = value;
            this.hasBeenReset = true;
          }
        },
        "align": {
          enumerable: true,
          get: function() {
            return _align;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
            }
            _align = setting;
            this.hasBeenReset = true;
          }
        }
      });
      this.displayState = void 0;
    }
    VTTCue.prototype.getCueAsHTML = function() {
      return WebVTT.convertCueToDOMTree(window, this.text);
    };
    module.exports = VTTCue;
  }
});

// node_modules/videojs-vtt.js/lib/vttregion.js
var require_vttregion = __commonJS({
  "node_modules/videojs-vtt.js/lib/vttregion.js"(exports, module) {
    var scrollSetting = {
      "": true,
      "up": true
    };
    function findScrollSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var scroll = scrollSetting[value.toLowerCase()];
      return scroll ? value.toLowerCase() : false;
    }
    function isValidPercentValue(value) {
      return typeof value === "number" && (value >= 0 && value <= 100);
    }
    function VTTRegion() {
      var _width = 100;
      var _lines = 3;
      var _regionAnchorX = 0;
      var _regionAnchorY = 100;
      var _viewportAnchorX = 0;
      var _viewportAnchorY = 100;
      var _scroll = "";
      Object.defineProperties(this, {
        "width": {
          enumerable: true,
          get: function() {
            return _width;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("Width must be between 0 and 100.");
            }
            _width = value;
          }
        },
        "lines": {
          enumerable: true,
          get: function() {
            return _lines;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Lines must be set to a number.");
            }
            _lines = value;
          }
        },
        "regionAnchorY": {
          enumerable: true,
          get: function() {
            return _regionAnchorY;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("RegionAnchorX must be between 0 and 100.");
            }
            _regionAnchorY = value;
          }
        },
        "regionAnchorX": {
          enumerable: true,
          get: function() {
            return _regionAnchorX;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("RegionAnchorY must be between 0 and 100.");
            }
            _regionAnchorX = value;
          }
        },
        "viewportAnchorY": {
          enumerable: true,
          get: function() {
            return _viewportAnchorY;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("ViewportAnchorY must be between 0 and 100.");
            }
            _viewportAnchorY = value;
          }
        },
        "viewportAnchorX": {
          enumerable: true,
          get: function() {
            return _viewportAnchorX;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("ViewportAnchorX must be between 0 and 100.");
            }
            _viewportAnchorX = value;
          }
        },
        "scroll": {
          enumerable: true,
          get: function() {
            return _scroll;
          },
          set: function(value) {
            var setting = findScrollSetting(value);
            if (setting === false) {
              console.warn("Scroll: an invalid or illegal string was specified.");
            } else {
              _scroll = setting;
            }
          }
        }
      });
    }
    module.exports = VTTRegion;
  }
});

// node_modules/videojs-vtt.js/lib/browser-index.js
var require_browser_index = __commonJS({
  "node_modules/videojs-vtt.js/lib/browser-index.js"(exports, module) {
    var window7 = require_window();
    var vttjs = module.exports = {
      WebVTT: require_vtt(),
      VTTCue: require_vttcue(),
      VTTRegion: require_vttregion()
    };
    window7.vttjs = vttjs;
    window7.WebVTT = vttjs.WebVTT;
    var cueShim = vttjs.VTTCue;
    var regionShim = vttjs.VTTRegion;
    var nativeVTTCue = window7.VTTCue;
    var nativeVTTRegion = window7.VTTRegion;
    vttjs.shim = function() {
      window7.VTTCue = cueShim;
      window7.VTTRegion = regionShim;
    };
    vttjs.restore = function() {
      window7.VTTCue = nativeVTTCue;
      window7.VTTRegion = nativeVTTRegion;
    };
    if (!window7.VTTCue) {
      vttjs.shim();
    }
  }
});

// node_modules/url-toolkit/src/url-toolkit.js
var require_url_toolkit = __commonJS({
  "node_modules/url-toolkit/src/url-toolkit.js"(exports, module) {
    (function(root) {
      var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
      var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
      var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
      var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
      var URLToolkit2 = {
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(baseURL, relativeURL, opts) {
          opts = opts || {};
          baseURL = baseURL.trim();
          relativeURL = relativeURL.trim();
          if (!relativeURL) {
            if (!opts.alwaysNormalize) {
              return baseURL;
            }
            var basePartsForNormalise = URLToolkit2.parseURL(baseURL);
            if (!basePartsForNormalise) {
              throw new Error("Error trying to parse base URL.");
            }
            basePartsForNormalise.path = URLToolkit2.normalizePath(
              basePartsForNormalise.path
            );
            return URLToolkit2.buildURLFromParts(basePartsForNormalise);
          }
          var relativeParts = URLToolkit2.parseURL(relativeURL);
          if (!relativeParts) {
            throw new Error("Error trying to parse relative URL.");
          }
          if (relativeParts.scheme) {
            if (!opts.alwaysNormalize) {
              return relativeURL;
            }
            relativeParts.path = URLToolkit2.normalizePath(relativeParts.path);
            return URLToolkit2.buildURLFromParts(relativeParts);
          }
          var baseParts = URLToolkit2.parseURL(baseURL);
          if (!baseParts) {
            throw new Error("Error trying to parse base URL.");
          }
          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
            baseParts.netLoc = pathParts[1];
            baseParts.path = pathParts[2];
          }
          if (baseParts.netLoc && !baseParts.path) {
            baseParts.path = "/";
          }
          var builtParts = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: baseParts.scheme,
            netLoc: relativeParts.netLoc,
            path: null,
            params: relativeParts.params,
            query: relativeParts.query,
            fragment: relativeParts.fragment
          };
          if (!relativeParts.netLoc) {
            builtParts.netLoc = baseParts.netLoc;
            if (relativeParts.path[0] !== "/") {
              if (!relativeParts.path) {
                builtParts.path = baseParts.path;
                if (!relativeParts.params) {
                  builtParts.params = baseParts.params;
                  if (!relativeParts.query) {
                    builtParts.query = baseParts.query;
                  }
                }
              } else {
                var baseURLPath = baseParts.path;
                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                builtParts.path = URLToolkit2.normalizePath(newPath);
              }
            }
          }
          if (builtParts.path === null) {
            builtParts.path = opts.alwaysNormalize ? URLToolkit2.normalizePath(relativeParts.path) : relativeParts.path;
          }
          return URLToolkit2.buildURLFromParts(builtParts);
        },
        parseURL: function(url) {
          var parts = URL_REGEX.exec(url);
          if (!parts) {
            return null;
          }
          return {
            scheme: parts[1] || "",
            netLoc: parts[2] || "",
            path: parts[3] || "",
            params: parts[4] || "",
            query: parts[5] || "",
            fragment: parts[6] || ""
          };
        },
        normalizePath: function(path) {
          path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
          }
          return path.split("").reverse().join("");
        },
        buildURLFromParts: function(parts) {
          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
        }
      };
      if (typeof exports === "object" && typeof module === "object")
        module.exports = URLToolkit2;
      else if (typeof define === "function" && define.amd)
        define([], function() {
          return URLToolkit2;
        });
      else if (typeof exports === "object") exports["URLToolkit"] = URLToolkit2;
      else root["URLToolkit"] = URLToolkit2;
    })(exports);
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign2(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.assign = assign2;
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends2(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t3 = function() {
        };
        var t2 = t3;
        ;
        t3.prototype = Super.prototype;
        t3 = new t3();
        copy(pt, t3);
        Class.prototype = pt = t3;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends2(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version2) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version2) {
        return this.ownerDocument.implementation.hasFeature(feature, version2);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback2) {
      if (callback2(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback2)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove2) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode2(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode2(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
        var targetDoc = parent.ownerDocument || parent;
        _updateOwnerDocument(newFirst, targetDoc);
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _updateOwnerDocument(node, newOwnerDocument) {
      if (node.ownerDocument === newOwnerDocument) {
        return;
      }
      node.ownerDocument = newOwnerDocument;
      if (node.nodeType === ELEMENT_NODE && node.attributes) {
        for (var i = 0; i < node.attributes.length; i++) {
          var attr = node.attributes.item(i);
          if (attr) {
            attr.ownerDocument = newOwnerDocument;
          }
        }
      }
      var child = node.firstChild;
      while (child) {
        _updateOwnerDocument(child, newOwnerDocument);
        child = child.nextSibling;
      }
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      var targetDoc = parentNode.ownerDocument || parentNode;
      _updateOwnerDocument(newChild, targetDoc);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        _updateOwnerDocument(newChild, this);
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        _updateOwnerDocument(newChild, this);
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends2(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends2(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends2(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start2 = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start2 + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends2(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends2(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends2(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends2(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends2(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends2(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends2(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends2(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends2(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends2(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v2 = node[n];
          if (typeof v2 != "object") {
            if (v2 != node2[n]) {
              node2[n] = v2;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "Á",
      aacute: "á",
      Abreve: "Ă",
      abreve: "ă",
      ac: "∾",
      acd: "∿",
      acE: "∾̳",
      Acirc: "Â",
      acirc: "â",
      acute: "´",
      Acy: "А",
      acy: "а",
      AElig: "Æ",
      aelig: "æ",
      af: "⁡",
      Afr: "𝔄",
      afr: "𝔞",
      Agrave: "À",
      agrave: "à",
      alefsym: "ℵ",
      aleph: "ℵ",
      Alpha: "Α",
      alpha: "α",
      Amacr: "Ā",
      amacr: "ā",
      amalg: "⨿",
      AMP: "&",
      amp: "&",
      And: "⩓",
      and: "∧",
      andand: "⩕",
      andd: "⩜",
      andslope: "⩘",
      andv: "⩚",
      ang: "∠",
      ange: "⦤",
      angle: "∠",
      angmsd: "∡",
      angmsdaa: "⦨",
      angmsdab: "⦩",
      angmsdac: "⦪",
      angmsdad: "⦫",
      angmsdae: "⦬",
      angmsdaf: "⦭",
      angmsdag: "⦮",
      angmsdah: "⦯",
      angrt: "∟",
      angrtvb: "⊾",
      angrtvbd: "⦝",
      angsph: "∢",
      angst: "Å",
      angzarr: "⍼",
      Aogon: "Ą",
      aogon: "ą",
      Aopf: "𝔸",
      aopf: "𝕒",
      ap: "≈",
      apacir: "⩯",
      apE: "⩰",
      ape: "≊",
      apid: "≋",
      apos: "'",
      ApplyFunction: "⁡",
      approx: "≈",
      approxeq: "≊",
      Aring: "Å",
      aring: "å",
      Ascr: "𝒜",
      ascr: "𝒶",
      Assign: "≔",
      ast: "*",
      asymp: "≈",
      asympeq: "≍",
      Atilde: "Ã",
      atilde: "ã",
      Auml: "Ä",
      auml: "ä",
      awconint: "∳",
      awint: "⨑",
      backcong: "≌",
      backepsilon: "϶",
      backprime: "‵",
      backsim: "∽",
      backsimeq: "⋍",
      Backslash: "∖",
      Barv: "⫧",
      barvee: "⊽",
      Barwed: "⌆",
      barwed: "⌅",
      barwedge: "⌅",
      bbrk: "⎵",
      bbrktbrk: "⎶",
      bcong: "≌",
      Bcy: "Б",
      bcy: "б",
      bdquo: "„",
      becaus: "∵",
      Because: "∵",
      because: "∵",
      bemptyv: "⦰",
      bepsi: "϶",
      bernou: "ℬ",
      Bernoullis: "ℬ",
      Beta: "Β",
      beta: "β",
      beth: "ℶ",
      between: "≬",
      Bfr: "𝔅",
      bfr: "𝔟",
      bigcap: "⋂",
      bigcirc: "◯",
      bigcup: "⋃",
      bigodot: "⨀",
      bigoplus: "⨁",
      bigotimes: "⨂",
      bigsqcup: "⨆",
      bigstar: "★",
      bigtriangledown: "▽",
      bigtriangleup: "△",
      biguplus: "⨄",
      bigvee: "⋁",
      bigwedge: "⋀",
      bkarow: "⤍",
      blacklozenge: "⧫",
      blacksquare: "▪",
      blacktriangle: "▴",
      blacktriangledown: "▾",
      blacktriangleleft: "◂",
      blacktriangleright: "▸",
      blank: "␣",
      blk12: "▒",
      blk14: "░",
      blk34: "▓",
      block: "█",
      bne: "=⃥",
      bnequiv: "≡⃥",
      bNot: "⫭",
      bnot: "⌐",
      Bopf: "𝔹",
      bopf: "𝕓",
      bot: "⊥",
      bottom: "⊥",
      bowtie: "⋈",
      boxbox: "⧉",
      boxDL: "╗",
      boxDl: "╖",
      boxdL: "╕",
      boxdl: "┐",
      boxDR: "╔",
      boxDr: "╓",
      boxdR: "╒",
      boxdr: "┌",
      boxH: "═",
      boxh: "─",
      boxHD: "╦",
      boxHd: "╤",
      boxhD: "╥",
      boxhd: "┬",
      boxHU: "╩",
      boxHu: "╧",
      boxhU: "╨",
      boxhu: "┴",
      boxminus: "⊟",
      boxplus: "⊞",
      boxtimes: "⊠",
      boxUL: "╝",
      boxUl: "╜",
      boxuL: "╛",
      boxul: "┘",
      boxUR: "╚",
      boxUr: "╙",
      boxuR: "╘",
      boxur: "└",
      boxV: "║",
      boxv: "│",
      boxVH: "╬",
      boxVh: "╫",
      boxvH: "╪",
      boxvh: "┼",
      boxVL: "╣",
      boxVl: "╢",
      boxvL: "╡",
      boxvl: "┤",
      boxVR: "╠",
      boxVr: "╟",
      boxvR: "╞",
      boxvr: "├",
      bprime: "‵",
      Breve: "˘",
      breve: "˘",
      brvbar: "¦",
      Bscr: "ℬ",
      bscr: "𝒷",
      bsemi: "⁏",
      bsim: "∽",
      bsime: "⋍",
      bsol: "\\",
      bsolb: "⧅",
      bsolhsub: "⟈",
      bull: "•",
      bullet: "•",
      bump: "≎",
      bumpE: "⪮",
      bumpe: "≏",
      Bumpeq: "≎",
      bumpeq: "≏",
      Cacute: "Ć",
      cacute: "ć",
      Cap: "⋒",
      cap: "∩",
      capand: "⩄",
      capbrcup: "⩉",
      capcap: "⩋",
      capcup: "⩇",
      capdot: "⩀",
      CapitalDifferentialD: "ⅅ",
      caps: "∩︀",
      caret: "⁁",
      caron: "ˇ",
      Cayleys: "ℭ",
      ccaps: "⩍",
      Ccaron: "Č",
      ccaron: "č",
      Ccedil: "Ç",
      ccedil: "ç",
      Ccirc: "Ĉ",
      ccirc: "ĉ",
      Cconint: "∰",
      ccups: "⩌",
      ccupssm: "⩐",
      Cdot: "Ċ",
      cdot: "ċ",
      cedil: "¸",
      Cedilla: "¸",
      cemptyv: "⦲",
      cent: "¢",
      CenterDot: "·",
      centerdot: "·",
      Cfr: "ℭ",
      cfr: "𝔠",
      CHcy: "Ч",
      chcy: "ч",
      check: "✓",
      checkmark: "✓",
      Chi: "Χ",
      chi: "χ",
      cir: "○",
      circ: "ˆ",
      circeq: "≗",
      circlearrowleft: "↺",
      circlearrowright: "↻",
      circledast: "⊛",
      circledcirc: "⊚",
      circleddash: "⊝",
      CircleDot: "⊙",
      circledR: "®",
      circledS: "Ⓢ",
      CircleMinus: "⊖",
      CirclePlus: "⊕",
      CircleTimes: "⊗",
      cirE: "⧃",
      cire: "≗",
      cirfnint: "⨐",
      cirmid: "⫯",
      cirscir: "⧂",
      ClockwiseContourIntegral: "∲",
      CloseCurlyDoubleQuote: "”",
      CloseCurlyQuote: "’",
      clubs: "♣",
      clubsuit: "♣",
      Colon: "∷",
      colon: ":",
      Colone: "⩴",
      colone: "≔",
      coloneq: "≔",
      comma: ",",
      commat: "@",
      comp: "∁",
      compfn: "∘",
      complement: "∁",
      complexes: "ℂ",
      cong: "≅",
      congdot: "⩭",
      Congruent: "≡",
      Conint: "∯",
      conint: "∮",
      ContourIntegral: "∮",
      Copf: "ℂ",
      copf: "𝕔",
      coprod: "∐",
      Coproduct: "∐",
      COPY: "©",
      copy: "©",
      copysr: "℗",
      CounterClockwiseContourIntegral: "∳",
      crarr: "↵",
      Cross: "⨯",
      cross: "✗",
      Cscr: "𝒞",
      cscr: "𝒸",
      csub: "⫏",
      csube: "⫑",
      csup: "⫐",
      csupe: "⫒",
      ctdot: "⋯",
      cudarrl: "⤸",
      cudarrr: "⤵",
      cuepr: "⋞",
      cuesc: "⋟",
      cularr: "↶",
      cularrp: "⤽",
      Cup: "⋓",
      cup: "∪",
      cupbrcap: "⩈",
      CupCap: "≍",
      cupcap: "⩆",
      cupcup: "⩊",
      cupdot: "⊍",
      cupor: "⩅",
      cups: "∪︀",
      curarr: "↷",
      curarrm: "⤼",
      curlyeqprec: "⋞",
      curlyeqsucc: "⋟",
      curlyvee: "⋎",
      curlywedge: "⋏",
      curren: "¤",
      curvearrowleft: "↶",
      curvearrowright: "↷",
      cuvee: "⋎",
      cuwed: "⋏",
      cwconint: "∲",
      cwint: "∱",
      cylcty: "⌭",
      Dagger: "‡",
      dagger: "†",
      daleth: "ℸ",
      Darr: "↡",
      dArr: "⇓",
      darr: "↓",
      dash: "‐",
      Dashv: "⫤",
      dashv: "⊣",
      dbkarow: "⤏",
      dblac: "˝",
      Dcaron: "Ď",
      dcaron: "ď",
      Dcy: "Д",
      dcy: "д",
      DD: "ⅅ",
      dd: "ⅆ",
      ddagger: "‡",
      ddarr: "⇊",
      DDotrahd: "⤑",
      ddotseq: "⩷",
      deg: "°",
      Del: "∇",
      Delta: "Δ",
      delta: "δ",
      demptyv: "⦱",
      dfisht: "⥿",
      Dfr: "𝔇",
      dfr: "𝔡",
      dHar: "⥥",
      dharl: "⇃",
      dharr: "⇂",
      DiacriticalAcute: "´",
      DiacriticalDot: "˙",
      DiacriticalDoubleAcute: "˝",
      DiacriticalGrave: "`",
      DiacriticalTilde: "˜",
      diam: "⋄",
      Diamond: "⋄",
      diamond: "⋄",
      diamondsuit: "♦",
      diams: "♦",
      die: "¨",
      DifferentialD: "ⅆ",
      digamma: "ϝ",
      disin: "⋲",
      div: "÷",
      divide: "÷",
      divideontimes: "⋇",
      divonx: "⋇",
      DJcy: "Ђ",
      djcy: "ђ",
      dlcorn: "⌞",
      dlcrop: "⌍",
      dollar: "$",
      Dopf: "𝔻",
      dopf: "𝕕",
      Dot: "¨",
      dot: "˙",
      DotDot: "⃜",
      doteq: "≐",
      doteqdot: "≑",
      DotEqual: "≐",
      dotminus: "∸",
      dotplus: "∔",
      dotsquare: "⊡",
      doublebarwedge: "⌆",
      DoubleContourIntegral: "∯",
      DoubleDot: "¨",
      DoubleDownArrow: "⇓",
      DoubleLeftArrow: "⇐",
      DoubleLeftRightArrow: "⇔",
      DoubleLeftTee: "⫤",
      DoubleLongLeftArrow: "⟸",
      DoubleLongLeftRightArrow: "⟺",
      DoubleLongRightArrow: "⟹",
      DoubleRightArrow: "⇒",
      DoubleRightTee: "⊨",
      DoubleUpArrow: "⇑",
      DoubleUpDownArrow: "⇕",
      DoubleVerticalBar: "∥",
      DownArrow: "↓",
      Downarrow: "⇓",
      downarrow: "↓",
      DownArrowBar: "⤓",
      DownArrowUpArrow: "⇵",
      DownBreve: "̑",
      downdownarrows: "⇊",
      downharpoonleft: "⇃",
      downharpoonright: "⇂",
      DownLeftRightVector: "⥐",
      DownLeftTeeVector: "⥞",
      DownLeftVector: "↽",
      DownLeftVectorBar: "⥖",
      DownRightTeeVector: "⥟",
      DownRightVector: "⇁",
      DownRightVectorBar: "⥗",
      DownTee: "⊤",
      DownTeeArrow: "↧",
      drbkarow: "⤐",
      drcorn: "⌟",
      drcrop: "⌌",
      Dscr: "𝒟",
      dscr: "𝒹",
      DScy: "Ѕ",
      dscy: "ѕ",
      dsol: "⧶",
      Dstrok: "Đ",
      dstrok: "đ",
      dtdot: "⋱",
      dtri: "▿",
      dtrif: "▾",
      duarr: "⇵",
      duhar: "⥯",
      dwangle: "⦦",
      DZcy: "Џ",
      dzcy: "џ",
      dzigrarr: "⟿",
      Eacute: "É",
      eacute: "é",
      easter: "⩮",
      Ecaron: "Ě",
      ecaron: "ě",
      ecir: "≖",
      Ecirc: "Ê",
      ecirc: "ê",
      ecolon: "≕",
      Ecy: "Э",
      ecy: "э",
      eDDot: "⩷",
      Edot: "Ė",
      eDot: "≑",
      edot: "ė",
      ee: "ⅇ",
      efDot: "≒",
      Efr: "𝔈",
      efr: "𝔢",
      eg: "⪚",
      Egrave: "È",
      egrave: "è",
      egs: "⪖",
      egsdot: "⪘",
      el: "⪙",
      Element: "∈",
      elinters: "⏧",
      ell: "ℓ",
      els: "⪕",
      elsdot: "⪗",
      Emacr: "Ē",
      emacr: "ē",
      empty: "∅",
      emptyset: "∅",
      EmptySmallSquare: "◻",
      emptyv: "∅",
      EmptyVerySmallSquare: "▫",
      emsp: " ",
      emsp13: " ",
      emsp14: " ",
      ENG: "Ŋ",
      eng: "ŋ",
      ensp: " ",
      Eogon: "Ę",
      eogon: "ę",
      Eopf: "𝔼",
      eopf: "𝕖",
      epar: "⋕",
      eparsl: "⧣",
      eplus: "⩱",
      epsi: "ε",
      Epsilon: "Ε",
      epsilon: "ε",
      epsiv: "ϵ",
      eqcirc: "≖",
      eqcolon: "≕",
      eqsim: "≂",
      eqslantgtr: "⪖",
      eqslantless: "⪕",
      Equal: "⩵",
      equals: "=",
      EqualTilde: "≂",
      equest: "≟",
      Equilibrium: "⇌",
      equiv: "≡",
      equivDD: "⩸",
      eqvparsl: "⧥",
      erarr: "⥱",
      erDot: "≓",
      Escr: "ℰ",
      escr: "ℯ",
      esdot: "≐",
      Esim: "⩳",
      esim: "≂",
      Eta: "Η",
      eta: "η",
      ETH: "Ð",
      eth: "ð",
      Euml: "Ë",
      euml: "ë",
      euro: "€",
      excl: "!",
      exist: "∃",
      Exists: "∃",
      expectation: "ℰ",
      ExponentialE: "ⅇ",
      exponentiale: "ⅇ",
      fallingdotseq: "≒",
      Fcy: "Ф",
      fcy: "ф",
      female: "♀",
      ffilig: "ﬃ",
      fflig: "ﬀ",
      ffllig: "ﬄ",
      Ffr: "𝔉",
      ffr: "𝔣",
      filig: "ﬁ",
      FilledSmallSquare: "◼",
      FilledVerySmallSquare: "▪",
      fjlig: "fj",
      flat: "♭",
      fllig: "ﬂ",
      fltns: "▱",
      fnof: "ƒ",
      Fopf: "𝔽",
      fopf: "𝕗",
      ForAll: "∀",
      forall: "∀",
      fork: "⋔",
      forkv: "⫙",
      Fouriertrf: "ℱ",
      fpartint: "⨍",
      frac12: "½",
      frac13: "⅓",
      frac14: "¼",
      frac15: "⅕",
      frac16: "⅙",
      frac18: "⅛",
      frac23: "⅔",
      frac25: "⅖",
      frac34: "¾",
      frac35: "⅗",
      frac38: "⅜",
      frac45: "⅘",
      frac56: "⅚",
      frac58: "⅝",
      frac78: "⅞",
      frasl: "⁄",
      frown: "⌢",
      Fscr: "ℱ",
      fscr: "𝒻",
      gacute: "ǵ",
      Gamma: "Γ",
      gamma: "γ",
      Gammad: "Ϝ",
      gammad: "ϝ",
      gap: "⪆",
      Gbreve: "Ğ",
      gbreve: "ğ",
      Gcedil: "Ģ",
      Gcirc: "Ĝ",
      gcirc: "ĝ",
      Gcy: "Г",
      gcy: "г",
      Gdot: "Ġ",
      gdot: "ġ",
      gE: "≧",
      ge: "≥",
      gEl: "⪌",
      gel: "⋛",
      geq: "≥",
      geqq: "≧",
      geqslant: "⩾",
      ges: "⩾",
      gescc: "⪩",
      gesdot: "⪀",
      gesdoto: "⪂",
      gesdotol: "⪄",
      gesl: "⋛︀",
      gesles: "⪔",
      Gfr: "𝔊",
      gfr: "𝔤",
      Gg: "⋙",
      gg: "≫",
      ggg: "⋙",
      gimel: "ℷ",
      GJcy: "Ѓ",
      gjcy: "ѓ",
      gl: "≷",
      gla: "⪥",
      glE: "⪒",
      glj: "⪤",
      gnap: "⪊",
      gnapprox: "⪊",
      gnE: "≩",
      gne: "⪈",
      gneq: "⪈",
      gneqq: "≩",
      gnsim: "⋧",
      Gopf: "𝔾",
      gopf: "𝕘",
      grave: "`",
      GreaterEqual: "≥",
      GreaterEqualLess: "⋛",
      GreaterFullEqual: "≧",
      GreaterGreater: "⪢",
      GreaterLess: "≷",
      GreaterSlantEqual: "⩾",
      GreaterTilde: "≳",
      Gscr: "𝒢",
      gscr: "ℊ",
      gsim: "≳",
      gsime: "⪎",
      gsiml: "⪐",
      Gt: "≫",
      GT: ">",
      gt: ">",
      gtcc: "⪧",
      gtcir: "⩺",
      gtdot: "⋗",
      gtlPar: "⦕",
      gtquest: "⩼",
      gtrapprox: "⪆",
      gtrarr: "⥸",
      gtrdot: "⋗",
      gtreqless: "⋛",
      gtreqqless: "⪌",
      gtrless: "≷",
      gtrsim: "≳",
      gvertneqq: "≩︀",
      gvnE: "≩︀",
      Hacek: "ˇ",
      hairsp: " ",
      half: "½",
      hamilt: "ℋ",
      HARDcy: "Ъ",
      hardcy: "ъ",
      hArr: "⇔",
      harr: "↔",
      harrcir: "⥈",
      harrw: "↭",
      Hat: "^",
      hbar: "ℏ",
      Hcirc: "Ĥ",
      hcirc: "ĥ",
      hearts: "♥",
      heartsuit: "♥",
      hellip: "…",
      hercon: "⊹",
      Hfr: "ℌ",
      hfr: "𝔥",
      HilbertSpace: "ℋ",
      hksearow: "⤥",
      hkswarow: "⤦",
      hoarr: "⇿",
      homtht: "∻",
      hookleftarrow: "↩",
      hookrightarrow: "↪",
      Hopf: "ℍ",
      hopf: "𝕙",
      horbar: "―",
      HorizontalLine: "─",
      Hscr: "ℋ",
      hscr: "𝒽",
      hslash: "ℏ",
      Hstrok: "Ħ",
      hstrok: "ħ",
      HumpDownHump: "≎",
      HumpEqual: "≏",
      hybull: "⁃",
      hyphen: "‐",
      Iacute: "Í",
      iacute: "í",
      ic: "⁣",
      Icirc: "Î",
      icirc: "î",
      Icy: "И",
      icy: "и",
      Idot: "İ",
      IEcy: "Е",
      iecy: "е",
      iexcl: "¡",
      iff: "⇔",
      Ifr: "ℑ",
      ifr: "𝔦",
      Igrave: "Ì",
      igrave: "ì",
      ii: "ⅈ",
      iiiint: "⨌",
      iiint: "∭",
      iinfin: "⧜",
      iiota: "℩",
      IJlig: "Ĳ",
      ijlig: "ĳ",
      Im: "ℑ",
      Imacr: "Ī",
      imacr: "ī",
      image: "ℑ",
      ImaginaryI: "ⅈ",
      imagline: "ℐ",
      imagpart: "ℑ",
      imath: "ı",
      imof: "⊷",
      imped: "Ƶ",
      Implies: "⇒",
      in: "∈",
      incare: "℅",
      infin: "∞",
      infintie: "⧝",
      inodot: "ı",
      Int: "∬",
      int: "∫",
      intcal: "⊺",
      integers: "ℤ",
      Integral: "∫",
      intercal: "⊺",
      Intersection: "⋂",
      intlarhk: "⨗",
      intprod: "⨼",
      InvisibleComma: "⁣",
      InvisibleTimes: "⁢",
      IOcy: "Ё",
      iocy: "ё",
      Iogon: "Į",
      iogon: "į",
      Iopf: "𝕀",
      iopf: "𝕚",
      Iota: "Ι",
      iota: "ι",
      iprod: "⨼",
      iquest: "¿",
      Iscr: "ℐ",
      iscr: "𝒾",
      isin: "∈",
      isindot: "⋵",
      isinE: "⋹",
      isins: "⋴",
      isinsv: "⋳",
      isinv: "∈",
      it: "⁢",
      Itilde: "Ĩ",
      itilde: "ĩ",
      Iukcy: "І",
      iukcy: "і",
      Iuml: "Ï",
      iuml: "ï",
      Jcirc: "Ĵ",
      jcirc: "ĵ",
      Jcy: "Й",
      jcy: "й",
      Jfr: "𝔍",
      jfr: "𝔧",
      jmath: "ȷ",
      Jopf: "𝕁",
      jopf: "𝕛",
      Jscr: "𝒥",
      jscr: "𝒿",
      Jsercy: "Ј",
      jsercy: "ј",
      Jukcy: "Є",
      jukcy: "є",
      Kappa: "Κ",
      kappa: "κ",
      kappav: "ϰ",
      Kcedil: "Ķ",
      kcedil: "ķ",
      Kcy: "К",
      kcy: "к",
      Kfr: "𝔎",
      kfr: "𝔨",
      kgreen: "ĸ",
      KHcy: "Х",
      khcy: "х",
      KJcy: "Ќ",
      kjcy: "ќ",
      Kopf: "𝕂",
      kopf: "𝕜",
      Kscr: "𝒦",
      kscr: "𝓀",
      lAarr: "⇚",
      Lacute: "Ĺ",
      lacute: "ĺ",
      laemptyv: "⦴",
      lagran: "ℒ",
      Lambda: "Λ",
      lambda: "λ",
      Lang: "⟪",
      lang: "⟨",
      langd: "⦑",
      langle: "⟨",
      lap: "⪅",
      Laplacetrf: "ℒ",
      laquo: "«",
      Larr: "↞",
      lArr: "⇐",
      larr: "←",
      larrb: "⇤",
      larrbfs: "⤟",
      larrfs: "⤝",
      larrhk: "↩",
      larrlp: "↫",
      larrpl: "⤹",
      larrsim: "⥳",
      larrtl: "↢",
      lat: "⪫",
      lAtail: "⤛",
      latail: "⤙",
      late: "⪭",
      lates: "⪭︀",
      lBarr: "⤎",
      lbarr: "⤌",
      lbbrk: "❲",
      lbrace: "{",
      lbrack: "[",
      lbrke: "⦋",
      lbrksld: "⦏",
      lbrkslu: "⦍",
      Lcaron: "Ľ",
      lcaron: "ľ",
      Lcedil: "Ļ",
      lcedil: "ļ",
      lceil: "⌈",
      lcub: "{",
      Lcy: "Л",
      lcy: "л",
      ldca: "⤶",
      ldquo: "“",
      ldquor: "„",
      ldrdhar: "⥧",
      ldrushar: "⥋",
      ldsh: "↲",
      lE: "≦",
      le: "≤",
      LeftAngleBracket: "⟨",
      LeftArrow: "←",
      Leftarrow: "⇐",
      leftarrow: "←",
      LeftArrowBar: "⇤",
      LeftArrowRightArrow: "⇆",
      leftarrowtail: "↢",
      LeftCeiling: "⌈",
      LeftDoubleBracket: "⟦",
      LeftDownTeeVector: "⥡",
      LeftDownVector: "⇃",
      LeftDownVectorBar: "⥙",
      LeftFloor: "⌊",
      leftharpoondown: "↽",
      leftharpoonup: "↼",
      leftleftarrows: "⇇",
      LeftRightArrow: "↔",
      Leftrightarrow: "⇔",
      leftrightarrow: "↔",
      leftrightarrows: "⇆",
      leftrightharpoons: "⇋",
      leftrightsquigarrow: "↭",
      LeftRightVector: "⥎",
      LeftTee: "⊣",
      LeftTeeArrow: "↤",
      LeftTeeVector: "⥚",
      leftthreetimes: "⋋",
      LeftTriangle: "⊲",
      LeftTriangleBar: "⧏",
      LeftTriangleEqual: "⊴",
      LeftUpDownVector: "⥑",
      LeftUpTeeVector: "⥠",
      LeftUpVector: "↿",
      LeftUpVectorBar: "⥘",
      LeftVector: "↼",
      LeftVectorBar: "⥒",
      lEg: "⪋",
      leg: "⋚",
      leq: "≤",
      leqq: "≦",
      leqslant: "⩽",
      les: "⩽",
      lescc: "⪨",
      lesdot: "⩿",
      lesdoto: "⪁",
      lesdotor: "⪃",
      lesg: "⋚︀",
      lesges: "⪓",
      lessapprox: "⪅",
      lessdot: "⋖",
      lesseqgtr: "⋚",
      lesseqqgtr: "⪋",
      LessEqualGreater: "⋚",
      LessFullEqual: "≦",
      LessGreater: "≶",
      lessgtr: "≶",
      LessLess: "⪡",
      lesssim: "≲",
      LessSlantEqual: "⩽",
      LessTilde: "≲",
      lfisht: "⥼",
      lfloor: "⌊",
      Lfr: "𝔏",
      lfr: "𝔩",
      lg: "≶",
      lgE: "⪑",
      lHar: "⥢",
      lhard: "↽",
      lharu: "↼",
      lharul: "⥪",
      lhblk: "▄",
      LJcy: "Љ",
      ljcy: "љ",
      Ll: "⋘",
      ll: "≪",
      llarr: "⇇",
      llcorner: "⌞",
      Lleftarrow: "⇚",
      llhard: "⥫",
      lltri: "◺",
      Lmidot: "Ŀ",
      lmidot: "ŀ",
      lmoust: "⎰",
      lmoustache: "⎰",
      lnap: "⪉",
      lnapprox: "⪉",
      lnE: "≨",
      lne: "⪇",
      lneq: "⪇",
      lneqq: "≨",
      lnsim: "⋦",
      loang: "⟬",
      loarr: "⇽",
      lobrk: "⟦",
      LongLeftArrow: "⟵",
      Longleftarrow: "⟸",
      longleftarrow: "⟵",
      LongLeftRightArrow: "⟷",
      Longleftrightarrow: "⟺",
      longleftrightarrow: "⟷",
      longmapsto: "⟼",
      LongRightArrow: "⟶",
      Longrightarrow: "⟹",
      longrightarrow: "⟶",
      looparrowleft: "↫",
      looparrowright: "↬",
      lopar: "⦅",
      Lopf: "𝕃",
      lopf: "𝕝",
      loplus: "⨭",
      lotimes: "⨴",
      lowast: "∗",
      lowbar: "_",
      LowerLeftArrow: "↙",
      LowerRightArrow: "↘",
      loz: "◊",
      lozenge: "◊",
      lozf: "⧫",
      lpar: "(",
      lparlt: "⦓",
      lrarr: "⇆",
      lrcorner: "⌟",
      lrhar: "⇋",
      lrhard: "⥭",
      lrm: "‎",
      lrtri: "⊿",
      lsaquo: "‹",
      Lscr: "ℒ",
      lscr: "𝓁",
      Lsh: "↰",
      lsh: "↰",
      lsim: "≲",
      lsime: "⪍",
      lsimg: "⪏",
      lsqb: "[",
      lsquo: "‘",
      lsquor: "‚",
      Lstrok: "Ł",
      lstrok: "ł",
      Lt: "≪",
      LT: "<",
      lt: "<",
      ltcc: "⪦",
      ltcir: "⩹",
      ltdot: "⋖",
      lthree: "⋋",
      ltimes: "⋉",
      ltlarr: "⥶",
      ltquest: "⩻",
      ltri: "◃",
      ltrie: "⊴",
      ltrif: "◂",
      ltrPar: "⦖",
      lurdshar: "⥊",
      luruhar: "⥦",
      lvertneqq: "≨︀",
      lvnE: "≨︀",
      macr: "¯",
      male: "♂",
      malt: "✠",
      maltese: "✠",
      Map: "⤅",
      map: "↦",
      mapsto: "↦",
      mapstodown: "↧",
      mapstoleft: "↤",
      mapstoup: "↥",
      marker: "▮",
      mcomma: "⨩",
      Mcy: "М",
      mcy: "м",
      mdash: "—",
      mDDot: "∺",
      measuredangle: "∡",
      MediumSpace: " ",
      Mellintrf: "ℳ",
      Mfr: "𝔐",
      mfr: "𝔪",
      mho: "℧",
      micro: "µ",
      mid: "∣",
      midast: "*",
      midcir: "⫰",
      middot: "·",
      minus: "−",
      minusb: "⊟",
      minusd: "∸",
      minusdu: "⨪",
      MinusPlus: "∓",
      mlcp: "⫛",
      mldr: "…",
      mnplus: "∓",
      models: "⊧",
      Mopf: "𝕄",
      mopf: "𝕞",
      mp: "∓",
      Mscr: "ℳ",
      mscr: "𝓂",
      mstpos: "∾",
      Mu: "Μ",
      mu: "μ",
      multimap: "⊸",
      mumap: "⊸",
      nabla: "∇",
      Nacute: "Ń",
      nacute: "ń",
      nang: "∠⃒",
      nap: "≉",
      napE: "⩰̸",
      napid: "≋̸",
      napos: "ŉ",
      napprox: "≉",
      natur: "♮",
      natural: "♮",
      naturals: "ℕ",
      nbsp: " ",
      nbump: "≎̸",
      nbumpe: "≏̸",
      ncap: "⩃",
      Ncaron: "Ň",
      ncaron: "ň",
      Ncedil: "Ņ",
      ncedil: "ņ",
      ncong: "≇",
      ncongdot: "⩭̸",
      ncup: "⩂",
      Ncy: "Н",
      ncy: "н",
      ndash: "–",
      ne: "≠",
      nearhk: "⤤",
      neArr: "⇗",
      nearr: "↗",
      nearrow: "↗",
      nedot: "≐̸",
      NegativeMediumSpace: "​",
      NegativeThickSpace: "​",
      NegativeThinSpace: "​",
      NegativeVeryThinSpace: "​",
      nequiv: "≢",
      nesear: "⤨",
      nesim: "≂̸",
      NestedGreaterGreater: "≫",
      NestedLessLess: "≪",
      NewLine: "\n",
      nexist: "∄",
      nexists: "∄",
      Nfr: "𝔑",
      nfr: "𝔫",
      ngE: "≧̸",
      nge: "≱",
      ngeq: "≱",
      ngeqq: "≧̸",
      ngeqslant: "⩾̸",
      nges: "⩾̸",
      nGg: "⋙̸",
      ngsim: "≵",
      nGt: "≫⃒",
      ngt: "≯",
      ngtr: "≯",
      nGtv: "≫̸",
      nhArr: "⇎",
      nharr: "↮",
      nhpar: "⫲",
      ni: "∋",
      nis: "⋼",
      nisd: "⋺",
      niv: "∋",
      NJcy: "Њ",
      njcy: "њ",
      nlArr: "⇍",
      nlarr: "↚",
      nldr: "‥",
      nlE: "≦̸",
      nle: "≰",
      nLeftarrow: "⇍",
      nleftarrow: "↚",
      nLeftrightarrow: "⇎",
      nleftrightarrow: "↮",
      nleq: "≰",
      nleqq: "≦̸",
      nleqslant: "⩽̸",
      nles: "⩽̸",
      nless: "≮",
      nLl: "⋘̸",
      nlsim: "≴",
      nLt: "≪⃒",
      nlt: "≮",
      nltri: "⋪",
      nltrie: "⋬",
      nLtv: "≪̸",
      nmid: "∤",
      NoBreak: "⁠",
      NonBreakingSpace: " ",
      Nopf: "ℕ",
      nopf: "𝕟",
      Not: "⫬",
      not: "¬",
      NotCongruent: "≢",
      NotCupCap: "≭",
      NotDoubleVerticalBar: "∦",
      NotElement: "∉",
      NotEqual: "≠",
      NotEqualTilde: "≂̸",
      NotExists: "∄",
      NotGreater: "≯",
      NotGreaterEqual: "≱",
      NotGreaterFullEqual: "≧̸",
      NotGreaterGreater: "≫̸",
      NotGreaterLess: "≹",
      NotGreaterSlantEqual: "⩾̸",
      NotGreaterTilde: "≵",
      NotHumpDownHump: "≎̸",
      NotHumpEqual: "≏̸",
      notin: "∉",
      notindot: "⋵̸",
      notinE: "⋹̸",
      notinva: "∉",
      notinvb: "⋷",
      notinvc: "⋶",
      NotLeftTriangle: "⋪",
      NotLeftTriangleBar: "⧏̸",
      NotLeftTriangleEqual: "⋬",
      NotLess: "≮",
      NotLessEqual: "≰",
      NotLessGreater: "≸",
      NotLessLess: "≪̸",
      NotLessSlantEqual: "⩽̸",
      NotLessTilde: "≴",
      NotNestedGreaterGreater: "⪢̸",
      NotNestedLessLess: "⪡̸",
      notni: "∌",
      notniva: "∌",
      notnivb: "⋾",
      notnivc: "⋽",
      NotPrecedes: "⊀",
      NotPrecedesEqual: "⪯̸",
      NotPrecedesSlantEqual: "⋠",
      NotReverseElement: "∌",
      NotRightTriangle: "⋫",
      NotRightTriangleBar: "⧐̸",
      NotRightTriangleEqual: "⋭",
      NotSquareSubset: "⊏̸",
      NotSquareSubsetEqual: "⋢",
      NotSquareSuperset: "⊐̸",
      NotSquareSupersetEqual: "⋣",
      NotSubset: "⊂⃒",
      NotSubsetEqual: "⊈",
      NotSucceeds: "⊁",
      NotSucceedsEqual: "⪰̸",
      NotSucceedsSlantEqual: "⋡",
      NotSucceedsTilde: "≿̸",
      NotSuperset: "⊃⃒",
      NotSupersetEqual: "⊉",
      NotTilde: "≁",
      NotTildeEqual: "≄",
      NotTildeFullEqual: "≇",
      NotTildeTilde: "≉",
      NotVerticalBar: "∤",
      npar: "∦",
      nparallel: "∦",
      nparsl: "⫽⃥",
      npart: "∂̸",
      npolint: "⨔",
      npr: "⊀",
      nprcue: "⋠",
      npre: "⪯̸",
      nprec: "⊀",
      npreceq: "⪯̸",
      nrArr: "⇏",
      nrarr: "↛",
      nrarrc: "⤳̸",
      nrarrw: "↝̸",
      nRightarrow: "⇏",
      nrightarrow: "↛",
      nrtri: "⋫",
      nrtrie: "⋭",
      nsc: "⊁",
      nsccue: "⋡",
      nsce: "⪰̸",
      Nscr: "𝒩",
      nscr: "𝓃",
      nshortmid: "∤",
      nshortparallel: "∦",
      nsim: "≁",
      nsime: "≄",
      nsimeq: "≄",
      nsmid: "∤",
      nspar: "∦",
      nsqsube: "⋢",
      nsqsupe: "⋣",
      nsub: "⊄",
      nsubE: "⫅̸",
      nsube: "⊈",
      nsubset: "⊂⃒",
      nsubseteq: "⊈",
      nsubseteqq: "⫅̸",
      nsucc: "⊁",
      nsucceq: "⪰̸",
      nsup: "⊅",
      nsupE: "⫆̸",
      nsupe: "⊉",
      nsupset: "⊃⃒",
      nsupseteq: "⊉",
      nsupseteqq: "⫆̸",
      ntgl: "≹",
      Ntilde: "Ñ",
      ntilde: "ñ",
      ntlg: "≸",
      ntriangleleft: "⋪",
      ntrianglelefteq: "⋬",
      ntriangleright: "⋫",
      ntrianglerighteq: "⋭",
      Nu: "Ν",
      nu: "ν",
      num: "#",
      numero: "№",
      numsp: " ",
      nvap: "≍⃒",
      nVDash: "⊯",
      nVdash: "⊮",
      nvDash: "⊭",
      nvdash: "⊬",
      nvge: "≥⃒",
      nvgt: ">⃒",
      nvHarr: "⤄",
      nvinfin: "⧞",
      nvlArr: "⤂",
      nvle: "≤⃒",
      nvlt: "<⃒",
      nvltrie: "⊴⃒",
      nvrArr: "⤃",
      nvrtrie: "⊵⃒",
      nvsim: "∼⃒",
      nwarhk: "⤣",
      nwArr: "⇖",
      nwarr: "↖",
      nwarrow: "↖",
      nwnear: "⤧",
      Oacute: "Ó",
      oacute: "ó",
      oast: "⊛",
      ocir: "⊚",
      Ocirc: "Ô",
      ocirc: "ô",
      Ocy: "О",
      ocy: "о",
      odash: "⊝",
      Odblac: "Ő",
      odblac: "ő",
      odiv: "⨸",
      odot: "⊙",
      odsold: "⦼",
      OElig: "Œ",
      oelig: "œ",
      ofcir: "⦿",
      Ofr: "𝔒",
      ofr: "𝔬",
      ogon: "˛",
      Ograve: "Ò",
      ograve: "ò",
      ogt: "⧁",
      ohbar: "⦵",
      ohm: "Ω",
      oint: "∮",
      olarr: "↺",
      olcir: "⦾",
      olcross: "⦻",
      oline: "‾",
      olt: "⧀",
      Omacr: "Ō",
      omacr: "ō",
      Omega: "Ω",
      omega: "ω",
      Omicron: "Ο",
      omicron: "ο",
      omid: "⦶",
      ominus: "⊖",
      Oopf: "𝕆",
      oopf: "𝕠",
      opar: "⦷",
      OpenCurlyDoubleQuote: "“",
      OpenCurlyQuote: "‘",
      operp: "⦹",
      oplus: "⊕",
      Or: "⩔",
      or: "∨",
      orarr: "↻",
      ord: "⩝",
      order: "ℴ",
      orderof: "ℴ",
      ordf: "ª",
      ordm: "º",
      origof: "⊶",
      oror: "⩖",
      orslope: "⩗",
      orv: "⩛",
      oS: "Ⓢ",
      Oscr: "𝒪",
      oscr: "ℴ",
      Oslash: "Ø",
      oslash: "ø",
      osol: "⊘",
      Otilde: "Õ",
      otilde: "õ",
      Otimes: "⨷",
      otimes: "⊗",
      otimesas: "⨶",
      Ouml: "Ö",
      ouml: "ö",
      ovbar: "⌽",
      OverBar: "‾",
      OverBrace: "⏞",
      OverBracket: "⎴",
      OverParenthesis: "⏜",
      par: "∥",
      para: "¶",
      parallel: "∥",
      parsim: "⫳",
      parsl: "⫽",
      part: "∂",
      PartialD: "∂",
      Pcy: "П",
      pcy: "п",
      percnt: "%",
      period: ".",
      permil: "‰",
      perp: "⊥",
      pertenk: "‱",
      Pfr: "𝔓",
      pfr: "𝔭",
      Phi: "Φ",
      phi: "φ",
      phiv: "ϕ",
      phmmat: "ℳ",
      phone: "☎",
      Pi: "Π",
      pi: "π",
      pitchfork: "⋔",
      piv: "ϖ",
      planck: "ℏ",
      planckh: "ℎ",
      plankv: "ℏ",
      plus: "+",
      plusacir: "⨣",
      plusb: "⊞",
      pluscir: "⨢",
      plusdo: "∔",
      plusdu: "⨥",
      pluse: "⩲",
      PlusMinus: "±",
      plusmn: "±",
      plussim: "⨦",
      plustwo: "⨧",
      pm: "±",
      Poincareplane: "ℌ",
      pointint: "⨕",
      Popf: "ℙ",
      popf: "𝕡",
      pound: "£",
      Pr: "⪻",
      pr: "≺",
      prap: "⪷",
      prcue: "≼",
      prE: "⪳",
      pre: "⪯",
      prec: "≺",
      precapprox: "⪷",
      preccurlyeq: "≼",
      Precedes: "≺",
      PrecedesEqual: "⪯",
      PrecedesSlantEqual: "≼",
      PrecedesTilde: "≾",
      preceq: "⪯",
      precnapprox: "⪹",
      precneqq: "⪵",
      precnsim: "⋨",
      precsim: "≾",
      Prime: "″",
      prime: "′",
      primes: "ℙ",
      prnap: "⪹",
      prnE: "⪵",
      prnsim: "⋨",
      prod: "∏",
      Product: "∏",
      profalar: "⌮",
      profline: "⌒",
      profsurf: "⌓",
      prop: "∝",
      Proportion: "∷",
      Proportional: "∝",
      propto: "∝",
      prsim: "≾",
      prurel: "⊰",
      Pscr: "𝒫",
      pscr: "𝓅",
      Psi: "Ψ",
      psi: "ψ",
      puncsp: " ",
      Qfr: "𝔔",
      qfr: "𝔮",
      qint: "⨌",
      Qopf: "ℚ",
      qopf: "𝕢",
      qprime: "⁗",
      Qscr: "𝒬",
      qscr: "𝓆",
      quaternions: "ℍ",
      quatint: "⨖",
      quest: "?",
      questeq: "≟",
      QUOT: '"',
      quot: '"',
      rAarr: "⇛",
      race: "∽̱",
      Racute: "Ŕ",
      racute: "ŕ",
      radic: "√",
      raemptyv: "⦳",
      Rang: "⟫",
      rang: "⟩",
      rangd: "⦒",
      range: "⦥",
      rangle: "⟩",
      raquo: "»",
      Rarr: "↠",
      rArr: "⇒",
      rarr: "→",
      rarrap: "⥵",
      rarrb: "⇥",
      rarrbfs: "⤠",
      rarrc: "⤳",
      rarrfs: "⤞",
      rarrhk: "↪",
      rarrlp: "↬",
      rarrpl: "⥅",
      rarrsim: "⥴",
      Rarrtl: "⤖",
      rarrtl: "↣",
      rarrw: "↝",
      rAtail: "⤜",
      ratail: "⤚",
      ratio: "∶",
      rationals: "ℚ",
      RBarr: "⤐",
      rBarr: "⤏",
      rbarr: "⤍",
      rbbrk: "❳",
      rbrace: "}",
      rbrack: "]",
      rbrke: "⦌",
      rbrksld: "⦎",
      rbrkslu: "⦐",
      Rcaron: "Ř",
      rcaron: "ř",
      Rcedil: "Ŗ",
      rcedil: "ŗ",
      rceil: "⌉",
      rcub: "}",
      Rcy: "Р",
      rcy: "р",
      rdca: "⤷",
      rdldhar: "⥩",
      rdquo: "”",
      rdquor: "”",
      rdsh: "↳",
      Re: "ℜ",
      real: "ℜ",
      realine: "ℛ",
      realpart: "ℜ",
      reals: "ℝ",
      rect: "▭",
      REG: "®",
      reg: "®",
      ReverseElement: "∋",
      ReverseEquilibrium: "⇋",
      ReverseUpEquilibrium: "⥯",
      rfisht: "⥽",
      rfloor: "⌋",
      Rfr: "ℜ",
      rfr: "𝔯",
      rHar: "⥤",
      rhard: "⇁",
      rharu: "⇀",
      rharul: "⥬",
      Rho: "Ρ",
      rho: "ρ",
      rhov: "ϱ",
      RightAngleBracket: "⟩",
      RightArrow: "→",
      Rightarrow: "⇒",
      rightarrow: "→",
      RightArrowBar: "⇥",
      RightArrowLeftArrow: "⇄",
      rightarrowtail: "↣",
      RightCeiling: "⌉",
      RightDoubleBracket: "⟧",
      RightDownTeeVector: "⥝",
      RightDownVector: "⇂",
      RightDownVectorBar: "⥕",
      RightFloor: "⌋",
      rightharpoondown: "⇁",
      rightharpoonup: "⇀",
      rightleftarrows: "⇄",
      rightleftharpoons: "⇌",
      rightrightarrows: "⇉",
      rightsquigarrow: "↝",
      RightTee: "⊢",
      RightTeeArrow: "↦",
      RightTeeVector: "⥛",
      rightthreetimes: "⋌",
      RightTriangle: "⊳",
      RightTriangleBar: "⧐",
      RightTriangleEqual: "⊵",
      RightUpDownVector: "⥏",
      RightUpTeeVector: "⥜",
      RightUpVector: "↾",
      RightUpVectorBar: "⥔",
      RightVector: "⇀",
      RightVectorBar: "⥓",
      ring: "˚",
      risingdotseq: "≓",
      rlarr: "⇄",
      rlhar: "⇌",
      rlm: "‏",
      rmoust: "⎱",
      rmoustache: "⎱",
      rnmid: "⫮",
      roang: "⟭",
      roarr: "⇾",
      robrk: "⟧",
      ropar: "⦆",
      Ropf: "ℝ",
      ropf: "𝕣",
      roplus: "⨮",
      rotimes: "⨵",
      RoundImplies: "⥰",
      rpar: ")",
      rpargt: "⦔",
      rppolint: "⨒",
      rrarr: "⇉",
      Rrightarrow: "⇛",
      rsaquo: "›",
      Rscr: "ℛ",
      rscr: "𝓇",
      Rsh: "↱",
      rsh: "↱",
      rsqb: "]",
      rsquo: "’",
      rsquor: "’",
      rthree: "⋌",
      rtimes: "⋊",
      rtri: "▹",
      rtrie: "⊵",
      rtrif: "▸",
      rtriltri: "⧎",
      RuleDelayed: "⧴",
      ruluhar: "⥨",
      rx: "℞",
      Sacute: "Ś",
      sacute: "ś",
      sbquo: "‚",
      Sc: "⪼",
      sc: "≻",
      scap: "⪸",
      Scaron: "Š",
      scaron: "š",
      sccue: "≽",
      scE: "⪴",
      sce: "⪰",
      Scedil: "Ş",
      scedil: "ş",
      Scirc: "Ŝ",
      scirc: "ŝ",
      scnap: "⪺",
      scnE: "⪶",
      scnsim: "⋩",
      scpolint: "⨓",
      scsim: "≿",
      Scy: "С",
      scy: "с",
      sdot: "⋅",
      sdotb: "⊡",
      sdote: "⩦",
      searhk: "⤥",
      seArr: "⇘",
      searr: "↘",
      searrow: "↘",
      sect: "§",
      semi: ";",
      seswar: "⤩",
      setminus: "∖",
      setmn: "∖",
      sext: "✶",
      Sfr: "𝔖",
      sfr: "𝔰",
      sfrown: "⌢",
      sharp: "♯",
      SHCHcy: "Щ",
      shchcy: "щ",
      SHcy: "Ш",
      shcy: "ш",
      ShortDownArrow: "↓",
      ShortLeftArrow: "←",
      shortmid: "∣",
      shortparallel: "∥",
      ShortRightArrow: "→",
      ShortUpArrow: "↑",
      shy: "­",
      Sigma: "Σ",
      sigma: "σ",
      sigmaf: "ς",
      sigmav: "ς",
      sim: "∼",
      simdot: "⩪",
      sime: "≃",
      simeq: "≃",
      simg: "⪞",
      simgE: "⪠",
      siml: "⪝",
      simlE: "⪟",
      simne: "≆",
      simplus: "⨤",
      simrarr: "⥲",
      slarr: "←",
      SmallCircle: "∘",
      smallsetminus: "∖",
      smashp: "⨳",
      smeparsl: "⧤",
      smid: "∣",
      smile: "⌣",
      smt: "⪪",
      smte: "⪬",
      smtes: "⪬︀",
      SOFTcy: "Ь",
      softcy: "ь",
      sol: "/",
      solb: "⧄",
      solbar: "⌿",
      Sopf: "𝕊",
      sopf: "𝕤",
      spades: "♠",
      spadesuit: "♠",
      spar: "∥",
      sqcap: "⊓",
      sqcaps: "⊓︀",
      sqcup: "⊔",
      sqcups: "⊔︀",
      Sqrt: "√",
      sqsub: "⊏",
      sqsube: "⊑",
      sqsubset: "⊏",
      sqsubseteq: "⊑",
      sqsup: "⊐",
      sqsupe: "⊒",
      sqsupset: "⊐",
      sqsupseteq: "⊒",
      squ: "□",
      Square: "□",
      square: "□",
      SquareIntersection: "⊓",
      SquareSubset: "⊏",
      SquareSubsetEqual: "⊑",
      SquareSuperset: "⊐",
      SquareSupersetEqual: "⊒",
      SquareUnion: "⊔",
      squarf: "▪",
      squf: "▪",
      srarr: "→",
      Sscr: "𝒮",
      sscr: "𝓈",
      ssetmn: "∖",
      ssmile: "⌣",
      sstarf: "⋆",
      Star: "⋆",
      star: "☆",
      starf: "★",
      straightepsilon: "ϵ",
      straightphi: "ϕ",
      strns: "¯",
      Sub: "⋐",
      sub: "⊂",
      subdot: "⪽",
      subE: "⫅",
      sube: "⊆",
      subedot: "⫃",
      submult: "⫁",
      subnE: "⫋",
      subne: "⊊",
      subplus: "⪿",
      subrarr: "⥹",
      Subset: "⋐",
      subset: "⊂",
      subseteq: "⊆",
      subseteqq: "⫅",
      SubsetEqual: "⊆",
      subsetneq: "⊊",
      subsetneqq: "⫋",
      subsim: "⫇",
      subsub: "⫕",
      subsup: "⫓",
      succ: "≻",
      succapprox: "⪸",
      succcurlyeq: "≽",
      Succeeds: "≻",
      SucceedsEqual: "⪰",
      SucceedsSlantEqual: "≽",
      SucceedsTilde: "≿",
      succeq: "⪰",
      succnapprox: "⪺",
      succneqq: "⪶",
      succnsim: "⋩",
      succsim: "≿",
      SuchThat: "∋",
      Sum: "∑",
      sum: "∑",
      sung: "♪",
      Sup: "⋑",
      sup: "⊃",
      sup1: "¹",
      sup2: "²",
      sup3: "³",
      supdot: "⪾",
      supdsub: "⫘",
      supE: "⫆",
      supe: "⊇",
      supedot: "⫄",
      Superset: "⊃",
      SupersetEqual: "⊇",
      suphsol: "⟉",
      suphsub: "⫗",
      suplarr: "⥻",
      supmult: "⫂",
      supnE: "⫌",
      supne: "⊋",
      supplus: "⫀",
      Supset: "⋑",
      supset: "⊃",
      supseteq: "⊇",
      supseteqq: "⫆",
      supsetneq: "⊋",
      supsetneqq: "⫌",
      supsim: "⫈",
      supsub: "⫔",
      supsup: "⫖",
      swarhk: "⤦",
      swArr: "⇙",
      swarr: "↙",
      swarrow: "↙",
      swnwar: "⤪",
      szlig: "ß",
      Tab: "	",
      target: "⌖",
      Tau: "Τ",
      tau: "τ",
      tbrk: "⎴",
      Tcaron: "Ť",
      tcaron: "ť",
      Tcedil: "Ţ",
      tcedil: "ţ",
      Tcy: "Т",
      tcy: "т",
      tdot: "⃛",
      telrec: "⌕",
      Tfr: "𝔗",
      tfr: "𝔱",
      there4: "∴",
      Therefore: "∴",
      therefore: "∴",
      Theta: "Θ",
      theta: "θ",
      thetasym: "ϑ",
      thetav: "ϑ",
      thickapprox: "≈",
      thicksim: "∼",
      ThickSpace: "  ",
      thinsp: " ",
      ThinSpace: " ",
      thkap: "≈",
      thksim: "∼",
      THORN: "Þ",
      thorn: "þ",
      Tilde: "∼",
      tilde: "˜",
      TildeEqual: "≃",
      TildeFullEqual: "≅",
      TildeTilde: "≈",
      times: "×",
      timesb: "⊠",
      timesbar: "⨱",
      timesd: "⨰",
      tint: "∭",
      toea: "⤨",
      top: "⊤",
      topbot: "⌶",
      topcir: "⫱",
      Topf: "𝕋",
      topf: "𝕥",
      topfork: "⫚",
      tosa: "⤩",
      tprime: "‴",
      TRADE: "™",
      trade: "™",
      triangle: "▵",
      triangledown: "▿",
      triangleleft: "◃",
      trianglelefteq: "⊴",
      triangleq: "≜",
      triangleright: "▹",
      trianglerighteq: "⊵",
      tridot: "◬",
      trie: "≜",
      triminus: "⨺",
      TripleDot: "⃛",
      triplus: "⨹",
      trisb: "⧍",
      tritime: "⨻",
      trpezium: "⏢",
      Tscr: "𝒯",
      tscr: "𝓉",
      TScy: "Ц",
      tscy: "ц",
      TSHcy: "Ћ",
      tshcy: "ћ",
      Tstrok: "Ŧ",
      tstrok: "ŧ",
      twixt: "≬",
      twoheadleftarrow: "↞",
      twoheadrightarrow: "↠",
      Uacute: "Ú",
      uacute: "ú",
      Uarr: "↟",
      uArr: "⇑",
      uarr: "↑",
      Uarrocir: "⥉",
      Ubrcy: "Ў",
      ubrcy: "ў",
      Ubreve: "Ŭ",
      ubreve: "ŭ",
      Ucirc: "Û",
      ucirc: "û",
      Ucy: "У",
      ucy: "у",
      udarr: "⇅",
      Udblac: "Ű",
      udblac: "ű",
      udhar: "⥮",
      ufisht: "⥾",
      Ufr: "𝔘",
      ufr: "𝔲",
      Ugrave: "Ù",
      ugrave: "ù",
      uHar: "⥣",
      uharl: "↿",
      uharr: "↾",
      uhblk: "▀",
      ulcorn: "⌜",
      ulcorner: "⌜",
      ulcrop: "⌏",
      ultri: "◸",
      Umacr: "Ū",
      umacr: "ū",
      uml: "¨",
      UnderBar: "_",
      UnderBrace: "⏟",
      UnderBracket: "⎵",
      UnderParenthesis: "⏝",
      Union: "⋃",
      UnionPlus: "⊎",
      Uogon: "Ų",
      uogon: "ų",
      Uopf: "𝕌",
      uopf: "𝕦",
      UpArrow: "↑",
      Uparrow: "⇑",
      uparrow: "↑",
      UpArrowBar: "⤒",
      UpArrowDownArrow: "⇅",
      UpDownArrow: "↕",
      Updownarrow: "⇕",
      updownarrow: "↕",
      UpEquilibrium: "⥮",
      upharpoonleft: "↿",
      upharpoonright: "↾",
      uplus: "⊎",
      UpperLeftArrow: "↖",
      UpperRightArrow: "↗",
      Upsi: "ϒ",
      upsi: "υ",
      upsih: "ϒ",
      Upsilon: "Υ",
      upsilon: "υ",
      UpTee: "⊥",
      UpTeeArrow: "↥",
      upuparrows: "⇈",
      urcorn: "⌝",
      urcorner: "⌝",
      urcrop: "⌎",
      Uring: "Ů",
      uring: "ů",
      urtri: "◹",
      Uscr: "𝒰",
      uscr: "𝓊",
      utdot: "⋰",
      Utilde: "Ũ",
      utilde: "ũ",
      utri: "▵",
      utrif: "▴",
      uuarr: "⇈",
      Uuml: "Ü",
      uuml: "ü",
      uwangle: "⦧",
      vangrt: "⦜",
      varepsilon: "ϵ",
      varkappa: "ϰ",
      varnothing: "∅",
      varphi: "ϕ",
      varpi: "ϖ",
      varpropto: "∝",
      vArr: "⇕",
      varr: "↕",
      varrho: "ϱ",
      varsigma: "ς",
      varsubsetneq: "⊊︀",
      varsubsetneqq: "⫋︀",
      varsupsetneq: "⊋︀",
      varsupsetneqq: "⫌︀",
      vartheta: "ϑ",
      vartriangleleft: "⊲",
      vartriangleright: "⊳",
      Vbar: "⫫",
      vBar: "⫨",
      vBarv: "⫩",
      Vcy: "В",
      vcy: "в",
      VDash: "⊫",
      Vdash: "⊩",
      vDash: "⊨",
      vdash: "⊢",
      Vdashl: "⫦",
      Vee: "⋁",
      vee: "∨",
      veebar: "⊻",
      veeeq: "≚",
      vellip: "⋮",
      Verbar: "‖",
      verbar: "|",
      Vert: "‖",
      vert: "|",
      VerticalBar: "∣",
      VerticalLine: "|",
      VerticalSeparator: "❘",
      VerticalTilde: "≀",
      VeryThinSpace: " ",
      Vfr: "𝔙",
      vfr: "𝔳",
      vltri: "⊲",
      vnsub: "⊂⃒",
      vnsup: "⊃⃒",
      Vopf: "𝕍",
      vopf: "𝕧",
      vprop: "∝",
      vrtri: "⊳",
      Vscr: "𝒱",
      vscr: "𝓋",
      vsubnE: "⫋︀",
      vsubne: "⊊︀",
      vsupnE: "⫌︀",
      vsupne: "⊋︀",
      Vvdash: "⊪",
      vzigzag: "⦚",
      Wcirc: "Ŵ",
      wcirc: "ŵ",
      wedbar: "⩟",
      Wedge: "⋀",
      wedge: "∧",
      wedgeq: "≙",
      weierp: "℘",
      Wfr: "𝔚",
      wfr: "𝔴",
      Wopf: "𝕎",
      wopf: "𝕨",
      wp: "℘",
      wr: "≀",
      wreath: "≀",
      Wscr: "𝒲",
      wscr: "𝓌",
      xcap: "⋂",
      xcirc: "◯",
      xcup: "⋃",
      xdtri: "▽",
      Xfr: "𝔛",
      xfr: "𝔵",
      xhArr: "⟺",
      xharr: "⟷",
      Xi: "Ξ",
      xi: "ξ",
      xlArr: "⟸",
      xlarr: "⟵",
      xmap: "⟼",
      xnis: "⋻",
      xodot: "⨀",
      Xopf: "𝕏",
      xopf: "𝕩",
      xoplus: "⨁",
      xotime: "⨂",
      xrArr: "⟹",
      xrarr: "⟶",
      Xscr: "𝒳",
      xscr: "𝓍",
      xsqcup: "⨆",
      xuplus: "⨄",
      xutri: "△",
      xvee: "⋁",
      xwedge: "⋀",
      Yacute: "Ý",
      yacute: "ý",
      YAcy: "Я",
      yacy: "я",
      Ycirc: "Ŷ",
      ycirc: "ŷ",
      Ycy: "Ы",
      ycy: "ы",
      yen: "¥",
      Yfr: "𝔜",
      yfr: "𝔶",
      YIcy: "Ї",
      yicy: "ї",
      Yopf: "𝕐",
      yopf: "𝕪",
      Yscr: "𝒴",
      yscr: "𝓎",
      YUcy: "Ю",
      yucy: "ю",
      Yuml: "Ÿ",
      yuml: "ÿ",
      Zacute: "Ź",
      zacute: "ź",
      Zcaron: "Ž",
      zcaron: "ž",
      Zcy: "З",
      zcy: "з",
      Zdot: "Ż",
      zdot: "ż",
      zeetrf: "ℨ",
      ZeroWidthSpace: "​",
      Zeta: "Ζ",
      zeta: "ζ",
      Zfr: "ℨ",
      zfr: "𝔷",
      ZHcy: "Ж",
      zhcy: "ж",
      zigrarr: "⇝",
      Zopf: "ℤ",
      zopf: "𝕫",
      Zscr: "𝒵",
      zscr: "𝓏",
      zwj: "‍",
      zwnj: "‌"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse3(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse3(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k2 = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k2)) {
          return entityMap[k2];
        } else if (k2.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k2.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start2) {
          var xt = source.substring(start2, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start2);
          domBuilder.characters(xt, 0, end2 - start2);
          start2 = end2;
        }
      }
      function position(p, m2) {
        while (p >= lineEnd && (m2 = linePattern.exec(source))) {
          lineStart = m2.index;
          lineEnd = lineStart + m2[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start2 = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start2);
          if (tagStart < 0) {
            if (!source.substr(start2).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start2));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start2) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start2) {
          start2 = end;
        } else {
          appendText(Math.max(tagStart, start2) + 1);
        }
      }
    }
    function copyLocator(f2, t2) {
      t2.lineNumber = f2.lineNumber;
      t2.columnNumber = f2.columnNumber;
      return t2;
    }
    function parseElementStartPart(source, start2, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start2;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start2, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start2, p);
              }
              start2 = p + 1;
              p = source.indexOf(c, start2);
              if (p > 0) {
                value = source.slice(start2, p);
                addAttribute(attrName, value, start2 - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start2, p);
              addAttribute(attrName, value, start2);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start2 = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start2, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start2, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start2, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start2, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start2);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start2);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          case "":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start2, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start2, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start2, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start2);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start2);
                  start2 = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start2 = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start2 = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start2, domBuilder, errorHandler) {
      var next = source.charAt(start2 + 2);
      switch (next) {
        case "-":
          if (source.charAt(start2 + 3) === "-") {
            var end = source.indexOf("-->", start2 + 4);
            if (end > start2) {
              domBuilder.comment(source, start2 + 4, end - start2 - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start2 + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start2 + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start2 + 9, end - start2 - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start2);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start2, domBuilder) {
      var end = source.indexOf("?>", start2);
      if (end) {
        var match = source.substring(start2, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start2) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start2;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser2(options) {
      this.options = options || { locator: {} };
    }
    DOMParser2.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start2, length) {
      },
      characters: function(chars, start2, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start2, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start2, length) {
      if (typeof chars == "string") {
        return chars.substr(start2, length);
      } else {
        if (chars.length >= start2 + length || start2) {
          return new java.lang.String(chars, start2, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.normalizeLineEndings = normalizeLineEndings;
    exports.DOMParser = DOMParser2;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/mux.js/lib/utils/numbers.js
var require_numbers = __commonJS({
  "node_modules/mux.js/lib/utils/numbers.js"(exports, module) {
    var MAX_UINT32 = Math.pow(2, 32);
    var getUint64 = function(uint8) {
      var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
      var value;
      if (dv.getBigUint64) {
        value = dv.getBigUint64(0);
        if (value < Number.MAX_SAFE_INTEGER) {
          return Number(value);
        }
        return value;
      }
      return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
    };
    module.exports = {
      getUint64,
      MAX_UINT32
    };
  }
});

// node_modules/mux.js/lib/tools/parse-sidx.js
var require_parse_sidx = __commonJS({
  "node_modules/mux.js/lib/tools/parse-sidx.js"(exports, module) {
    var getUint64 = require_numbers().getUint64;
    var parseSidx2 = function(data) {
      var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4)),
        references: [],
        referenceId: view.getUint32(4),
        timescale: view.getUint32(8)
      }, i = 12;
      if (result.version === 0) {
        result.earliestPresentationTime = view.getUint32(i);
        result.firstOffset = view.getUint32(i + 4);
        i += 8;
      } else {
        result.earliestPresentationTime = getUint64(data.subarray(i));
        result.firstOffset = getUint64(data.subarray(i + 8));
        i += 16;
      }
      i += 2;
      var referenceCount = view.getUint16(i);
      i += 2;
      for (; referenceCount > 0; i += 12, referenceCount--) {
        result.references.push({
          referenceType: (data[i] & 128) >>> 7,
          referencedSize: view.getUint32(i) & 2147483647,
          subsegmentDuration: view.getUint32(i + 4),
          startsWithSap: !!(data[i + 8] & 128),
          sapType: (data[i + 8] & 112) >>> 4,
          sapDeltaTime: view.getUint32(i + 8) & 268435455
        });
      }
      return result;
    };
    module.exports = parseSidx2;
  }
});

// node_modules/mux.js/lib/utils/clock.js
var require_clock = __commonJS({
  "node_modules/mux.js/lib/utils/clock.js"(exports, module) {
    var ONE_SECOND_IN_TS2 = 9e4;
    var secondsToVideoTs;
    var secondsToAudioTs;
    var videoTsToSeconds;
    var audioTsToSeconds;
    var audioTsToVideoTs;
    var videoTsToAudioTs;
    var metadataTsToSeconds;
    secondsToVideoTs = function(seconds) {
      return seconds * ONE_SECOND_IN_TS2;
    };
    secondsToAudioTs = function(seconds, sampleRate) {
      return seconds * sampleRate;
    };
    videoTsToSeconds = function(timestamp) {
      return timestamp / ONE_SECOND_IN_TS2;
    };
    audioTsToSeconds = function(timestamp, sampleRate) {
      return timestamp / sampleRate;
    };
    audioTsToVideoTs = function(timestamp, sampleRate) {
      return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
    };
    videoTsToAudioTs = function(timestamp, sampleRate) {
      return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
    };
    metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
      return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
    };
    module.exports = {
      ONE_SECOND_IN_TS: ONE_SECOND_IN_TS2,
      secondsToVideoTs,
      secondsToAudioTs,
      videoTsToSeconds,
      audioTsToSeconds,
      audioTsToVideoTs,
      videoTsToAudioTs,
      metadataTsToSeconds
    };
  }
});

// node_modules/video.js/dist/video.es.js
var import_window6 = __toESM(require_window());
var import_document = __toESM(require_document());

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n[r2] = t2[r2]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/video.js/dist/video.es.js
var import_keycode = __toESM(require_keycode());

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t2, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
    return t3.__proto__ = e2, t3;
  }, _setPrototypeOf(t2, e);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t2, o) {
  t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o);
}

// node_modules/video.js/dist/video.es.js
var import_tuple = __toESM(require_tuple());
var import_xhr = __toESM(require_lib());
var import_videojs_vtt = __toESM(require_browser_index());

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t2, e, r2) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t2.bind.apply(t2, o))();
  return r2 && _setPrototypeOf(p, r2.prototype), p;
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t2, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t2,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t2, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t2, e);
}

// node_modules/@videojs/vhs-utils/es/resolve-url.js
var import_url_toolkit = __toESM(require_url_toolkit());
var import_window = __toESM(require_window());
var DEFAULT_LOCATION = "http://example.com";
var resolveUrl = function resolveUrl2(baseUrl, relativeUrl) {
  if (/^[a-z]+:/i.test(relativeUrl)) {
    return relativeUrl;
  }
  if (/^data:/.test(baseUrl)) {
    baseUrl = import_window.default.location && import_window.default.location.href || "";
  }
  var nativeURL = typeof import_window.default.URL === "function";
  var protocolLess = /^\/\//.test(baseUrl);
  var removeLocation = !import_window.default.location && !/\/\//i.test(baseUrl);
  if (nativeURL) {
    baseUrl = new import_window.default.URL(baseUrl, import_window.default.location || DEFAULT_LOCATION);
  } else if (!/\/\//i.test(baseUrl)) {
    baseUrl = import_url_toolkit.default.buildAbsoluteURL(import_window.default.location && import_window.default.location.href || "", baseUrl);
  }
  if (nativeURL) {
    var newUrl = new URL(relativeUrl, baseUrl);
    if (removeLocation) {
      return newUrl.href.slice(DEFAULT_LOCATION.length);
    } else if (protocolLess) {
      return newUrl.href.slice(newUrl.protocol.length);
    }
    return newUrl.href;
  }
  return import_url_toolkit.default.buildAbsoluteURL(baseUrl, relativeUrl);
};
var resolve_url_default = resolveUrl;

// node_modules/@videojs/vhs-utils/es/stream.js
var Stream = function() {
  function Stream2() {
    this.listeners = {};
  }
  var _proto = Stream2.prototype;
  _proto.on = function on3(type2, listener) {
    if (!this.listeners[type2]) {
      this.listeners[type2] = [];
    }
    this.listeners[type2].push(listener);
  };
  _proto.off = function off2(type2, listener) {
    if (!this.listeners[type2]) {
      return false;
    }
    var index = this.listeners[type2].indexOf(listener);
    this.listeners[type2] = this.listeners[type2].slice(0);
    this.listeners[type2].splice(index, 1);
    return index > -1;
  };
  _proto.trigger = function trigger2(type2) {
    var callbacks = this.listeners[type2];
    if (!callbacks) {
      return;
    }
    if (arguments.length === 2) {
      var length = callbacks.length;
      for (var i = 0; i < length; ++i) {
        callbacks[i].call(this, arguments[1]);
      }
    } else {
      var args = Array.prototype.slice.call(arguments, 1);
      var _length = callbacks.length;
      for (var _i = 0; _i < _length; ++_i) {
        callbacks[_i].apply(this, args);
      }
    }
  };
  _proto.dispose = function dispose() {
    this.listeners = {};
  };
  _proto.pipe = function pipe(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
  };
  return Stream2;
}();

// node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js
var import_window2 = __toESM(require_window());
var atob = function atob2(s) {
  return import_window2.default.atob ? import_window2.default.atob(s) : Buffer.from(s, "base64").toString("binary");
};
function decodeB64ToUint8Array(b64Text) {
  var decodedString = atob(b64Text);
  var array = new Uint8Array(decodedString.length);
  for (var i = 0; i < decodedString.length; i++) {
    array[i] = decodedString.charCodeAt(i);
  }
  return array;
}

// node_modules/m3u8-parser/dist/m3u8-parser.es.js
var LineStream = function(_Stream) {
  _inheritsLoose(LineStream2, _Stream);
  function LineStream2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.buffer = "";
    return _this;
  }
  var _proto = LineStream2.prototype;
  _proto.push = function push(data) {
    var nextNewline;
    this.buffer += data;
    nextNewline = this.buffer.indexOf("\n");
    for (; nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
      this.trigger("data", this.buffer.substring(0, nextNewline));
      this.buffer = this.buffer.substring(nextNewline + 1);
    }
  };
  return LineStream2;
}(Stream);
var TAB = String.fromCharCode(9);
var parseByterange = function parseByterange2(byterangeString) {
  var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
  var result = {};
  if (match[1]) {
    result.length = parseInt(match[1], 10);
  }
  if (match[2]) {
    result.offset = parseInt(match[2], 10);
  }
  return result;
};
var attributeSeparator = function attributeSeparator2() {
  var key = "[^=]*";
  var value = '"[^"]*"|[^,]*';
  var keyvalue = "(?:" + key + ")=(?:" + value + ")";
  return new RegExp("(?:^|,)(" + keyvalue + ")");
};
var parseAttributes = function parseAttributes2(attributes) {
  var attrs = attributes.split(attributeSeparator());
  var result = {};
  var i = attrs.length;
  var attr;
  while (i--) {
    if (attrs[i] === "") {
      continue;
    }
    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
    attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
    result[attr[0]] = attr[1];
  }
  return result;
};
var ParseStream = function(_Stream) {
  _inheritsLoose(ParseStream2, _Stream);
  function ParseStream2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.customParsers = [];
    _this.tagMappers = [];
    return _this;
  }
  var _proto = ParseStream2.prototype;
  _proto.push = function push(line) {
    var _this2 = this;
    var match;
    var event;
    line = line.trim();
    if (line.length === 0) {
      return;
    }
    if (line[0] !== "#") {
      this.trigger("data", {
        type: "uri",
        uri: line
      });
      return;
    }
    var newLines = this.tagMappers.reduce(function(acc, mapper) {
      var mappedLine = mapper(line);
      if (mappedLine === line) {
        return acc;
      }
      return acc.concat([mappedLine]);
    }, [line]);
    newLines.forEach(function(newLine) {
      for (var i = 0; i < _this2.customParsers.length; i++) {
        if (_this2.customParsers[i].call(_this2, newLine)) {
          return;
        }
      }
      if (newLine.indexOf("#EXT") !== 0) {
        _this2.trigger("data", {
          type: "comment",
          text: newLine.slice(1)
        });
        return;
      }
      newLine = newLine.replace("\r", "");
      match = /^#EXTM3U/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "m3u"
        });
        return;
      }
      match = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "inf"
        };
        if (match[1]) {
          event.duration = parseFloat(match[1]);
        }
        if (match[2]) {
          event.title = match[2];
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "targetduration"
        };
        if (match[1]) {
          event.duration = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "version"
        };
        if (match[1]) {
          event.version = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "media-sequence"
        };
        if (match[1]) {
          event.number = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "discontinuity-sequence"
        };
        if (match[1]) {
          event.number = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "playlist-type"
        };
        if (match[1]) {
          event.playlistType = match[1];
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);
      if (match) {
        event = _extends(parseByterange(match[1]), {
          type: "tag",
          tagType: "byterange"
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "allow-cache"
        };
        if (match[1]) {
          event.allowed = !/NO/.test(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "map"
        };
        if (match[1]) {
          var attributes = parseAttributes(match[1]);
          if (attributes.URI) {
            event.uri = attributes.URI;
          }
          if (attributes.BYTERANGE) {
            event.byterange = parseByterange(attributes.BYTERANGE);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "stream-inf"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          if (event.attributes.RESOLUTION) {
            var split = event.attributes.RESOLUTION.split("x");
            var resolution = {};
            if (split[0]) {
              resolution.width = parseInt(split[0], 10);
            }
            if (split[1]) {
              resolution.height = parseInt(split[1], 10);
            }
            event.attributes.RESOLUTION = resolution;
          }
          if (event.attributes.BANDWIDTH) {
            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
          }
          if (event.attributes["FRAME-RATE"]) {
            event.attributes["FRAME-RATE"] = parseFloat(event.attributes["FRAME-RATE"]);
          }
          if (event.attributes["PROGRAM-ID"]) {
            event.attributes["PROGRAM-ID"] = parseInt(event.attributes["PROGRAM-ID"], 10);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "media"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-ENDLIST/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "endlist"
        });
        return;
      }
      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "discontinuity"
        });
        return;
      }
      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "program-date-time"
        };
        if (match[1]) {
          event.dateTimeString = match[1];
          event.dateTimeObject = new Date(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "key"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          if (event.attributes.IV) {
            if (event.attributes.IV.substring(0, 2).toLowerCase() === "0x") {
              event.attributes.IV = event.attributes.IV.substring(2);
            }
            event.attributes.IV = event.attributes.IV.match(/.{8}/g);
            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
            event.attributes.IV = new Uint32Array(event.attributes.IV);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-START:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "start"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          event.attributes["TIME-OFFSET"] = parseFloat(event.attributes["TIME-OFFSET"]);
          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-out-cont"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-out"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-in"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "skip"
        };
        event.attributes = parseAttributes(match[1]);
        if (event.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) {
          event.attributes["SKIPPED-SEGMENTS"] = parseInt(event.attributes["SKIPPED-SEGMENTS"], 10);
        }
        if (event.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) {
          event.attributes["RECENTLY-REMOVED-DATERANGES"] = event.attributes["RECENTLY-REMOVED-DATERANGES"].split(TAB);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PART:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "part"
        };
        event.attributes = parseAttributes(match[1]);
        ["DURATION"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ["INDEPENDENT", "GAP"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });
        if (event.attributes.hasOwnProperty("BYTERANGE")) {
          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "server-control"
        };
        event.attributes = parseAttributes(match[1]);
        ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "part-inf"
        };
        event.attributes = parseAttributes(match[1]);
        ["PART-TARGET"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "preload-hint"
        };
        event.attributes = parseAttributes(match[1]);
        ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
            var subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
            event.attributes.byterange = event.attributes.byterange || {};
            event.attributes.byterange[subkey] = event.attributes[key];
            delete event.attributes[key];
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "rendition-report"
        };
        event.attributes = parseAttributes(match[1]);
        ["LAST-MSN", "LAST-PART"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      _this2.trigger("data", {
        type: "tag",
        data: newLine.slice(4)
      });
    });
  };
  _proto.addParser = function addParser(_ref) {
    var _this3 = this;
    var expression = _ref.expression, customType = _ref.customType, dataParser = _ref.dataParser, segment = _ref.segment;
    if (typeof dataParser !== "function") {
      dataParser = function dataParser2(line) {
        return line;
      };
    }
    this.customParsers.push(function(line) {
      var match = expression.exec(line);
      if (match) {
        _this3.trigger("data", {
          type: "custom",
          data: dataParser(line),
          customType,
          segment
        });
        return true;
      }
    });
  };
  _proto.addTagMapper = function addTagMapper(_ref2) {
    var expression = _ref2.expression, map = _ref2.map;
    var mapFn = function mapFn2(line) {
      if (expression.test(line)) {
        return map(line);
      }
      return line;
    };
    this.tagMappers.push(mapFn);
  };
  return ParseStream2;
}(Stream);
var camelCase = function camelCase2(str) {
  return str.toLowerCase().replace(/-(\w)/g, function(a) {
    return a[1].toUpperCase();
  });
};
var camelCaseKeys = function camelCaseKeys2(attributes) {
  var result = {};
  Object.keys(attributes).forEach(function(key) {
    result[camelCase(key)] = attributes[key];
  });
  return result;
};
var setHoldBack = function setHoldBack2(manifest) {
  var serverControl = manifest.serverControl, targetDuration = manifest.targetDuration, partTargetDuration = manifest.partTargetDuration;
  if (!serverControl) {
    return;
  }
  var tag = "#EXT-X-SERVER-CONTROL";
  var hb = "holdBack";
  var phb = "partHoldBack";
  var minTargetDuration = targetDuration && targetDuration * 3;
  var minPartDuration = partTargetDuration && partTargetDuration * 2;
  if (targetDuration && !serverControl.hasOwnProperty(hb)) {
    serverControl[hb] = minTargetDuration;
    this.trigger("info", {
      message: tag + " defaulting HOLD-BACK to targetDuration * 3 (" + minTargetDuration + ")."
    });
  }
  if (minTargetDuration && serverControl[hb] < minTargetDuration) {
    this.trigger("warn", {
      message: tag + " clamping HOLD-BACK (" + serverControl[hb] + ") to targetDuration * 3 (" + minTargetDuration + ")"
    });
    serverControl[hb] = minTargetDuration;
  }
  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
    serverControl[phb] = partTargetDuration * 3;
    this.trigger("info", {
      message: tag + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + serverControl[phb] + ")."
    });
  }
  if (partTargetDuration && serverControl[phb] < minPartDuration) {
    this.trigger("warn", {
      message: tag + " clamping PART-HOLD-BACK (" + serverControl[phb] + ") to partTargetDuration * 2 (" + minPartDuration + ")."
    });
    serverControl[phb] = minPartDuration;
  }
};
var Parser = function(_Stream) {
  _inheritsLoose(Parser2, _Stream);
  function Parser2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.lineStream = new LineStream();
    _this.parseStream = new ParseStream();
    _this.lineStream.pipe(_this.parseStream);
    var self2 = _assertThisInitialized(_this);
    var uris = [];
    var currentUri = {};
    var currentMap;
    var _key;
    var hasParts = false;
    var noop2 = function noop3() {
    };
    var defaultMediaGroups = {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    };
    var widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
    var currentTimeline = 0;
    _this.manifest = {
      allowCache: true,
      discontinuityStarts: [],
      segments: []
    };
    var lastByterangeEnd = 0;
    var lastPartByterangeEnd = 0;
    _this.on("end", function() {
      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
        return;
      }
      if (!currentUri.map && currentMap) {
        currentUri.map = currentMap;
      }
      if (!currentUri.key && _key) {
        currentUri.key = _key;
      }
      if (!currentUri.timeline && typeof currentTimeline === "number") {
        currentUri.timeline = currentTimeline;
      }
      _this.manifest.preloadSegment = currentUri;
    });
    _this.parseStream.on("data", function(entry) {
      var mediaGroup;
      var rendition;
      ({
        tag: function tag() {
          ({
            version: function version2() {
              if (entry.version) {
                this.manifest.version = entry.version;
              }
            },
            "allow-cache": function allowCache() {
              this.manifest.allowCache = entry.allowed;
              if (!("allowed" in entry)) {
                this.trigger("info", {
                  message: "defaulting allowCache to YES"
                });
                this.manifest.allowCache = true;
              }
            },
            byterange: function byterange() {
              var byterange2 = {};
              if ("length" in entry) {
                currentUri.byterange = byterange2;
                byterange2.length = entry.length;
                if (!("offset" in entry)) {
                  entry.offset = lastByterangeEnd;
                }
              }
              if ("offset" in entry) {
                currentUri.byterange = byterange2;
                byterange2.offset = entry.offset;
              }
              lastByterangeEnd = byterange2.offset + byterange2.length;
            },
            endlist: function endlist() {
              this.manifest.endList = true;
            },
            inf: function inf() {
              if (!("mediaSequence" in this.manifest)) {
                this.manifest.mediaSequence = 0;
                this.trigger("info", {
                  message: "defaulting media sequence to zero"
                });
              }
              if (!("discontinuitySequence" in this.manifest)) {
                this.manifest.discontinuitySequence = 0;
                this.trigger("info", {
                  message: "defaulting discontinuity sequence to zero"
                });
              }
              if (entry.duration > 0) {
                currentUri.duration = entry.duration;
              }
              if (entry.duration === 0) {
                currentUri.duration = 0.01;
                this.trigger("info", {
                  message: "updating zero segment duration to a small value"
                });
              }
              this.manifest.segments = uris;
            },
            key: function key() {
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (entry.attributes.METHOD === "NONE") {
                _key = null;
                return;
              }
              if (!entry.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: entry.attributes
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: entry.attributes.URI
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === widevineUuid) {
                var VALID_METHODS = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (entry.attributes.METHOD === "SAMPLE-AES-CENC") {
                  this.trigger("warn", {
                    message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                  });
                }
                if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: entry.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: entry.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(",")[1])
                };
                return;
              }
              if (!entry.attributes.METHOD) {
                this.trigger("warn", {
                  message: "defaulting key method to AES-128"
                });
              }
              _key = {
                method: entry.attributes.METHOD || "AES-128",
                uri: entry.attributes.URI
              };
              if (typeof entry.attributes.IV !== "undefined") {
                _key.iv = entry.attributes.IV;
              }
            },
            "media-sequence": function mediaSequence() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + entry.number
                });
                return;
              }
              this.manifest.mediaSequence = entry.number;
            },
            "discontinuity-sequence": function discontinuitySequence() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + entry.number
                });
                return;
              }
              this.manifest.discontinuitySequence = entry.number;
              currentTimeline = entry.number;
            },
            "playlist-type": function playlistType() {
              if (!/VOD|EVENT/.test(entry.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + entry.playlist
                });
                return;
              }
              this.manifest.playlistType = entry.playlistType;
            },
            map: function map() {
              currentMap = {};
              if (entry.uri) {
                currentMap.uri = entry.uri;
              }
              if (entry.byterange) {
                currentMap.byterange = entry.byterange;
              }
              if (_key) {
                currentMap.key = _key;
              }
            },
            "stream-inf": function streamInf() {
              this.manifest.playlists = uris;
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              if (!currentUri.attributes) {
                currentUri.attributes = {};
              }
              _extends(currentUri.attributes, entry.attributes);
            },
            media: function media() {
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
              mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
              mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
              rendition = {
                default: /yes/i.test(entry.attributes.DEFAULT)
              };
              if (rendition.default) {
                rendition.autoselect = true;
              } else {
                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
              }
              if (entry.attributes.LANGUAGE) {
                rendition.language = entry.attributes.LANGUAGE;
              }
              if (entry.attributes.URI) {
                rendition.uri = entry.attributes.URI;
              }
              if (entry.attributes["INSTREAM-ID"]) {
                rendition.instreamId = entry.attributes["INSTREAM-ID"];
              }
              if (entry.attributes.CHARACTERISTICS) {
                rendition.characteristics = entry.attributes.CHARACTERISTICS;
              }
              if (entry.attributes.FORCED) {
                rendition.forced = /yes/i.test(entry.attributes.FORCED);
              }
              mediaGroup[entry.attributes.NAME] = rendition;
            },
            discontinuity: function discontinuity() {
              currentTimeline += 1;
              currentUri.discontinuity = true;
              this.manifest.discontinuityStarts.push(uris.length);
            },
            "program-date-time": function programDateTime() {
              if (typeof this.manifest.dateTimeString === "undefined") {
                this.manifest.dateTimeString = entry.dateTimeString;
                this.manifest.dateTimeObject = entry.dateTimeObject;
              }
              currentUri.dateTimeString = entry.dateTimeString;
              currentUri.dateTimeObject = entry.dateTimeObject;
            },
            targetduration: function targetduration() {
              if (!isFinite(entry.duration) || entry.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + entry.duration
                });
                return;
              }
              this.manifest.targetDuration = entry.duration;
              setHoldBack.call(this, this.manifest);
            },
            start: function start2() {
              if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: entry.attributes["TIME-OFFSET"],
                precise: entry.attributes.PRECISE
              };
            },
            "cue-out": function cueOut() {
              currentUri.cueOut = entry.data;
            },
            "cue-out-cont": function cueOutCont() {
              currentUri.cueOutCont = entry.data;
            },
            "cue-in": function cueIn() {
              currentUri.cueIn = entry.data;
            },
            "skip": function skip() {
              this.manifest.skip = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, ["SKIPPED-SEGMENTS"]);
            },
            "part": function part() {
              var _this2 = this;
              hasParts = true;
              var segmentIndex = this.manifest.segments.length;
              var part2 = camelCaseKeys(entry.attributes);
              currentUri.parts = currentUri.parts || [];
              currentUri.parts.push(part2);
              if (part2.byterange) {
                if (!part2.byterange.hasOwnProperty("offset")) {
                  part2.byterange.offset = lastPartByterangeEnd;
                }
                lastPartByterangeEnd = part2.byterange.offset + part2.byterange.length;
              }
              var partIndex = currentUri.parts.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PART #" + partIndex + " for segment #" + segmentIndex, entry.attributes, ["URI", "DURATION"]);
              if (this.manifest.renditionReports) {
                this.manifest.renditionReports.forEach(function(r2, i) {
                  if (!r2.hasOwnProperty("lastPart")) {
                    _this2.trigger("warn", {
                      message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART"
                    });
                  }
                });
              }
            },
            "server-control": function serverControl() {
              var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
              if (!attrs.hasOwnProperty("canBlockReload")) {
                attrs.canBlockReload = false;
                this.trigger("info", {
                  message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                });
              }
              setHoldBack.call(this, this.manifest);
              if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) {
                this.trigger("warn", {
                  message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                });
              }
            },
            "preload-hint": function preloadHint() {
              var segmentIndex = this.manifest.segments.length;
              var hint = camelCaseKeys(entry.attributes);
              var isPart = hint.type && hint.type === "PART";
              currentUri.preloadHints = currentUri.preloadHints || [];
              currentUri.preloadHints.push(hint);
              if (hint.byterange) {
                if (!hint.byterange.hasOwnProperty("offset")) {
                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                  if (isPart) {
                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                  }
                }
              }
              var index = currentUri.preloadHints.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex, entry.attributes, ["TYPE", "URI"]);
              if (!hint.type) {
                return;
              }
              for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {
                var otherHint = currentUri.preloadHints[i];
                if (!otherHint.type) {
                  continue;
                }
                if (otherHint.type === hint.type) {
                  this.trigger("warn", {
                    message: "#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex + " has the same TYPE " + hint.type + " as preload hint #" + i
                  });
                }
              }
            },
            "rendition-report": function renditionReport() {
              var report = camelCaseKeys(entry.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [];
              this.manifest.renditionReports.push(report);
              var index = this.manifest.renditionReports.length - 1;
              var required = ["LAST-MSN", "URI"];
              if (hasParts) {
                required.push("LAST-PART");
              }
              this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + index, entry.attributes, required);
            },
            "part-inf": function partInf() {
              this.manifest.partInf = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, ["PART-TARGET"]);
              if (this.manifest.partInf.partTarget) {
                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
              }
              setHoldBack.call(this, this.manifest);
            }
          }[entry.tagType] || noop2).call(self2);
        },
        uri: function uri() {
          currentUri.uri = entry.uri;
          uris.push(currentUri);
          if (this.manifest.targetDuration && !("duration" in currentUri)) {
            this.trigger("warn", {
              message: "defaulting segment duration to the target duration"
            });
            currentUri.duration = this.manifest.targetDuration;
          }
          if (_key) {
            currentUri.key = _key;
          }
          currentUri.timeline = currentTimeline;
          if (currentMap) {
            currentUri.map = currentMap;
          }
          lastPartByterangeEnd = 0;
          currentUri = {};
        },
        comment: function comment() {
        },
        custom: function custom() {
          if (entry.segment) {
            currentUri.custom = currentUri.custom || {};
            currentUri.custom[entry.customType] = entry.data;
          } else {
            this.manifest.custom = this.manifest.custom || {};
            this.manifest.custom[entry.customType] = entry.data;
          }
        }
      })[entry.type].call(self2);
    });
    return _this;
  }
  var _proto = Parser2.prototype;
  _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {
    var missing = [];
    required.forEach(function(key) {
      if (!attributes.hasOwnProperty(key)) {
        missing.push(key);
      }
    });
    if (missing.length) {
      this.trigger("warn", {
        message: identifier + " lacks required attribute(s): " + missing.join(", ")
      });
    }
  };
  _proto.push = function push(chunk) {
    this.lineStream.push(chunk);
  };
  _proto.end = function end() {
    this.lineStream.push("\n");
    this.trigger("end");
  };
  _proto.addParser = function addParser(options) {
    this.parseStream.addParser(options);
  };
  _proto.addTagMapper = function addTagMapper(options) {
    this.parseStream.addTagMapper(options);
  };
  return Parser2;
}(Stream);

// node_modules/@videojs/vhs-utils/es/codecs.js
var import_window3 = __toESM(require_window());
var regexs = {
  // to determine mime types
  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
  // to determine if a codec is audio or video
  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
  text: /^(stpp.ttml.im1t)/,
  // mux.js support regex
  muxerVideo: /^(avc0?1)/,
  muxerAudio: /^(mp4a)/,
  // match nothing as muxer does not support text right now.
  // there cannot never be a character before the start of a string
  // so this matches nothing.
  muxerText: /a^/
};
var mediaTypes = ["video", "audio", "text"];
var upperMediaTypes = ["Video", "Audio", "Text"];
var translateLegacyCodec = function translateLegacyCodec2(codec) {
  if (!codec) {
    return codec;
  }
  return codec.replace(/avc1\.(\d+)\.(\d+)/i, function(orig, profile, avcLevel) {
    var profileHex = ("00" + Number(profile).toString(16)).slice(-2);
    var avcLevelHex = ("00" + Number(avcLevel).toString(16)).slice(-2);
    return "avc1." + profileHex + "00" + avcLevelHex;
  });
};
var parseCodecs = function parseCodecs2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  var codecs = codecString.split(",");
  var result = [];
  codecs.forEach(function(codec) {
    codec = codec.trim();
    var codecType;
    mediaTypes.forEach(function(name) {
      var match = regexs[name].exec(codec.toLowerCase());
      if (!match || match.length <= 1) {
        return;
      }
      codecType = name;
      var type2 = codec.substring(0, match[1].length);
      var details = codec.replace(type2, "");
      result.push({
        type: type2,
        details,
        mediaType: name
      });
    });
    if (!codecType) {
      result.push({
        type: codec,
        details: "",
        mediaType: "unknown"
      });
    }
  });
  return result;
};
var codecsFromDefault = function codecsFromDefault2(master, audioGroupId) {
  if (!master.mediaGroups.AUDIO || !audioGroupId) {
    return null;
  }
  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
  if (!audioGroup) {
    return null;
  }
  for (var name in audioGroup) {
    var audioType = audioGroup[name];
    if (audioType.default && audioType.playlists) {
      return parseCodecs(audioType.playlists[0].attributes.CODECS);
    }
  }
  return null;
};
var isAudioCodec = function isAudioCodec2(codec) {
  if (codec === void 0) {
    codec = "";
  }
  return regexs.audio.test(codec.trim().toLowerCase());
};
var isTextCodec = function isTextCodec2(codec) {
  if (codec === void 0) {
    codec = "";
  }
  return regexs.text.test(codec.trim().toLowerCase());
};
var getMimeForCodec = function getMimeForCodec2(codecString) {
  if (!codecString || typeof codecString !== "string") {
    return;
  }
  var codecs = codecString.toLowerCase().split(",").map(function(c) {
    return translateLegacyCodec(c.trim());
  });
  var type2 = "video";
  if (codecs.length === 1 && isAudioCodec(codecs[0])) {
    type2 = "audio";
  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {
    type2 = "application";
  }
  var container = "mp4";
  if (codecs.every(function(c) {
    return regexs.mp4.test(c);
  })) {
    container = "mp4";
  } else if (codecs.every(function(c) {
    return regexs.webm.test(c);
  })) {
    container = "webm";
  } else if (codecs.every(function(c) {
    return regexs.ogg.test(c);
  })) {
    container = "ogg";
  }
  return type2 + "/" + container + ';codecs="' + codecString + '"';
};
var browserSupportsCodec = function browserSupportsCodec2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  return import_window3.default.MediaSource && import_window3.default.MediaSource.isTypeSupported && import_window3.default.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;
};
var muxerSupportsCodec = function muxerSupportsCodec2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  return codecString.toLowerCase().split(",").every(function(codec) {
    codec = codec.trim();
    for (var i = 0; i < upperMediaTypes.length; i++) {
      var type2 = upperMediaTypes[i];
      if (regexs["muxer" + type2].test(codec)) {
        return true;
      }
    }
    return false;
  });
};
var DEFAULT_AUDIO_CODEC = "mp4a.40.2";
var DEFAULT_VIDEO_CODEC = "avc1.4d400d";

// node_modules/@videojs/vhs-utils/es/media-types.js
var MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
var DASH_REGEX = /^application\/dash\+xml/i;
var simpleTypeFromSourceType = function simpleTypeFromSourceType2(type2) {
  if (MPEGURL_REGEX.test(type2)) {
    return "hls";
  }
  if (DASH_REGEX.test(type2)) {
    return "dash";
  }
  if (type2 === "application/vnd.videojs.vhs+json") {
    return "vhs-json";
  }
  return null;
};

// node_modules/@videojs/vhs-utils/es/byte-helpers.js
var import_window4 = __toESM(require_window());
var countBits = function countBits2(x) {
  return x.toString(2).length;
};
var countBytes = function countBytes2(x) {
  return Math.ceil(countBits(x) / 8);
};
var isArrayBufferView = function isArrayBufferView2(obj) {
  if (ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(obj);
  }
  return obj && obj.buffer instanceof ArrayBuffer;
};
var isTypedArray = function isTypedArray2(obj) {
  return isArrayBufferView(obj);
};
var toUint8 = function toUint82(bytes) {
  if (bytes instanceof Uint8Array) {
    return bytes;
  }
  if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {
    if (typeof bytes !== "number" || typeof bytes === "number" && bytes !== bytes) {
      bytes = 0;
    } else {
      bytes = [bytes];
    }
  }
  return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
};
var BigInt = import_window4.default.BigInt || Number;
var BYTE_TABLE = [BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000")];
var ENDIANNESS = function() {
  var a = new Uint16Array([65484]);
  var b2 = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  if (b2[0] === 255) {
    return "big";
  }
  if (b2[0] === 204) {
    return "little";
  }
  return "unknown";
}();
var bytesToNumber = function bytesToNumber2(bytes, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$signed = _ref.signed, signed = _ref$signed === void 0 ? false : _ref$signed, _ref$le = _ref.le, le = _ref$le === void 0 ? false : _ref$le;
  bytes = toUint8(bytes);
  var fn = le ? "reduce" : "reduceRight";
  var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];
  var number = obj.call(bytes, function(total, byte, i) {
    var exponent = le ? i : Math.abs(i + 1 - bytes.length);
    return total + BigInt(byte) * BYTE_TABLE[exponent];
  }, BigInt(0));
  if (signed) {
    var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);
    number = BigInt(number);
    if (number > max) {
      number -= max;
      number -= max;
      number -= BigInt(2);
    }
  }
  return Number(number);
};
var numberToBytes = function numberToBytes2(number, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$le = _ref2.le, le = _ref2$le === void 0 ? false : _ref2$le;
  if (typeof number !== "bigint" && typeof number !== "number" || typeof number === "number" && number !== number) {
    number = 0;
  }
  number = BigInt(number);
  var byteCount = countBytes(number);
  var bytes = new Uint8Array(new ArrayBuffer(byteCount));
  for (var i = 0; i < byteCount; i++) {
    var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);
    bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(255));
    if (number < 0) {
      bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
      bytes[byteIndex] -= i === 0 ? 1 : 2;
    }
  }
  return bytes;
};
var bytesToString = function bytesToString2(bytes) {
  if (!bytes) {
    return "";
  }
  bytes = Array.prototype.slice.call(bytes);
  var string = String.fromCharCode.apply(null, toUint8(bytes));
  try {
    return decodeURIComponent(escape(string));
  } catch (e) {
  }
  return string;
};
var stringToBytes = function stringToBytes2(string, stringIsBytes) {
  if (typeof string !== "string" && string && typeof string.toString === "function") {
    string = string.toString();
  }
  if (typeof string !== "string") {
    return new Uint8Array();
  }
  if (!stringIsBytes) {
    string = unescape(encodeURIComponent(string));
  }
  var view = new Uint8Array(string.length);
  for (var i = 0; i < string.length; i++) {
    view[i] = string.charCodeAt(i);
  }
  return view;
};
var concatTypedArrays = function concatTypedArrays2() {
  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
    buffers[_key] = arguments[_key];
  }
  buffers = buffers.filter(function(b2) {
    return b2 && (b2.byteLength || b2.length) && typeof b2 !== "string";
  });
  if (buffers.length <= 1) {
    return toUint8(buffers[0]);
  }
  var totalLen = buffers.reduce(function(total, buf, i) {
    return total + (buf.byteLength || buf.length);
  }, 0);
  var tempBuffer = new Uint8Array(totalLen);
  var offset = 0;
  buffers.forEach(function(buf) {
    buf = toUint8(buf);
    tempBuffer.set(buf, offset);
    offset += buf.byteLength;
  });
  return tempBuffer;
};
var bytesMatch = function bytesMatch2(a, b2, _temp3) {
  var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$offset = _ref3.offset, offset = _ref3$offset === void 0 ? 0 : _ref3$offset, _ref3$mask = _ref3.mask, mask = _ref3$mask === void 0 ? [] : _ref3$mask;
  a = toUint8(a);
  b2 = toUint8(b2);
  var fn = b2.every ? b2.every : Array.prototype.every;
  return b2.length && a.length - offset >= b2.length && // ie 11 doesn't support every on uin8
  fn.call(b2, function(bByte, i) {
    var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];
    return bByte === aByte;
  });
};

// node_modules/mpd-parser/dist/mpd-parser.es.js
var import_window5 = __toESM(require_window());

// node_modules/@videojs/vhs-utils/es/media-groups.js
var forEachMediaGroup = function forEachMediaGroup2(master, groups, callback2) {
  groups.forEach(function(mediaType) {
    for (var groupKey in master.mediaGroups[mediaType]) {
      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
        callback2(mediaProperties, mediaType, groupKey, labelKey);
      }
    }
  });
};

// node_modules/mpd-parser/dist/mpd-parser.es.js
var import_xmldom = __toESM(require_lib2());
var isObject = function isObject2(obj) {
  return !!obj && typeof obj === "object";
};
var merge = function merge2() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  return objects.reduce(function(result, source) {
    if (typeof source !== "object") {
      return result;
    }
    Object.keys(source).forEach(function(key) {
      if (Array.isArray(result[key]) && Array.isArray(source[key])) {
        result[key] = result[key].concat(source[key]);
      } else if (isObject(result[key]) && isObject(source[key])) {
        result[key] = merge2(result[key], source[key]);
      } else {
        result[key] = source[key];
      }
    });
    return result;
  }, {});
};
var values = function values2(o) {
  return Object.keys(o).map(function(k2) {
    return o[k2];
  });
};
var range = function range2(start2, end) {
  var result = [];
  for (var i = start2; i < end; i++) {
    result.push(i);
  }
  return result;
};
var flatten = function flatten2(lists) {
  return lists.reduce(function(x, y2) {
    return x.concat(y2);
  }, []);
};
var from = function from2(list) {
  if (!list.length) {
    return [];
  }
  var result = [];
  for (var i = 0; i < list.length; i++) {
    result.push(list[i]);
  }
  return result;
};
var findIndexes = function findIndexes2(l, key) {
  return l.reduce(function(a, e, i) {
    if (e[key]) {
      a.push(i);
    }
    return a;
  }, []);
};
var findIndex = function findIndex2(list, matchingFunction) {
  for (var i = 0; i < list.length; i++) {
    if (matchingFunction(list[i])) {
      return i;
    }
  }
  return -1;
};
var union = function union2(lists, keyFunction) {
  return values(lists.reduce(function(acc, list) {
    list.forEach(function(el) {
      acc[keyFunction(el)] = el;
    });
    return acc;
  }, {}));
};
var errors = {
  INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
  DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
  DASH_INVALID_XML: "DASH_INVALID_XML",
  NO_BASE_URL: "NO_BASE_URL",
  MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
  SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
  UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
};
var urlTypeToSegment = function urlTypeToSegment2(_ref) {
  var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? "" : _ref$baseUrl, _ref$source = _ref.source, source = _ref$source === void 0 ? "" : _ref$source, _ref$range = _ref.range, range3 = _ref$range === void 0 ? "" : _ref$range, _ref$indexRange = _ref.indexRange, indexRange = _ref$indexRange === void 0 ? "" : _ref$indexRange;
  var segment = {
    uri: source,
    resolvedUri: resolve_url_default(baseUrl || "", source)
  };
  if (range3 || indexRange) {
    var rangeStr = range3 ? range3 : indexRange;
    var ranges = rangeStr.split("-");
    var startRange = import_window5.default.BigInt ? import_window5.default.BigInt(ranges[0]) : parseInt(ranges[0], 10);
    var endRange = import_window5.default.BigInt ? import_window5.default.BigInt(ranges[1]) : parseInt(ranges[1], 10);
    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === "bigint") {
      startRange = Number(startRange);
    }
    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === "bigint") {
      endRange = Number(endRange);
    }
    var length;
    if (typeof endRange === "bigint" || typeof startRange === "bigint") {
      length = import_window5.default.BigInt(endRange) - import_window5.default.BigInt(startRange) + import_window5.default.BigInt(1);
    } else {
      length = endRange - startRange + 1;
    }
    if (typeof length === "bigint" && length < Number.MAX_SAFE_INTEGER) {
      length = Number(length);
    }
    segment.byterange = {
      length,
      offset: startRange
    };
  }
  return segment;
};
var byteRangeToString = function byteRangeToString2(byterange) {
  var endRange;
  if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
    endRange = import_window5.default.BigInt(byterange.offset) + import_window5.default.BigInt(byterange.length) - import_window5.default.BigInt(1);
  } else {
    endRange = byterange.offset + byterange.length - 1;
  }
  return byterange.offset + "-" + endRange;
};
var parseEndNumber = function parseEndNumber2(endNumber) {
  if (endNumber && typeof endNumber !== "number") {
    endNumber = parseInt(endNumber, 10);
  }
  if (isNaN(endNumber)) {
    return null;
  }
  return endNumber;
};
var segmentRange = {
  /**
   * Returns the entire range of available segments for a static MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  static: function _static(attributes) {
    var duration5 = attributes.duration, _attributes$timescale = attributes.timescale, timescale2 = _attributes$timescale === void 0 ? 1 : _attributes$timescale, sourceDuration = attributes.sourceDuration, periodDuration = attributes.periodDuration;
    var endNumber = parseEndNumber(attributes.endNumber);
    var segmentDuration = duration5 / timescale2;
    if (typeof endNumber === "number") {
      return {
        start: 0,
        end: endNumber
      };
    }
    if (typeof periodDuration === "number") {
      return {
        start: 0,
        end: periodDuration / segmentDuration
      };
    }
    return {
      start: 0,
      end: sourceDuration / segmentDuration
    };
  },
  /**
   * Returns the current live window range of available segments for a dynamic MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  dynamic: function dynamic(attributes) {
    var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime2 = attributes.availabilityStartTime, _attributes$timescale2 = attributes.timescale, timescale2 = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, duration5 = attributes.duration, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp, _attributes$timeShift = attributes.timeShiftBufferDepth, timeShiftBufferDepth2 = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;
    var endNumber = parseEndNumber(attributes.endNumber);
    var now = (NOW + clientOffset) / 1e3;
    var periodStartWC = availabilityStartTime2 + periodStart;
    var periodEndWC = now + minimumUpdatePeriod2;
    var periodDuration = periodEndWC - periodStartWC;
    var segmentCount = Math.ceil(periodDuration * timescale2 / duration5);
    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth2) * timescale2 / duration5);
    var availableEnd = Math.floor((now - periodStartWC) * timescale2 / duration5);
    return {
      start: Math.max(0, availableStart),
      end: typeof endNumber === "number" ? endNumber : Math.min(segmentCount, availableEnd)
    };
  }
};
var toSegments = function toSegments2(attributes) {
  return function(number) {
    var duration5 = attributes.duration, _attributes$timescale3 = attributes.timescale, timescale2 = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3, periodStart = attributes.periodStart, _attributes$startNumb = attributes.startNumber, startNumber2 = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;
    return {
      number: startNumber2 + number,
      duration: duration5 / timescale2,
      timeline: periodStart,
      time: number * duration5
    };
  };
};
var parseByDuration = function parseByDuration2(attributes) {
  var type2 = attributes.type, duration5 = attributes.duration, _attributes$timescale4 = attributes.timescale, timescale2 = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4, periodDuration = attributes.periodDuration, sourceDuration = attributes.sourceDuration;
  var _segmentRange$type = segmentRange[type2](attributes), start2 = _segmentRange$type.start, end = _segmentRange$type.end;
  var segments = range(start2, end).map(toSegments(attributes));
  if (type2 === "static") {
    var index = segments.length - 1;
    var sectionDuration = typeof periodDuration === "number" ? periodDuration : sourceDuration;
    segments[index].duration = sectionDuration - duration5 / timescale2 * index;
  }
  return segments;
};
var segmentsFromBase = function segmentsFromBase2(attributes) {
  var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ, sourceDuration = attributes.sourceDuration, _attributes$indexRang = attributes.indexRange, indexRange = _attributes$indexRang === void 0 ? "" : _attributes$indexRang, periodStart = attributes.periodStart, presentationTime = attributes.presentationTime, _attributes$number = attributes.number, number = _attributes$number === void 0 ? 0 : _attributes$number, duration5 = attributes.duration;
  if (!baseUrl) {
    throw new Error(errors.NO_BASE_URL);
  }
  var initSegment = urlTypeToSegment({
    baseUrl,
    source: initialization.sourceURL,
    range: initialization.range
  });
  var segment = urlTypeToSegment({
    baseUrl,
    source: baseUrl,
    indexRange
  });
  segment.map = initSegment;
  if (duration5) {
    var segmentTimeInfo = parseByDuration(attributes);
    if (segmentTimeInfo.length) {
      segment.duration = segmentTimeInfo[0].duration;
      segment.timeline = segmentTimeInfo[0].timeline;
    }
  } else if (sourceDuration) {
    segment.duration = sourceDuration;
    segment.timeline = periodStart;
  }
  segment.presentationTime = presentationTime || periodStart;
  segment.number = number;
  return [segment];
};
var addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {
  var initSegment = playlist.sidx.map ? playlist.sidx.map : null;
  var sourceDuration = playlist.sidx.duration;
  var timeline = playlist.timeline || 0;
  var sidxByteRange = playlist.sidx.byterange;
  var sidxEnd = sidxByteRange.offset + sidxByteRange.length;
  var timescale2 = sidx.timescale;
  var mediaReferences = sidx.references.filter(function(r2) {
    return r2.referenceType !== 1;
  });
  var segments = [];
  var type2 = playlist.endList ? "static" : "dynamic";
  var periodStart = playlist.sidx.timeline;
  var presentationTime = periodStart;
  var number = playlist.mediaSequence || 0;
  var startIndex;
  if (typeof sidx.firstOffset === "bigint") {
    startIndex = import_window5.default.BigInt(sidxEnd) + sidx.firstOffset;
  } else {
    startIndex = sidxEnd + sidx.firstOffset;
  }
  for (var i = 0; i < mediaReferences.length; i++) {
    var reference = sidx.references[i];
    var size = reference.referencedSize;
    var duration5 = reference.subsegmentDuration;
    var endIndex = void 0;
    if (typeof startIndex === "bigint") {
      endIndex = startIndex + import_window5.default.BigInt(size) - import_window5.default.BigInt(1);
    } else {
      endIndex = startIndex + size - 1;
    }
    var indexRange = startIndex + "-" + endIndex;
    var attributes = {
      baseUrl,
      timescale: timescale2,
      timeline,
      periodStart,
      presentationTime,
      number,
      duration: duration5,
      sourceDuration,
      indexRange,
      type: type2
    };
    var segment = segmentsFromBase(attributes)[0];
    if (initSegment) {
      segment.map = initSegment;
    }
    segments.push(segment);
    if (typeof startIndex === "bigint") {
      startIndex += import_window5.default.BigInt(size);
    } else {
      startIndex += size;
    }
    presentationTime += duration5 / timescale2;
    number++;
  }
  playlist.segments = segments;
  return playlist;
};
var SUPPORTED_MEDIA_TYPES = ["AUDIO", "SUBTITLES"];
var TIME_FUDGE = 1 / 60;
var getUniqueTimelineStarts = function getUniqueTimelineStarts2(timelineStarts) {
  return union(timelineStarts, function(_ref) {
    var timeline = _ref.timeline;
    return timeline;
  }).sort(function(a, b2) {
    return a.timeline > b2.timeline ? 1 : -1;
  });
};
var findPlaylistWithName = function findPlaylistWithName2(playlists, name) {
  for (var i = 0; i < playlists.length; i++) {
    if (playlists[i].attributes.NAME === name) {
      return playlists[i];
    }
  }
  return null;
};
var getMediaGroupPlaylists = function getMediaGroupPlaylists2(manifest) {
  var mediaGroupPlaylists = [];
  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, function(properties, type2, group, label) {
    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);
  });
  return mediaGroupPlaylists;
};
var updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist2(_ref2) {
  var playlist = _ref2.playlist, mediaSequence = _ref2.mediaSequence;
  playlist.mediaSequence = mediaSequence;
  playlist.segments.forEach(function(segment, index) {
    segment.number = playlist.mediaSequence + index;
  });
};
var updateSequenceNumbers = function updateSequenceNumbers2(_ref3) {
  var oldPlaylists = _ref3.oldPlaylists, newPlaylists = _ref3.newPlaylists, timelineStarts = _ref3.timelineStarts;
  newPlaylists.forEach(function(playlist) {
    playlist.discontinuitySequence = findIndex(timelineStarts, function(_ref4) {
      var timeline = _ref4.timeline;
      return timeline === playlist.timeline;
    });
    var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
    if (!oldPlaylist) {
      return;
    }
    if (playlist.sidx) {
      return;
    }
    var firstNewSegment = playlist.segments[0];
    var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function(oldSegment) {
      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;
    });
    if (oldMatchingSegmentIndex === -1) {
      updateMediaSequenceForPlaylist({
        playlist,
        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
      });
      playlist.segments[0].discontinuity = true;
      playlist.discontinuityStarts.unshift(0);
      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {
        playlist.discontinuitySequence--;
      }
      return;
    }
    var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
      firstNewSegment.discontinuity = true;
      playlist.discontinuityStarts.unshift(0);
      playlist.discontinuitySequence--;
    }
    updateMediaSequenceForPlaylist({
      playlist,
      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
    });
  });
};
var positionManifestOnTimeline = function positionManifestOnTimeline2(_ref5) {
  var oldManifest = _ref5.oldManifest, newManifest = _ref5.newManifest;
  var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));
  var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest));
  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);
  updateSequenceNumbers({
    oldPlaylists,
    newPlaylists,
    timelineStarts: newManifest.timelineStarts
  });
  return newManifest;
};
var generateSidxKey = function generateSidxKey2(sidx) {
  return sidx && sidx.uri + "-" + byteRangeToString(sidx.byterange);
};
var mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists2(playlists) {
  var mergedPlaylists = values(playlists.reduce(function(acc, playlist) {
    var name = playlist.attributes.id + (playlist.attributes.lang || "");
    if (!acc[name]) {
      acc[name] = playlist;
      acc[name].attributes.timelineStarts = [];
    } else {
      if (playlist.segments) {
        var _acc$name$segments;
        if (playlist.segments[0]) {
          playlist.segments[0].discontinuity = true;
        }
        (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);
      }
      if (playlist.attributes.contentProtection) {
        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
      }
    }
    acc[name].attributes.timelineStarts.push({
      // Although they represent the same number, it's important to have both to make it
      // compatible with HLS potentially having a similar attribute.
      start: playlist.attributes.periodStart,
      timeline: playlist.attributes.periodStart
    });
    return acc;
  }, {}));
  return mergedPlaylists.map(function(playlist) {
    playlist.discontinuityStarts = findIndexes(playlist.segments || [], "discontinuity");
    return playlist;
  });
};
var addSidxSegmentsToPlaylist2 = function addSidxSegmentsToPlaylist3(playlist, sidxMapping) {
  var sidxKey = generateSidxKey(playlist.sidx);
  var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
  if (sidxMatch) {
    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
  }
  return playlist;
};
var addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists2(playlists, sidxMapping) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  if (!Object.keys(sidxMapping).length) {
    return playlists;
  }
  for (var i in playlists) {
    playlists[i] = addSidxSegmentsToPlaylist2(playlists[i], sidxMapping);
  }
  return playlists;
};
var formatAudioPlaylist = function formatAudioPlaylist2(_ref, isAudioOnly3) {
  var _attributes;
  var attributes = _ref.attributes, segments = _ref.segments, sidx = _ref.sidx, mediaSequence = _ref.mediaSequence, discontinuitySequence = _ref.discontinuitySequence, discontinuityStarts = _ref.discontinuityStarts;
  var playlist = {
    attributes: (_attributes = {
      NAME: attributes.id,
      BANDWIDTH: attributes.bandwidth,
      CODECS: attributes.codecs
    }, _attributes["PROGRAM-ID"] = 1, _attributes),
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: "",
    targetDuration: attributes.duration,
    discontinuitySequence,
    discontinuityStarts,
    timelineStarts: attributes.timelineStarts,
    mediaSequence,
    segments
  };
  if (attributes.contentProtection) {
    playlist.contentProtection = attributes.contentProtection;
  }
  if (sidx) {
    playlist.sidx = sidx;
  }
  if (isAudioOnly3) {
    playlist.attributes.AUDIO = "audio";
    playlist.attributes.SUBTITLES = "subs";
  }
  return playlist;
};
var formatVttPlaylist = function formatVttPlaylist2(_ref2) {
  var _m3u8Attributes;
  var attributes = _ref2.attributes, segments = _ref2.segments, mediaSequence = _ref2.mediaSequence, discontinuityStarts = _ref2.discontinuityStarts, discontinuitySequence = _ref2.discontinuitySequence;
  if (typeof segments === "undefined") {
    segments = [{
      uri: attributes.baseUrl,
      timeline: attributes.periodStart,
      resolvedUri: attributes.baseUrl || "",
      duration: attributes.sourceDuration,
      number: 0
    }];
    attributes.duration = attributes.sourceDuration;
  }
  var m3u8Attributes = (_m3u8Attributes = {
    NAME: attributes.id,
    BANDWIDTH: attributes.bandwidth
  }, _m3u8Attributes["PROGRAM-ID"] = 1, _m3u8Attributes);
  if (attributes.codecs) {
    m3u8Attributes.CODECS = attributes.codecs;
  }
  return {
    attributes: m3u8Attributes,
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: attributes.baseUrl || "",
    targetDuration: attributes.duration,
    timelineStarts: attributes.timelineStarts,
    discontinuityStarts,
    discontinuitySequence,
    mediaSequence,
    segments
  };
};
var organizeAudioPlaylists = function organizeAudioPlaylists2(playlists, sidxMapping, isAudioOnly3) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  if (isAudioOnly3 === void 0) {
    isAudioOnly3 = false;
  }
  var mainPlaylist;
  var formattedPlaylists = playlists.reduce(function(a, playlist) {
    var role = playlist.attributes.role && playlist.attributes.role.value || "";
    var language = playlist.attributes.lang || "";
    var label = playlist.attributes.label || "main";
    if (language && !playlist.attributes.label) {
      var roleLabel = role ? " (" + role + ")" : "";
      label = "" + playlist.attributes.lang + roleLabel;
    }
    if (!a[label]) {
      a[label] = {
        language,
        autoselect: true,
        default: role === "main",
        playlists: [],
        uri: ""
      };
    }
    var formatted = addSidxSegmentsToPlaylist2(formatAudioPlaylist(playlist, isAudioOnly3), sidxMapping);
    a[label].playlists.push(formatted);
    if (typeof mainPlaylist === "undefined" && role === "main") {
      mainPlaylist = playlist;
      mainPlaylist.default = true;
    }
    return a;
  }, {});
  if (!mainPlaylist) {
    var firstLabel = Object.keys(formattedPlaylists)[0];
    formattedPlaylists[firstLabel].default = true;
  }
  return formattedPlaylists;
};
var organizeVttPlaylists = function organizeVttPlaylists2(playlists, sidxMapping) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  return playlists.reduce(function(a, playlist) {
    var label = playlist.attributes.lang || "text";
    if (!a[label]) {
      a[label] = {
        language: label,
        default: false,
        autoselect: false,
        playlists: [],
        uri: ""
      };
    }
    a[label].playlists.push(addSidxSegmentsToPlaylist2(formatVttPlaylist(playlist), sidxMapping));
    return a;
  }, {});
};
var organizeCaptionServices = function organizeCaptionServices2(captionServices) {
  return captionServices.reduce(function(svcObj, svc) {
    if (!svc) {
      return svcObj;
    }
    svc.forEach(function(service) {
      var channel = service.channel, language = service.language;
      svcObj[language] = {
        autoselect: false,
        default: false,
        instreamId: channel,
        language
      };
      if (service.hasOwnProperty("aspectRatio")) {
        svcObj[language].aspectRatio = service.aspectRatio;
      }
      if (service.hasOwnProperty("easyReader")) {
        svcObj[language].easyReader = service.easyReader;
      }
      if (service.hasOwnProperty("3D")) {
        svcObj[language]["3D"] = service["3D"];
      }
    });
    return svcObj;
  }, {});
};
var formatVideoPlaylist = function formatVideoPlaylist2(_ref3) {
  var _attributes2;
  var attributes = _ref3.attributes, segments = _ref3.segments, sidx = _ref3.sidx, discontinuityStarts = _ref3.discontinuityStarts;
  var playlist = {
    attributes: (_attributes2 = {
      NAME: attributes.id,
      AUDIO: "audio",
      SUBTITLES: "subs",
      RESOLUTION: {
        width: attributes.width,
        height: attributes.height
      },
      CODECS: attributes.codecs,
      BANDWIDTH: attributes.bandwidth
    }, _attributes2["PROGRAM-ID"] = 1, _attributes2),
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: "",
    targetDuration: attributes.duration,
    discontinuityStarts,
    timelineStarts: attributes.timelineStarts,
    segments
  };
  if (attributes.frameRate) {
    playlist.attributes["FRAME-RATE"] = attributes.frameRate;
  }
  if (attributes.contentProtection) {
    playlist.contentProtection = attributes.contentProtection;
  }
  if (sidx) {
    playlist.sidx = sidx;
  }
  return playlist;
};
var videoOnly = function videoOnly2(_ref4) {
  var attributes = _ref4.attributes;
  return attributes.mimeType === "video/mp4" || attributes.mimeType === "video/webm" || attributes.contentType === "video";
};
var audioOnly = function audioOnly2(_ref5) {
  var attributes = _ref5.attributes;
  return attributes.mimeType === "audio/mp4" || attributes.mimeType === "audio/webm" || attributes.contentType === "audio";
};
var vttOnly = function vttOnly2(_ref6) {
  var attributes = _ref6.attributes;
  return attributes.mimeType === "text/vtt" || attributes.contentType === "text";
};
var addMediaSequenceValues = function addMediaSequenceValues2(playlists, timelineStarts) {
  playlists.forEach(function(playlist) {
    playlist.mediaSequence = 0;
    playlist.discontinuitySequence = findIndex(timelineStarts, function(_ref7) {
      var timeline = _ref7.timeline;
      return timeline === playlist.timeline;
    });
    if (!playlist.segments) {
      return;
    }
    playlist.segments.forEach(function(segment, index) {
      segment.number = index;
    });
  });
};
var flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists2(mediaGroupObject) {
  if (!mediaGroupObject) {
    return [];
  }
  return Object.keys(mediaGroupObject).reduce(function(acc, label) {
    var labelContents = mediaGroupObject[label];
    return acc.concat(labelContents.playlists);
  }, []);
};
var toM3u8 = function toM3u82(_ref8) {
  var _mediaGroups;
  var dashPlaylists = _ref8.dashPlaylists, locations = _ref8.locations, _ref8$sidxMapping = _ref8.sidxMapping, sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping, previousManifest = _ref8.previousManifest;
  if (!dashPlaylists.length) {
    return {};
  }
  var _dashPlaylists$0$attr = dashPlaylists[0].attributes, duration5 = _dashPlaylists$0$attr.sourceDuration, type2 = _dashPlaylists$0$attr.type, suggestedPresentationDelay2 = _dashPlaylists$0$attr.suggestedPresentationDelay, minimumUpdatePeriod2 = _dashPlaylists$0$attr.minimumUpdatePeriod;
  var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);
  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));
  var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));
  var captions = dashPlaylists.map(function(playlist) {
    return playlist.attributes.captionServices;
  }).filter(Boolean);
  var manifest = {
    allowCache: true,
    discontinuityStarts: [],
    segments: [],
    endList: true,
    mediaGroups: (_mediaGroups = {
      AUDIO: {},
      VIDEO: {}
    }, _mediaGroups["CLOSED-CAPTIONS"] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),
    uri: "",
    duration: duration5,
    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)
  };
  if (minimumUpdatePeriod2 >= 0) {
    manifest.minimumUpdatePeriod = minimumUpdatePeriod2 * 1e3;
  }
  if (locations) {
    manifest.locations = locations;
  }
  if (type2 === "dynamic") {
    manifest.suggestedPresentationDelay = suggestedPresentationDelay2;
  }
  var isAudioOnly3 = manifest.playlists.length === 0;
  var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly3) : null;
  var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
  var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));
  var playlistTimelineStarts = formattedPlaylists.map(function(_ref9) {
    var timelineStarts = _ref9.timelineStarts;
    return timelineStarts;
  });
  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);
  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
  if (organizedAudioGroup) {
    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
  }
  if (organizedVttGroup) {
    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
  }
  if (captions.length) {
    manifest.mediaGroups["CLOSED-CAPTIONS"].cc = organizeCaptionServices(captions);
  }
  if (previousManifest) {
    return positionManifestOnTimeline({
      oldManifest: previousManifest,
      newManifest: manifest
    });
  }
  return manifest;
};
var getLiveRValue = function getLiveRValue2(attributes, time, duration5) {
  var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime2 = attributes.availabilityStartTime, _attributes$timescale = attributes.timescale, timescale2 = _attributes$timescale === void 0 ? 1 : _attributes$timescale, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;
  var now = (NOW + clientOffset) / 1e3;
  var periodStartWC = availabilityStartTime2 + periodStart;
  var periodEndWC = now + minimumUpdatePeriod2;
  var periodDuration = periodEndWC - periodStartWC;
  return Math.ceil((periodDuration * timescale2 - time) / duration5);
};
var parseByTimeline = function parseByTimeline2(attributes, segmentTimeline) {
  var type2 = attributes.type, _attributes$minimumUp2 = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2, _attributes$media = attributes.media, media = _attributes$media === void 0 ? "" : _attributes$media, sourceDuration = attributes.sourceDuration, _attributes$timescale2 = attributes.timescale, timescale2 = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, _attributes$startNumb = attributes.startNumber, startNumber2 = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb, timeline = attributes.periodStart;
  var segments = [];
  var time = -1;
  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
    var S2 = segmentTimeline[sIndex];
    var duration5 = S2.d;
    var repeat = S2.r || 0;
    var segmentTime = S2.t || 0;
    if (time < 0) {
      time = segmentTime;
    }
    if (segmentTime && segmentTime > time) {
      time = segmentTime;
    }
    var count = void 0;
    if (repeat < 0) {
      var nextS = sIndex + 1;
      if (nextS === segmentTimeline.length) {
        if (type2 === "dynamic" && minimumUpdatePeriod2 > 0 && media.indexOf("$Number$") > 0) {
          count = getLiveRValue(attributes, time, duration5);
        } else {
          count = (sourceDuration * timescale2 - time) / duration5;
        }
      } else {
        count = (segmentTimeline[nextS].t - time) / duration5;
      }
    } else {
      count = repeat + 1;
    }
    var end = startNumber2 + segments.length + count;
    var number = startNumber2 + segments.length;
    while (number < end) {
      segments.push({
        number,
        duration: duration5 / timescale2,
        time,
        timeline
      });
      time += duration5;
      number++;
    }
  }
  return segments;
};
var identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
var identifierReplacement = function identifierReplacement2(values3) {
  return function(match, identifier, format, width2) {
    if (match === "$$") {
      return "$";
    }
    if (typeof values3[identifier] === "undefined") {
      return match;
    }
    var value = "" + values3[identifier];
    if (identifier === "RepresentationID") {
      return value;
    }
    if (!format) {
      width2 = 1;
    } else {
      width2 = parseInt(width2, 10);
    }
    if (value.length >= width2) {
      return value;
    }
    return "" + new Array(width2 - value.length + 1).join("0") + value;
  };
};
var constructTemplateUrl = function constructTemplateUrl2(url, values3) {
  return url.replace(identifierPattern, identifierReplacement(values3));
};
var parseTemplateInfo = function parseTemplateInfo2(attributes, segmentTimeline) {
  if (!attributes.duration && !segmentTimeline) {
    return [{
      number: attributes.startNumber || 1,
      duration: attributes.sourceDuration,
      time: 0,
      timeline: attributes.periodStart
    }];
  }
  if (attributes.duration) {
    return parseByDuration(attributes);
  }
  return parseByTimeline(attributes, segmentTimeline);
};
var segmentsFromTemplate = function segmentsFromTemplate2(attributes, segmentTimeline) {
  var templateValues = {
    RepresentationID: attributes.id,
    Bandwidth: attributes.bandwidth || 0
  };
  var _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {
    sourceURL: "",
    range: ""
  } : _attributes$initializ;
  var mapSegment = urlTypeToSegment({
    baseUrl: attributes.baseUrl,
    source: constructTemplateUrl(initialization.sourceURL, templateValues),
    range: initialization.range
  });
  var segments = parseTemplateInfo(attributes, segmentTimeline);
  return segments.map(function(segment) {
    templateValues.Number = segment.number;
    templateValues.Time = segment.time;
    var uri = constructTemplateUrl(attributes.media || "", templateValues);
    var timescale2 = attributes.timescale || 1;
    var presentationTimeOffset2 = attributes.presentationTimeOffset || 0;
    var presentationTime = (
      // Even if the @t attribute is not specified for the segment, segment.time is
      // calculated in mpd-parser prior to this, so it's assumed to be available.
      attributes.periodStart + (segment.time - presentationTimeOffset2) / timescale2
    );
    var map = {
      uri,
      timeline: segment.timeline,
      duration: segment.duration,
      resolvedUri: resolve_url_default(attributes.baseUrl || "", uri),
      map: mapSegment,
      number: segment.number,
      presentationTime
    };
    return map;
  });
};
var SegmentURLToSegmentObject = function SegmentURLToSegmentObject2(attributes, segmentUrl) {
  var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;
  var initSegment = urlTypeToSegment({
    baseUrl,
    source: initialization.sourceURL,
    range: initialization.range
  });
  var segment = urlTypeToSegment({
    baseUrl,
    source: segmentUrl.media,
    range: segmentUrl.mediaRange
  });
  segment.map = initSegment;
  return segment;
};
var segmentsFromList = function segmentsFromList2(attributes, segmentTimeline) {
  var duration5 = attributes.duration, _attributes$segmentUr = attributes.segmentUrls, segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr, periodStart = attributes.periodStart;
  if (!duration5 && !segmentTimeline || duration5 && segmentTimeline) {
    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);
  }
  var segmentUrlMap = segmentUrls.map(function(segmentUrlObject) {
    return SegmentURLToSegmentObject(attributes, segmentUrlObject);
  });
  var segmentTimeInfo;
  if (duration5) {
    segmentTimeInfo = parseByDuration(attributes);
  }
  if (segmentTimeline) {
    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);
  }
  var segments = segmentTimeInfo.map(function(segmentTime, index) {
    if (segmentUrlMap[index]) {
      var segment = segmentUrlMap[index];
      var timescale2 = attributes.timescale || 1;
      var presentationTimeOffset2 = attributes.presentationTimeOffset || 0;
      segment.timeline = segmentTime.timeline;
      segment.duration = segmentTime.duration;
      segment.number = segmentTime.number;
      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset2) / timescale2;
      return segment;
    }
  }).filter(function(segment) {
    return segment;
  });
  return segments;
};
var generateSegments = function generateSegments2(_ref) {
  var attributes = _ref.attributes, segmentInfo = _ref.segmentInfo;
  var segmentAttributes;
  var segmentsFn;
  if (segmentInfo.template) {
    segmentsFn = segmentsFromTemplate;
    segmentAttributes = merge(attributes, segmentInfo.template);
  } else if (segmentInfo.base) {
    segmentsFn = segmentsFromBase;
    segmentAttributes = merge(attributes, segmentInfo.base);
  } else if (segmentInfo.list) {
    segmentsFn = segmentsFromList;
    segmentAttributes = merge(attributes, segmentInfo.list);
  }
  var segmentsInfo = {
    attributes
  };
  if (!segmentsFn) {
    return segmentsInfo;
  }
  var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
  if (segmentAttributes.duration) {
    var _segmentAttributes = segmentAttributes, duration5 = _segmentAttributes.duration, _segmentAttributes$ti = _segmentAttributes.timescale, timescale2 = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;
    segmentAttributes.duration = duration5 / timescale2;
  } else if (segments.length) {
    segmentAttributes.duration = segments.reduce(function(max, segment) {
      return Math.max(max, Math.ceil(segment.duration));
    }, 0);
  } else {
    segmentAttributes.duration = 0;
  }
  segmentsInfo.attributes = segmentAttributes;
  segmentsInfo.segments = segments;
  if (segmentInfo.base && segmentAttributes.indexRange) {
    segmentsInfo.sidx = segments[0];
    segmentsInfo.segments = [];
  }
  return segmentsInfo;
};
var toPlaylists = function toPlaylists2(representations) {
  return representations.map(generateSegments);
};
var findChildren = function findChildren2(element, name) {
  return from(element.childNodes).filter(function(_ref) {
    var tagName = _ref.tagName;
    return tagName === name;
  });
};
var getContent = function getContent2(element) {
  return element.textContent.trim();
};
var parseDivisionValue = function parseDivisionValue2(value) {
  return parseFloat(value.split("/").reduce(function(prev, current) {
    return prev / current;
  }));
};
var parseDuration = function parseDuration2(str) {
  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
  var SECONDS_IN_DAY = 24 * 60 * 60;
  var SECONDS_IN_HOUR = 60 * 60;
  var SECONDS_IN_MIN = 60;
  var durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
  var match = durationRegex.exec(str);
  if (!match) {
    return 0;
  }
  var _match$slice = match.slice(1), year = _match$slice[0], month = _match$slice[1], day = _match$slice[2], hour = _match$slice[3], minute = _match$slice[4], second = _match$slice[5];
  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
};
var parseDate = function parseDate2(str) {
  var dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
  if (dateRegex.test(str)) {
    str += "Z";
  }
  return Date.parse(str);
};
var parsers = {
  /**
   * Specifies the duration of the entire Media Presentation. Format is a duration string
   * as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  mediaPresentationDuration: function mediaPresentationDuration(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the Segment availability start time for all Segments referred to in this
   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
   * time. Format is a date string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The date as seconds from unix epoch
   */
  availabilityStartTime: function availabilityStartTime(value) {
    return parseDate(value) / 1e3;
  },
  /**
   * Specifies the smallest period between potential changes to the MPD. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  minimumUpdatePeriod: function minimumUpdatePeriod(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the suggested presentation delay. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  suggestedPresentationDelay: function suggestedPresentationDelay(value) {
    return parseDuration(value);
  },
  /**
   * specifices the type of mpd. Can be either "static" or "dynamic"
   *
   * @param {string} value
   *        value of attribute as a string
   *
   * @return {string}
   *         The type as a string
   */
  type: function type(value) {
    return value;
  },
  /**
   * Specifies the duration of the smallest time shifting buffer for any Representation
   * in the MPD. Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  timeShiftBufferDepth: function timeShiftBufferDepth(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
   * Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  start: function start(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the width of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed width
   */
  width: function width(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the height of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed height
   */
  height: function height(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the bitrate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed bandwidth
   */
  bandwidth: function bandwidth(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the frame rate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed frame rate
   */
  frameRate: function frameRate(value) {
    return parseDivisionValue(value);
  },
  /**
   * Specifies the number of the first Media Segment in this Representation in the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  startNumber: function startNumber(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the timescale in units per seconds
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed timescale
   */
  timescale: function timescale(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the presentationTimeOffset.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTimeOffset
   */
  presentationTimeOffset: function presentationTimeOffset(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the constant approximate Segment duration
   * NOTE: The <Period> element also contains an @duration attribute. This duration
   *       specifies the duration of the Period. This attribute is currently not
   *       supported by the rest of the parser, however we still check for it to prevent
   *       errors.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  duration: function duration(value) {
    var parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue)) {
      return parseDuration(value);
    }
    return parsedValue;
  },
  /**
   * Specifies the Segment duration, in units of the value of the @timescale.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  d: function d(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the MPD start time, in @timescale units, the first Segment in the series
   * starts relative to the beginning of the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed time
   */
  t: function t(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the repeat count of the number of following contiguous Segments with the
   * same duration expressed by the value of @d
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  r: function r(value) {
    return parseInt(value, 10);
  },
  /**
   * Default parser for all other attributes. Acts as a no-op and just returns the value
   * as a string
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {string}
   *         Unparsed value
   */
  DEFAULT: function DEFAULT(value) {
    return value;
  }
};
var parseAttributes3 = function parseAttributes4(el) {
  if (!(el && el.attributes)) {
    return {};
  }
  return from(el.attributes).reduce(function(a, e) {
    var parseFn = parsers[e.name] || parsers.DEFAULT;
    a[e.name] = parseFn(e.value);
    return a;
  }, {});
};
var keySystemsMap = {
  "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
  "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
  "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
};
var buildBaseUrls = function buildBaseUrls2(referenceUrls, baseUrlElements) {
  if (!baseUrlElements.length) {
    return referenceUrls;
  }
  return flatten(referenceUrls.map(function(reference) {
    return baseUrlElements.map(function(baseUrlElement) {
      return resolve_url_default(reference, getContent(baseUrlElement));
    });
  }));
};
var getSegmentInformation = function getSegmentInformation2(adaptationSet) {
  var segmentTemplate = findChildren(adaptationSet, "SegmentTemplate")[0];
  var segmentList = findChildren(adaptationSet, "SegmentList")[0];
  var segmentUrls = segmentList && findChildren(segmentList, "SegmentURL").map(function(s) {
    return merge({
      tag: "SegmentURL"
    }, parseAttributes3(s));
  });
  var segmentBase = findChildren(adaptationSet, "SegmentBase")[0];
  var segmentTimelineParentNode = segmentList || segmentTemplate;
  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, "SegmentTimeline")[0];
  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, "Initialization")[0];
  var template = segmentTemplate && parseAttributes3(segmentTemplate);
  if (template && segmentInitialization) {
    template.initialization = segmentInitialization && parseAttributes3(segmentInitialization);
  } else if (template && template.initialization) {
    template.initialization = {
      sourceURL: template.initialization
    };
  }
  var segmentInfo = {
    template,
    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, "S").map(function(s) {
      return parseAttributes3(s);
    }),
    list: segmentList && merge(parseAttributes3(segmentList), {
      segmentUrls,
      initialization: parseAttributes3(segmentInitialization)
    }),
    base: segmentBase && merge(parseAttributes3(segmentBase), {
      initialization: parseAttributes3(segmentInitialization)
    })
  };
  Object.keys(segmentInfo).forEach(function(key) {
    if (!segmentInfo[key]) {
      delete segmentInfo[key];
    }
  });
  return segmentInfo;
};
var inheritBaseUrls = function inheritBaseUrls2(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {
  return function(representation) {
    var repBaseUrlElements = findChildren(representation, "BaseURL");
    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
    var attributes = merge(adaptationSetAttributes, parseAttributes3(representation));
    var representationSegmentInfo = getSegmentInformation(representation);
    return repBaseUrls.map(function(baseUrl) {
      return {
        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),
        attributes: merge(attributes, {
          baseUrl
        })
      };
    });
  };
};
var generateKeySystemInformation = function generateKeySystemInformation2(contentProtectionNodes) {
  return contentProtectionNodes.reduce(function(acc, node) {
    var attributes = parseAttributes3(node);
    if (attributes.schemeIdUri) {
      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();
    }
    var keySystem = keySystemsMap[attributes.schemeIdUri];
    if (keySystem) {
      acc[keySystem] = {
        attributes
      };
      var psshNode = findChildren(node, "cenc:pssh")[0];
      if (psshNode) {
        var pssh = getContent(psshNode);
        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);
      }
    }
    return acc;
  }, {});
};
var parseCaptionServiceMetadata = function parseCaptionServiceMetadata2(service) {
  if (service.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
    var values3 = typeof service.value !== "string" ? [] : service.value.split(";");
    return values3.map(function(value) {
      var channel;
      var language;
      language = value;
      if (/^CC\d=/.test(value)) {
        var _value$split = value.split("=");
        channel = _value$split[0];
        language = _value$split[1];
      } else if (/^CC\d$/.test(value)) {
        channel = value;
      }
      return {
        channel,
        language
      };
    });
  } else if (service.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
    var _values = typeof service.value !== "string" ? [] : service.value.split(";");
    return _values.map(function(value) {
      var flags = {
        // service or channel number 1-63
        "channel": void 0,
        // language is a 3ALPHA per ISO 639.2/B
        // field is required
        "language": void 0,
        // BIT 1/0 or ?
        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
        "aspectRatio": 1,
        // BIT 1/0
        // easy reader flag indicated the text is tailed to the needs of beginning readers
        // default 0, or off
        "easyReader": 0,
        // BIT 1/0
        // If 3d metadata is present (CEA-708.1) then 1
        // default 0
        "3D": 0
      };
      if (/=/.test(value)) {
        var _value$split2 = value.split("="), channel = _value$split2[0], _value$split2$ = _value$split2[1], opts = _value$split2$ === void 0 ? "" : _value$split2$;
        flags.channel = channel;
        flags.language = value;
        opts.split(",").forEach(function(opt) {
          var _opt$split = opt.split(":"), name = _opt$split[0], val = _opt$split[1];
          if (name === "lang") {
            flags.language = val;
          } else if (name === "er") {
            flags.easyReader = Number(val);
          } else if (name === "war") {
            flags.aspectRatio = Number(val);
          } else if (name === "3D") {
            flags["3D"] = Number(val);
          }
        });
      } else {
        flags.language = value;
      }
      if (flags.channel) {
        flags.channel = "SERVICE" + flags.channel;
      }
      return flags;
    });
  }
};
var toRepresentations = function toRepresentations2(periodAttributes, periodBaseUrls, periodSegmentInfo) {
  return function(adaptationSet) {
    var adaptationSetAttributes = parseAttributes3(adaptationSet);
    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, "BaseURL"));
    var role = findChildren(adaptationSet, "Role")[0];
    var roleAttributes = {
      role: parseAttributes3(role)
    };
    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);
    var accessibility = findChildren(adaptationSet, "Accessibility")[0];
    var captionServices = parseCaptionServiceMetadata(parseAttributes3(accessibility));
    if (captionServices) {
      attrs = merge(attrs, {
        captionServices
      });
    }
    var label = findChildren(adaptationSet, "Label")[0];
    if (label && label.childNodes.length) {
      var labelVal = label.childNodes[0].nodeValue.trim();
      attrs = merge(attrs, {
        label: labelVal
      });
    }
    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, "ContentProtection"));
    if (Object.keys(contentProtection).length) {
      attrs = merge(attrs, {
        contentProtection
      });
    }
    var segmentInfo = getSegmentInformation(adaptationSet);
    var representations = findChildren(adaptationSet, "Representation");
    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);
    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
  };
};
var toAdaptationSets = function toAdaptationSets2(mpdAttributes, mpdBaseUrls) {
  return function(period, index) {
    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, "BaseURL"));
    var periodAttributes = merge(mpdAttributes, {
      periodStart: period.attributes.start
    });
    if (typeof period.attributes.duration === "number") {
      periodAttributes.periodDuration = period.attributes.duration;
    }
    var adaptationSets = findChildren(period.node, "AdaptationSet");
    var periodSegmentInfo = getSegmentInformation(period.node);
    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
  };
};
var getPeriodStart = function getPeriodStart2(_ref) {
  var attributes = _ref.attributes, priorPeriodAttributes = _ref.priorPeriodAttributes, mpdType = _ref.mpdType;
  if (typeof attributes.start === "number") {
    return attributes.start;
  }
  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === "number" && typeof priorPeriodAttributes.duration === "number") {
    return priorPeriodAttributes.start + priorPeriodAttributes.duration;
  }
  if (!priorPeriodAttributes && mpdType === "static") {
    return 0;
  }
  return null;
};
var inheritAttributes = function inheritAttributes2(mpd, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$manifestUri = _options.manifestUri, manifestUri = _options$manifestUri === void 0 ? "" : _options$manifestUri, _options$NOW = _options.NOW, NOW = _options$NOW === void 0 ? Date.now() : _options$NOW, _options$clientOffset = _options.clientOffset, clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;
  var periodNodes = findChildren(mpd, "Period");
  if (!periodNodes.length) {
    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);
  }
  var locations = findChildren(mpd, "Location");
  var mpdAttributes = parseAttributes3(mpd);
  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, "BaseURL"));
  mpdAttributes.type = mpdAttributes.type || "static";
  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
  mpdAttributes.NOW = NOW;
  mpdAttributes.clientOffset = clientOffset;
  if (locations.length) {
    mpdAttributes.locations = locations.map(getContent);
  }
  var periods = [];
  periodNodes.forEach(function(node, index) {
    var attributes = parseAttributes3(node);
    var priorPeriod = periods[index - 1];
    attributes.start = getPeriodStart({
      attributes,
      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
      mpdType: mpdAttributes.type
    });
    periods.push({
      node,
      attributes
    });
  });
  return {
    locations: mpdAttributes.locations,
    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))
  };
};
var stringToMpdXml = function stringToMpdXml2(manifestString) {
  if (manifestString === "") {
    throw new Error(errors.DASH_EMPTY_MANIFEST);
  }
  var parser6 = new import_xmldom.DOMParser();
  var xml;
  var mpd;
  try {
    xml = parser6.parseFromString(manifestString, "application/xml");
    mpd = xml && xml.documentElement.tagName === "MPD" ? xml.documentElement : null;
  } catch (e) {
  }
  if (!mpd || mpd && mpd.getElementsByTagName("parsererror").length > 0) {
    throw new Error(errors.DASH_INVALID_XML);
  }
  return mpd;
};
var parseUTCTimingScheme = function parseUTCTimingScheme2(mpd) {
  var UTCTimingNode = findChildren(mpd, "UTCTiming")[0];
  if (!UTCTimingNode) {
    return null;
  }
  var attributes = parseAttributes3(UTCTimingNode);
  switch (attributes.schemeIdUri) {
    case "urn:mpeg:dash:utc:http-head:2014":
    case "urn:mpeg:dash:utc:http-head:2012":
      attributes.method = "HEAD";
      break;
    case "urn:mpeg:dash:utc:http-xsdate:2014":
    case "urn:mpeg:dash:utc:http-iso:2014":
    case "urn:mpeg:dash:utc:http-xsdate:2012":
    case "urn:mpeg:dash:utc:http-iso:2012":
      attributes.method = "GET";
      break;
    case "urn:mpeg:dash:utc:direct:2014":
    case "urn:mpeg:dash:utc:direct:2012":
      attributes.method = "DIRECT";
      attributes.value = Date.parse(attributes.value);
      break;
    case "urn:mpeg:dash:utc:http-ntp:2014":
    case "urn:mpeg:dash:utc:ntp:2014":
    case "urn:mpeg:dash:utc:sntp:2014":
    default:
      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);
  }
  return attributes;
};
var parse = function parse2(manifestString, options) {
  if (options === void 0) {
    options = {};
  }
  var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);
  var playlists = toPlaylists(parsedManifestInfo.representationInfo);
  return toM3u8({
    dashPlaylists: playlists,
    locations: parsedManifestInfo.locations,
    sidxMapping: options.sidxMapping,
    previousManifest: options.previousManifest
  });
};
var parseUTCTiming = function parseUTCTiming2(manifestString) {
  return parseUTCTimingScheme(stringToMpdXml(manifestString));
};

// node_modules/video.js/dist/video.es.js
var import_parse_sidx = __toESM(require_parse_sidx());

// node_modules/@videojs/vhs-utils/es/id3-helpers.js
var ID3 = toUint8([73, 68, 51]);
var getId3Size = function getId3Size2(bytes, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  bytes = toUint8(bytes);
  var flags = bytes[offset + 5];
  var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];
  var footerPresent = (flags & 16) >> 4;
  if (footerPresent) {
    return returnSize + 20;
  }
  return returnSize + 10;
};
var getId3Offset = function getId3Offset2(bytes, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  bytes = toUint8(bytes);
  if (bytes.length - offset < 10 || !bytesMatch(bytes, ID3, {
    offset
  })) {
    return offset;
  }
  offset += getId3Size(bytes, offset);
  return getId3Offset2(bytes, offset);
};

// node_modules/@videojs/vhs-utils/es/opus-helpers.js
var OPUS_HEAD = new Uint8Array([
  // O, p, u, s
  79,
  112,
  117,
  115,
  // H, e, a, d
  72,
  101,
  97,
  100
]);

// node_modules/@videojs/vhs-utils/es/mp4-helpers.js
var normalizePath = function normalizePath2(path) {
  if (typeof path === "string") {
    return stringToBytes(path);
  }
  if (typeof path === "number") {
    return path;
  }
  return path;
};
var normalizePaths = function normalizePaths2(paths) {
  if (!Array.isArray(paths)) {
    return [normalizePath(paths)];
  }
  return paths.map(function(p) {
    return normalizePath(p);
  });
};
var DESCRIPTORS;
var parseDescriptors = function parseDescriptors2(bytes) {
  bytes = toUint8(bytes);
  var results = [];
  var i = 0;
  while (bytes.length > i) {
    var tag = bytes[i];
    var size = 0;
    var headerSize = 0;
    headerSize++;
    var byte = bytes[headerSize];
    headerSize++;
    while (byte & 128) {
      size = (byte & 127) << 7;
      byte = bytes[headerSize];
      headerSize++;
    }
    size += byte & 127;
    for (var z2 = 0; z2 < DESCRIPTORS.length; z2++) {
      var _DESCRIPTORS$z = DESCRIPTORS[z2], id = _DESCRIPTORS$z.id, parser6 = _DESCRIPTORS$z.parser;
      if (tag === id) {
        results.push(parser6(bytes.subarray(headerSize, headerSize + size)));
        break;
      }
    }
    i += size + headerSize;
  }
  return results;
};
DESCRIPTORS = [{
  id: 3,
  parser: function parser(bytes) {
    var desc = {
      tag: 3,
      id: bytes[0] << 8 | bytes[1],
      flags: bytes[2],
      size: 3,
      dependsOnEsId: 0,
      ocrEsId: 0,
      descriptors: [],
      url: ""
    };
    if (desc.flags & 128) {
      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
      desc.size += 2;
    }
    if (desc.flags & 64) {
      var len = bytes[desc.size];
      desc.url = bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));
      desc.size += len;
    }
    if (desc.flags & 32) {
      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
      desc.size += 2;
    }
    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];
    return desc;
  }
}, {
  id: 4,
  parser: function parser2(bytes) {
    var desc = {
      tag: 4,
      oti: bytes[0],
      streamType: bytes[1],
      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],
      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],
      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],
      descriptors: parseDescriptors(bytes.subarray(13))
    };
    return desc;
  }
}, {
  id: 5,
  parser: function parser3(bytes) {
    return {
      tag: 5,
      bytes
    };
  }
}, {
  id: 6,
  parser: function parser4(bytes) {
    return {
      tag: 6,
      bytes
    };
  }
}];
var findBox = function findBox2(bytes, paths, complete) {
  if (complete === void 0) {
    complete = false;
  }
  paths = normalizePaths(paths);
  bytes = toUint8(bytes);
  var results = [];
  if (!paths.length) {
    return results;
  }
  var i = 0;
  while (i < bytes.length) {
    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
    var type2 = bytes.subarray(i + 4, i + 8);
    if (size === 0) {
      break;
    }
    var end = i + size;
    if (end > bytes.length) {
      if (complete) {
        break;
      }
      end = bytes.length;
    }
    var data = bytes.subarray(i + 8, end);
    if (bytesMatch(type2, paths[0])) {
      if (paths.length === 1) {
        results.push(data);
      } else {
        results.push.apply(results, findBox2(data, paths.slice(1), complete));
      }
    }
    i = end;
  }
  return results;
};

// node_modules/@videojs/vhs-utils/es/ebml-helpers.js
var EBML_TAGS = {
  EBML: toUint8([26, 69, 223, 163]),
  DocType: toUint8([66, 130]),
  Segment: toUint8([24, 83, 128, 103]),
  SegmentInfo: toUint8([21, 73, 169, 102]),
  Tracks: toUint8([22, 84, 174, 107]),
  Track: toUint8([174]),
  TrackNumber: toUint8([215]),
  DefaultDuration: toUint8([35, 227, 131]),
  TrackEntry: toUint8([174]),
  TrackType: toUint8([131]),
  FlagDefault: toUint8([136]),
  CodecID: toUint8([134]),
  CodecPrivate: toUint8([99, 162]),
  VideoTrack: toUint8([224]),
  AudioTrack: toUint8([225]),
  // Not used yet, but will be used for live webm/mkv
  // see https://www.matroska.org/technical/basics.html#block-structure
  // see https://www.matroska.org/technical/basics.html#simpleblock-structure
  Cluster: toUint8([31, 67, 182, 117]),
  Timestamp: toUint8([231]),
  TimestampScale: toUint8([42, 215, 177]),
  BlockGroup: toUint8([160]),
  BlockDuration: toUint8([155]),
  Block: toUint8([161]),
  SimpleBlock: toUint8([163])
};
var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];
var getLength = function getLength2(byte) {
  var len = 1;
  for (var i = 0; i < LENGTH_TABLE.length; i++) {
    if (byte & LENGTH_TABLE[i]) {
      break;
    }
    len++;
  }
  return len;
};
var getvint = function getvint2(bytes, offset, removeLength, signed) {
  if (removeLength === void 0) {
    removeLength = true;
  }
  if (signed === void 0) {
    signed = false;
  }
  var length = getLength(bytes[offset]);
  var valueBytes = bytes.subarray(offset, offset + length);
  if (removeLength) {
    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);
    valueBytes[0] ^= LENGTH_TABLE[length - 1];
  }
  return {
    length,
    value: bytesToNumber(valueBytes, {
      signed
    }),
    bytes: valueBytes
  };
};
var normalizePath3 = function normalizePath4(path) {
  if (typeof path === "string") {
    return path.match(/.{1,2}/g).map(function(p) {
      return normalizePath4(p);
    });
  }
  if (typeof path === "number") {
    return numberToBytes(path);
  }
  return path;
};
var normalizePaths3 = function normalizePaths4(paths) {
  if (!Array.isArray(paths)) {
    return [normalizePath3(paths)];
  }
  return paths.map(function(p) {
    return normalizePath3(p);
  });
};
var getInfinityDataSize = function getInfinityDataSize2(id, bytes, offset) {
  if (offset >= bytes.length) {
    return bytes.length;
  }
  var innerid = getvint(bytes, offset, false);
  if (bytesMatch(id.bytes, innerid.bytes)) {
    return offset;
  }
  var dataHeader = getvint(bytes, offset + innerid.length);
  return getInfinityDataSize2(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);
};
var findEbml = function findEbml2(bytes, paths) {
  paths = normalizePaths3(paths);
  bytes = toUint8(bytes);
  var results = [];
  if (!paths.length) {
    return results;
  }
  var i = 0;
  while (i < bytes.length) {
    var id = getvint(bytes, i, false);
    var dataHeader = getvint(bytes, i + id.length);
    var dataStart = i + id.length + dataHeader.length;
    if (dataHeader.value === 127) {
      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);
      if (dataHeader.value !== bytes.length) {
        dataHeader.value -= dataStart;
      }
    }
    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
    var data = bytes.subarray(dataStart, dataEnd);
    if (bytesMatch(paths[0], id.bytes)) {
      if (paths.length === 1) {
        results.push(data);
      } else {
        results = results.concat(findEbml2(data, paths.slice(1)));
      }
    }
    var totalLength = id.length + dataHeader.length + data.length;
    i += totalLength;
  }
  return results;
};

// node_modules/@videojs/vhs-utils/es/nal-helpers.js
var NAL_TYPE_ONE = toUint8([0, 0, 0, 1]);
var NAL_TYPE_TWO = toUint8([0, 0, 1]);
var EMULATION_PREVENTION = toUint8([0, 0, 3]);
var discardEmulationPreventionBytes = function discardEmulationPreventionBytes2(bytes) {
  var positions = [];
  var i = 1;
  while (i < bytes.length - 2) {
    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {
      positions.push(i + 2);
      i++;
    }
    i++;
  }
  if (positions.length === 0) {
    return bytes;
  }
  var newLength = bytes.length - positions.length;
  var newData = new Uint8Array(newLength);
  var sourceIndex = 0;
  for (i = 0; i < newLength; sourceIndex++, i++) {
    if (sourceIndex === positions[0]) {
      sourceIndex++;
      positions.shift();
    }
    newData[i] = bytes[sourceIndex];
  }
  return newData;
};
var findNal = function findNal2(bytes, dataType, types, nalLimit) {
  if (nalLimit === void 0) {
    nalLimit = Infinity;
  }
  bytes = toUint8(bytes);
  types = [].concat(types);
  var i = 0;
  var nalStart;
  var nalsFound = 0;
  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
    var nalOffset = void 0;
    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {
      nalOffset = 4;
    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {
      nalOffset = 3;
    }
    if (!nalOffset) {
      i++;
      continue;
    }
    nalsFound++;
    if (nalStart) {
      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
    }
    var nalType = void 0;
    if (dataType === "h264") {
      nalType = bytes[i + nalOffset] & 31;
    } else if (dataType === "h265") {
      nalType = bytes[i + nalOffset] >> 1 & 63;
    }
    if (types.indexOf(nalType) !== -1) {
      nalStart = i + nalOffset;
    }
    i += nalOffset + (dataType === "h264" ? 1 : 2);
  }
  return bytes.subarray(0, 0);
};
var findH264Nal = function findH264Nal2(bytes, type2, nalLimit) {
  return findNal(bytes, "h264", type2, nalLimit);
};
var findH265Nal = function findH265Nal2(bytes, type2, nalLimit) {
  return findNal(bytes, "h265", type2, nalLimit);
};

// node_modules/@videojs/vhs-utils/es/containers.js
var CONSTANTS = {
  // "webm" string literal in hex
  "webm": toUint8([119, 101, 98, 109]),
  // "matroska" string literal in hex
  "matroska": toUint8([109, 97, 116, 114, 111, 115, 107, 97]),
  // "fLaC" string literal in hex
  "flac": toUint8([102, 76, 97, 67]),
  // "OggS" string literal in hex
  "ogg": toUint8([79, 103, 103, 83]),
  // ac-3 sync byte, also works for ec-3 as that is simply a codec
  // of ac-3
  "ac3": toUint8([11, 119]),
  // "RIFF" string literal in hex used for wav and avi
  "riff": toUint8([82, 73, 70, 70]),
  // "AVI" string literal in hex
  "avi": toUint8([65, 86, 73]),
  // "WAVE" string literal in hex
  "wav": toUint8([87, 65, 86, 69]),
  // "ftyp3g" string literal in hex
  "3gp": toUint8([102, 116, 121, 112, 51, 103]),
  // "ftyp" string literal in hex
  "mp4": toUint8([102, 116, 121, 112]),
  // "styp" string literal in hex
  "fmp4": toUint8([115, 116, 121, 112]),
  // "ftypqt" string literal in hex
  "mov": toUint8([102, 116, 121, 112, 113, 116]),
  // moov string literal in hex
  "moov": toUint8([109, 111, 111, 118]),
  // moof string literal in hex
  "moof": toUint8([109, 111, 111, 102])
};
var _isLikely = {
  aac: function aac(bytes) {
    var offset = getId3Offset(bytes);
    return bytesMatch(bytes, [255, 16], {
      offset,
      mask: [255, 22]
    });
  },
  mp3: function mp3(bytes) {
    var offset = getId3Offset(bytes);
    return bytesMatch(bytes, [255, 2], {
      offset,
      mask: [255, 6]
    });
  },
  webm: function webm(bytes) {
    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
    return bytesMatch(docType, CONSTANTS.webm);
  },
  mkv: function mkv(bytes) {
    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
    return bytesMatch(docType, CONSTANTS.matroska);
  },
  mp4: function mp4(bytes) {
    if (_isLikely["3gp"](bytes) || _isLikely.mov(bytes)) {
      return false;
    }
    if (bytesMatch(bytes, CONSTANTS.mp4, {
      offset: 4
    }) || bytesMatch(bytes, CONSTANTS.fmp4, {
      offset: 4
    })) {
      return true;
    }
    if (bytesMatch(bytes, CONSTANTS.moof, {
      offset: 4
    }) || bytesMatch(bytes, CONSTANTS.moov, {
      offset: 4
    })) {
      return true;
    }
  },
  mov: function mov(bytes) {
    return bytesMatch(bytes, CONSTANTS.mov, {
      offset: 4
    });
  },
  "3gp": function gp(bytes) {
    return bytesMatch(bytes, CONSTANTS["3gp"], {
      offset: 4
    });
  },
  ac3: function ac3(bytes) {
    var offset = getId3Offset(bytes);
    return bytesMatch(bytes, CONSTANTS.ac3, {
      offset
    });
  },
  ts: function ts(bytes) {
    if (bytes.length < 189 && bytes.length >= 1) {
      return bytes[0] === 71;
    }
    var i = 0;
    while (i + 188 < bytes.length && i < 188) {
      if (bytes[i] === 71 && bytes[i + 188] === 71) {
        return true;
      }
      i += 1;
    }
    return false;
  },
  flac: function flac(bytes) {
    var offset = getId3Offset(bytes);
    return bytesMatch(bytes, CONSTANTS.flac, {
      offset
    });
  },
  ogg: function ogg(bytes) {
    return bytesMatch(bytes, CONSTANTS.ogg);
  },
  avi: function avi(bytes) {
    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {
      offset: 8
    });
  },
  wav: function wav(bytes) {
    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {
      offset: 8
    });
  },
  "h264": function h264(bytes) {
    return findH264Nal(bytes, 7, 3).length;
  },
  "h265": function h265(bytes) {
    return findH265Nal(bytes, [32, 33], 3).length;
  }
};
var isLikelyTypes = Object.keys(_isLikely).filter(function(t2) {
  return t2 !== "ts" && t2 !== "h264" && t2 !== "h265";
}).concat(["ts", "h264", "h265"]);
isLikelyTypes.forEach(function(type2) {
  var isLikelyFn = _isLikely[type2];
  _isLikely[type2] = function(bytes) {
    return isLikelyFn(toUint8(bytes));
  };
});
var isLikely = _isLikely;
var detectContainerForBytes = function detectContainerForBytes2(bytes) {
  bytes = toUint8(bytes);
  for (var i = 0; i < isLikelyTypes.length; i++) {
    var type2 = isLikelyTypes[i];
    if (isLikely[type2](bytes)) {
      return type2;
    }
  }
  return "";
};
var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment2(bytes) {
  return findBox(bytes, ["moof"]).length > 0;
};

// node_modules/video.js/dist/video.es.js
var import_clock = __toESM(require_clock());

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, _getPrototypeOf(t2);
}

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t2) {
  try {
    return -1 !== Function.toString.call(t2).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t2;
  }
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t2) {
  var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t3) {
    if (null === t3 || !_isNativeFunction(t3)) return t3;
    if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r2) {
      if (r2.has(t3)) return r2.get(t3);
      r2.set(t3, Wrapper);
    }
    function Wrapper() {
      return _construct(t3, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t3.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t3);
  }, _wrapNativeSuper(t2);
}

// node_modules/video.js/dist/video.es.js
var version$5 = "7.21.7";
var hooks_ = {};
var hooks = function hooks2(type2, fn) {
  hooks_[type2] = hooks_[type2] || [];
  if (fn) {
    hooks_[type2] = hooks_[type2].concat(fn);
  }
  return hooks_[type2];
};
var hook = function hook2(type2, fn) {
  hooks(type2, fn);
};
var removeHook = function removeHook2(type2, fn) {
  var index = hooks(type2).indexOf(fn);
  if (index <= -1) {
    return false;
  }
  hooks_[type2] = hooks_[type2].slice();
  hooks_[type2].splice(index, 1);
  return true;
};
var hookOnce = function hookOnce2(type2, fn) {
  hooks(type2, [].concat(fn).map(function(original) {
    var wrapper = function wrapper2() {
      removeHook(type2, wrapper2);
      return original.apply(void 0, arguments);
    };
    return wrapper;
  }));
};
var FullscreenApi = {
  prefixed: true
};
var apiMap = [
  ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
  // WebKit
  ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"],
  // Mozilla
  ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen"],
  // Microsoft
  ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen"]
];
var specApi = apiMap[0];
var browserApi;
for (i = 0; i < apiMap.length; i++) {
  if (apiMap[i][1] in import_document.default) {
    browserApi = apiMap[i];
    break;
  }
}
var i;
if (browserApi) {
  for (_i = 0; _i < browserApi.length; _i++) {
    FullscreenApi[specApi[_i]] = browserApi[_i];
  }
  FullscreenApi.prefixed = browserApi[0] !== specApi[0];
}
var _i;
var history = [];
var LogByTypeFactory = function LogByTypeFactory2(name, log2) {
  return function(type2, level, args) {
    var lvl = log2.levels[level];
    var lvlRegExp = new RegExp("^(" + lvl + ")$");
    if (type2 !== "log") {
      args.unshift(type2.toUpperCase() + ":");
    }
    args.unshift(name + ":");
    if (history) {
      history.push([].concat(args));
      var splice = history.length - 1e3;
      history.splice(0, splice > 0 ? splice : 0);
    }
    if (!import_window6.default.console) {
      return;
    }
    var fn = import_window6.default.console[type2];
    if (!fn && type2 === "debug") {
      fn = import_window6.default.console.info || import_window6.default.console.log;
    }
    if (!fn || !lvl || !lvlRegExp.test(type2)) {
      return;
    }
    fn[Array.isArray(args) ? "apply" : "call"](import_window6.default.console, args);
  };
};
function createLogger$1(name) {
  var level = "info";
  var logByType;
  var log2 = function log3() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    logByType("log", level, args);
  };
  logByType = LogByTypeFactory(name, log2);
  log2.createLogger = function(subname) {
    return createLogger$1(name + ": " + subname);
  };
  log2.levels = {
    all: "debug|log|warn|error",
    off: "",
    debug: "debug|log|warn|error",
    info: "log|warn|error",
    warn: "warn|error",
    error: "error",
    DEFAULT: level
  };
  log2.level = function(lvl) {
    if (typeof lvl === "string") {
      if (!log2.levels.hasOwnProperty(lvl)) {
        throw new Error('"' + lvl + '" in not a valid log level');
      }
      level = lvl;
    }
    return level;
  };
  log2.history = function() {
    return history ? [].concat(history) : [];
  };
  log2.history.filter = function(fname) {
    return (history || []).filter(function(historyItem) {
      return new RegExp(".*" + fname + ".*").test(historyItem[0]);
    });
  };
  log2.history.clear = function() {
    if (history) {
      history.length = 0;
    }
  };
  log2.history.disable = function() {
    if (history !== null) {
      history.length = 0;
      history = null;
    }
  };
  log2.history.enable = function() {
    if (history === null) {
      history = [];
    }
  };
  log2.error = function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return logByType("error", level, args);
  };
  log2.warn = function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return logByType("warn", level, args);
  };
  log2.debug = function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return logByType("debug", level, args);
  };
  return log2;
}
var log$1 = createLogger$1("VIDEOJS");
var createLogger = log$1.createLogger;
var toString = Object.prototype.toString;
var keys = function keys2(object) {
  return isObject3(object) ? Object.keys(object) : [];
};
function each(object, fn) {
  keys(object).forEach(function(key) {
    return fn(object[key], key);
  });
}
function reduce(object, fn, initial) {
  if (initial === void 0) {
    initial = 0;
  }
  return keys(object).reduce(function(accum, key) {
    return fn(accum, object[key], key);
  }, initial);
}
function assign(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }
  if (Object.assign) {
    return _extends.apply(void 0, [target].concat(sources));
  }
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    each(source, function(value, key) {
      target[key] = value;
    });
  });
  return target;
}
function isObject3(value) {
  return !!value && typeof value === "object";
}
function isPlain(value) {
  return isObject3(value) && toString.call(value) === "[object Object]" && value.constructor === Object;
}
function computedStyle(el, prop) {
  if (!el || !prop) {
    return "";
  }
  if (typeof import_window6.default.getComputedStyle === "function") {
    var computedStyleValue;
    try {
      computedStyleValue = import_window6.default.getComputedStyle(el);
    } catch (e) {
      return "";
    }
    return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : "";
  }
  return "";
}
var USER_AGENT = import_window6.default.navigator && import_window6.default.navigator.userAgent || "";
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IOS_VERSION = function() {
  var match = USER_AGENT.match(/OS (\d+)_/i);
  if (match && match[1]) {
    return match[1];
  }
  return null;
}();
var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = function() {
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
  if (!match) {
    return null;
  }
  var major = match[1] && parseFloat(match[1]);
  var minor = match[2] && parseFloat(match[2]);
  if (major && minor) {
    return parseFloat(match[1] + "." + match[2]);
  } else if (major) {
    return major;
  }
  return null;
}();
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;
var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_EDGE = /Edg/i.test(USER_AGENT);
var IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));
var CHROME_VERSION = function() {
  var match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
  if (match && match[2]) {
    return parseFloat(match[2]);
  }
  return null;
}();
var IE_VERSION = function() {
  var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
  var version2 = result && parseFloat(result[1]);
  if (!version2 && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
    version2 = 11;
  }
  return version2;
}();
var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
var IS_WINDOWS = /Windows/i.test(USER_AGENT);
var TOUCH_ENABLED = Boolean(isReal() && ("ontouchstart" in import_window6.default || import_window6.default.navigator.maxTouchPoints || import_window6.default.DocumentTouch && import_window6.default.document instanceof import_window6.default.DocumentTouch));
var IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
var IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
var browser = Object.freeze({
  __proto__: null,
  IS_IPOD,
  IOS_VERSION,
  IS_ANDROID,
  ANDROID_VERSION,
  IS_NATIVE_ANDROID,
  IS_FIREFOX,
  IS_EDGE,
  IS_CHROME,
  CHROME_VERSION,
  IE_VERSION,
  IS_SAFARI,
  IS_WINDOWS,
  TOUCH_ENABLED,
  IS_IPAD,
  IS_IPHONE,
  IS_IOS,
  IS_ANY_SAFARI
});
function isNonBlankString(str) {
  return typeof str === "string" && Boolean(str.trim());
}
function throwIfWhitespace(str) {
  if (str.indexOf(" ") >= 0) {
    throw new Error("class has illegal whitespace characters");
  }
}
function classRegExp(className) {
  return new RegExp("(^|\\s)" + className + "($|\\s)");
}
function isReal() {
  return import_document.default === import_window6.default.document;
}
function isEl(value) {
  return isObject3(value) && value.nodeType === 1;
}
function isInFrame() {
  try {
    return import_window6.default.parent !== import_window6.default.self;
  } catch (x) {
    return true;
  }
}
function createQuerier(method) {
  return function(selector, context) {
    if (!isNonBlankString(selector)) {
      return import_document.default[method](null);
    }
    if (isNonBlankString(context)) {
      context = import_document.default.querySelector(context);
    }
    var ctx = isEl(context) ? context : import_document.default;
    return ctx[method] && ctx[method](selector);
  };
}
function createEl(tagName, properties, attributes, content) {
  if (tagName === void 0) {
    tagName = "div";
  }
  if (properties === void 0) {
    properties = {};
  }
  if (attributes === void 0) {
    attributes = {};
  }
  var el = import_document.default.createElement(tagName);
  Object.getOwnPropertyNames(properties).forEach(function(propName) {
    var val = properties[propName];
    if (propName.indexOf("aria-") !== -1 || propName === "role" || propName === "type") {
      log$1.warn("Setting attributes in the second argument of createEl()\nhas been deprecated. Use the third argument instead.\n" + ("createEl(type, properties, attributes). Attempting to set " + propName + " to " + val + "."));
      el.setAttribute(propName, val);
    } else if (propName === "textContent") {
      textContent(el, val);
    } else if (el[propName] !== val || propName === "tabIndex") {
      el[propName] = val;
    }
  });
  Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
    el.setAttribute(attrName, attributes[attrName]);
  });
  if (content) {
    appendContent(el, content);
  }
  return el;
}
function textContent(el, text) {
  if (typeof el.textContent === "undefined") {
    el.innerText = text;
  } else {
    el.textContent = text;
  }
  return el;
}
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  }
  return classRegExp(classToCheck).test(element.className);
}
function addClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);
  } else if (!hasClass(element, classToAdd)) {
    element.className = (element.className + " " + classToAdd).trim();
  }
  return element;
}
function removeClass(element, classToRemove) {
  if (!element) {
    log$1.warn("removeClass was called with an element that doesn't exist");
    return null;
  }
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function(c) {
      return c !== classToRemove;
    }).join(" ");
  }
  return element;
}
function toggleClass(element, classToToggle, predicate) {
  var has = hasClass(element, classToToggle);
  if (typeof predicate === "function") {
    predicate = predicate(element, classToToggle);
  }
  if (typeof predicate !== "boolean") {
    predicate = !has;
  }
  if (predicate === has) {
    return;
  }
  if (predicate) {
    addClass(element, classToToggle);
  } else {
    removeClass(element, classToToggle);
  }
  return element;
}
function setAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
    var attrValue = attributes[attrName];
    if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? "" : attrValue);
    }
  });
}
function getAttributes(tag) {
  var obj = {};
  var knownBooleans = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
  if (tag && tag.attributes && tag.attributes.length > 0) {
    var attrs = tag.attributes;
    for (var i = attrs.length - 1; i >= 0; i--) {
      var attrName = attrs[i].name;
      var attrVal = attrs[i].value;
      if (typeof tag[attrName] === "boolean" || knownBooleans.indexOf("," + attrName + ",") !== -1) {
        attrVal = attrVal !== null ? true : false;
      }
      obj[attrName] = attrVal;
    }
  }
  return obj;
}
function getAttribute(el, attribute) {
  return el.getAttribute(attribute);
}
function setAttribute(el, attribute, value) {
  el.setAttribute(attribute, value);
}
function removeAttribute(el, attribute) {
  el.removeAttribute(attribute);
}
function blockTextSelection() {
  import_document.default.body.focus();
  import_document.default.onselectstart = function() {
    return false;
  };
}
function unblockTextSelection() {
  import_document.default.onselectstart = function() {
    return true;
  };
}
function getBoundingClientRect(el) {
  if (el && el.getBoundingClientRect && el.parentNode) {
    var rect = el.getBoundingClientRect();
    var result = {};
    ["bottom", "height", "left", "right", "top", "width"].forEach(function(k2) {
      if (rect[k2] !== void 0) {
        result[k2] = rect[k2];
      }
    });
    if (!result.height) {
      result.height = parseFloat(computedStyle(el, "height"));
    }
    if (!result.width) {
      result.width = parseFloat(computedStyle(el, "width"));
    }
    return result;
  }
}
function findPosition(el) {
  if (!el || el && !el.offsetParent) {
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  }
  var width2 = el.offsetWidth;
  var height2 = el.offsetHeight;
  var left = 0;
  var top = 0;
  while (el.offsetParent && el !== import_document.default[FullscreenApi.fullscreenElement]) {
    left += el.offsetLeft;
    top += el.offsetTop;
    el = el.offsetParent;
  }
  return {
    left,
    top,
    width: width2,
    height: height2
  };
}
function getPointerPosition(el, event) {
  var translated = {
    x: 0,
    y: 0
  };
  if (IS_IOS) {
    var item = el;
    while (item && item.nodeName.toLowerCase() !== "html") {
      var transform3 = computedStyle(item, "transform");
      if (/^matrix/.test(transform3)) {
        var values3 = transform3.slice(7, -1).split(/,\s/).map(Number);
        translated.x += values3[4];
        translated.y += values3[5];
      } else if (/^matrix3d/.test(transform3)) {
        var _values = transform3.slice(9, -1).split(/,\s/).map(Number);
        translated.x += _values[12];
        translated.y += _values[13];
      }
      item = item.parentNode;
    }
  }
  var position = {};
  var boxTarget = findPosition(event.target);
  var box = findPosition(el);
  var boxW = box.width;
  var boxH = box.height;
  var offsetY = event.offsetY - (box.top - boxTarget.top);
  var offsetX = event.offsetX - (box.left - boxTarget.left);
  if (event.changedTouches) {
    offsetX = event.changedTouches[0].pageX - box.left;
    offsetY = event.changedTouches[0].pageY + box.top;
    if (IS_IOS) {
      offsetX -= translated.x;
      offsetY -= translated.y;
    }
  }
  position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
  position.x = Math.max(0, Math.min(1, offsetX / boxW));
  return position;
}
function isTextNode(value) {
  return isObject3(value) && value.nodeType === 3;
}
function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}
function normalizeContent(content) {
  if (typeof content === "function") {
    content = content();
  }
  return (Array.isArray(content) ? content : [content]).map(function(value) {
    if (typeof value === "function") {
      value = value();
    }
    if (isEl(value) || isTextNode(value)) {
      return value;
    }
    if (typeof value === "string" && /\S/.test(value)) {
      return import_document.default.createTextNode(value);
    }
  }).filter(function(value) {
    return value;
  });
}
function appendContent(el, content) {
  normalizeContent(content).forEach(function(node) {
    return el.appendChild(node);
  });
  return el;
}
function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}
function isSingleLeftClick(event) {
  if (event.button === void 0 && event.buttons === void 0) {
    return true;
  }
  if (event.button === 0 && event.buttons === void 0) {
    return true;
  }
  if (event.type === "mouseup" && event.button === 0 && event.buttons === 0) {
    return true;
  }
  if (event.button !== 0 || event.buttons !== 1) {
    return false;
  }
  return true;
}
var $ = createQuerier("querySelector");
var $$ = createQuerier("querySelectorAll");
var Dom = Object.freeze({
  __proto__: null,
  isReal,
  isEl,
  isInFrame,
  createEl,
  textContent,
  prependTo,
  hasClass,
  addClass,
  removeClass,
  toggleClass,
  setAttributes,
  getAttributes,
  getAttribute,
  setAttribute,
  removeAttribute,
  blockTextSelection,
  unblockTextSelection,
  getBoundingClientRect,
  findPosition,
  getPointerPosition,
  isTextNode,
  emptyEl,
  normalizeContent,
  appendContent,
  insertContent,
  isSingleLeftClick,
  $,
  $$
});
var _windowLoaded = false;
var videojs$1;
var autoSetup = function autoSetup2() {
  if (videojs$1.options.autoSetup === false) {
    return;
  }
  var vids = Array.prototype.slice.call(import_document.default.getElementsByTagName("video"));
  var audios = Array.prototype.slice.call(import_document.default.getElementsByTagName("audio"));
  var divs = Array.prototype.slice.call(import_document.default.getElementsByTagName("video-js"));
  var mediaEls = vids.concat(audios, divs);
  if (mediaEls && mediaEls.length > 0) {
    for (var i = 0, e = mediaEls.length; i < e; i++) {
      var mediaEl = mediaEls[i];
      if (mediaEl && mediaEl.getAttribute) {
        if (mediaEl.player === void 0) {
          var options = mediaEl.getAttribute("data-setup");
          if (options !== null) {
            videojs$1(mediaEl);
          }
        }
      } else {
        autoSetupTimeout(1);
        break;
      }
    }
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};
function autoSetupTimeout(wait, vjs) {
  if (!isReal()) {
    return;
  }
  if (vjs) {
    videojs$1 = vjs;
  }
  import_window6.default.setTimeout(autoSetup, wait);
}
function setWindowLoaded() {
  _windowLoaded = true;
  import_window6.default.removeEventListener("load", setWindowLoaded);
}
if (isReal()) {
  if (import_document.default.readyState === "complete") {
    setWindowLoaded();
  } else {
    import_window6.default.addEventListener("load", setWindowLoaded);
  }
}
var createStyleElement = function createStyleElement2(className) {
  var style = import_document.default.createElement("style");
  style.className = className;
  return style;
};
var setTextContent = function setTextContent2(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};
var _initialGuid = 3;
var _guid = _initialGuid;
function newGUID() {
  return _guid++;
}
var FakeWeakMap;
if (!import_window6.default.WeakMap) {
  FakeWeakMap = function() {
    function FakeWeakMap2() {
      this.vdata = "vdata" + Math.floor(import_window6.default.performance && import_window6.default.performance.now() || Date.now());
      this.data = {};
    }
    var _proto = FakeWeakMap2.prototype;
    _proto.set = function set4(key, value) {
      var access = key[this.vdata] || newGUID();
      if (!key[this.vdata]) {
        key[this.vdata] = access;
      }
      this.data[access] = value;
      return this;
    };
    _proto.get = function get7(key) {
      var access = key[this.vdata];
      if (access) {
        return this.data[access];
      }
      log$1("We have no data for this element", key);
      return void 0;
    };
    _proto.has = function has(key) {
      var access = key[this.vdata];
      return access in this.data;
    };
    _proto["delete"] = function _delete(key) {
      var access = key[this.vdata];
      if (access) {
        delete this.data[access];
        delete key[this.vdata];
      }
    };
    return FakeWeakMap2;
  }();
}
var DomData = import_window6.default.WeakMap ? /* @__PURE__ */ new WeakMap() : new FakeWeakMap();
function _cleanUpEvents(elem, type2) {
  if (!DomData.has(elem)) {
    return;
  }
  var data = DomData.get(elem);
  if (data.handlers[type2].length === 0) {
    delete data.handlers[type2];
    if (elem.removeEventListener) {
      elem.removeEventListener(type2, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent("on" + type2, data.dispatcher);
    }
  }
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }
  if (Object.getOwnPropertyNames(data).length === 0) {
    DomData["delete"](elem);
  }
}
function _handleMultipleEvents(fn, elem, types, callback2) {
  types.forEach(function(type2) {
    fn(elem, type2, callback2);
  });
}
function fixEvent(event) {
  if (event.fixed_) {
    return event;
  }
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
    var old = event || import_window6.default.event;
    event = {};
    for (var key in old) {
      if (key !== "layerX" && key !== "layerY" && key !== "keyLocation" && key !== "webkitMovementX" && key !== "webkitMovementY" && key !== "path") {
        if (!(key === "returnValue" && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }
    if (!event.target) {
      event.target = event.srcElement || import_document.default;
    }
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }
    event.preventDefault = function() {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };
    event.defaultPrevented = false;
    event.stopPropagation = function() {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };
    event.isPropagationStopped = returnFalse;
    event.stopImmediatePropagation = function() {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };
    event.isImmediatePropagationStopped = returnFalse;
    if (event.clientX !== null && event.clientX !== void 0) {
      var doc = import_document.default.documentElement;
      var body = import_document.default.body;
      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }
    event.which = event.charCode || event.keyCode;
    if (event.button !== null && event.button !== void 0) {
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
    }
  }
  event.fixed_ = true;
  return event;
}
var _supportsPassive;
var supportsPassive = function supportsPassive2() {
  if (typeof _supportsPassive !== "boolean") {
    _supportsPassive = false;
    try {
      var opts = Object.defineProperty({}, "passive", {
        get: function get7() {
          _supportsPassive = true;
        }
      });
      import_window6.default.addEventListener("test", null, opts);
      import_window6.default.removeEventListener("test", null, opts);
    } catch (e) {
    }
  }
  return _supportsPassive;
};
var passiveEvents = ["touchstart", "touchmove"];
function on(elem, type2, fn) {
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(on, elem, type2, fn);
  }
  if (!DomData.has(elem)) {
    DomData.set(elem, {});
  }
  var data = DomData.get(elem);
  if (!data.handlers) {
    data.handlers = {};
  }
  if (!data.handlers[type2]) {
    data.handlers[type2] = [];
  }
  if (!fn.guid) {
    fn.guid = newGUID();
  }
  data.handlers[type2].push(fn);
  if (!data.dispatcher) {
    data.disabled = false;
    data.dispatcher = function(event, hash) {
      if (data.disabled) {
        return;
      }
      event = fixEvent(event);
      var handlers = data.handlers[event.type];
      if (handlers) {
        var handlersCopy = handlers.slice(0);
        for (var m2 = 0, n = handlersCopy.length; m2 < n; m2++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m2].call(elem, event, hash);
            } catch (e) {
              log$1.error(e);
            }
          }
        }
      }
    };
  }
  if (data.handlers[type2].length === 1) {
    if (elem.addEventListener) {
      var options = false;
      if (supportsPassive() && passiveEvents.indexOf(type2) > -1) {
        options = {
          passive: true
        };
      }
      elem.addEventListener(type2, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent("on" + type2, data.dispatcher);
    }
  }
}
function off(elem, type2, fn) {
  if (!DomData.has(elem)) {
    return;
  }
  var data = DomData.get(elem);
  if (!data.handlers) {
    return;
  }
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(off, elem, type2, fn);
  }
  var removeType = function removeType2(el, t3) {
    data.handlers[t3] = [];
    _cleanUpEvents(el, t3);
  };
  if (type2 === void 0) {
    for (var t2 in data.handlers) {
      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t2)) {
        removeType(elem, t2);
      }
    }
    return;
  }
  var handlers = data.handlers[type2];
  if (!handlers) {
    return;
  }
  if (!fn) {
    removeType(elem, type2);
    return;
  }
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }
  _cleanUpEvents(elem, type2);
}
function trigger(elem, event, hash) {
  var elemData = DomData.has(elem) ? DomData.get(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  if (typeof event === "string") {
    event = {
      type: event,
      target: elem
    };
  } else if (!event.target) {
    event.target = elem;
  }
  event = fixEvent(event);
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash);
  }
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger.call(null, parent, event, hash);
  } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
    if (!DomData.has(event.target)) {
      DomData.set(event.target, {});
    }
    var targetData = DomData.get(event.target);
    if (event.target[event.type]) {
      targetData.disabled = true;
      if (typeof event.target[event.type] === "function") {
        event.target[event.type]();
      }
      targetData.disabled = false;
    }
  }
  return !event.defaultPrevented;
}
function one(elem, type2, fn) {
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(one, elem, type2, fn);
  }
  var func = function func2() {
    off(elem, type2, func2);
    fn.apply(this, arguments);
  };
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type2, func);
}
function any(elem, type2, fn) {
  var func = function func2() {
    off(elem, type2, func2);
    fn.apply(this, arguments);
  };
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type2, func);
}
var Events = Object.freeze({
  __proto__: null,
  fixEvent,
  on,
  off,
  trigger,
  one,
  any
});
var UPDATE_REFRESH_INTERVAL = 30;
var bind = function bind2(context, fn, uid) {
  if (!fn.guid) {
    fn.guid = newGUID();
  }
  var bound = fn.bind(context);
  bound.guid = uid ? uid + "_" + fn.guid : fn.guid;
  return bound;
};
var throttle = function throttle2(fn, wait) {
  var last = import_window6.default.performance.now();
  var throttled = function throttled2() {
    var now = import_window6.default.performance.now();
    if (now - last >= wait) {
      fn.apply(void 0, arguments);
      last = now;
    }
  };
  return throttled;
};
var debounce = function debounce2(func, wait, immediate, context) {
  if (context === void 0) {
    context = import_window6.default;
  }
  var timeout;
  var cancel = function cancel2() {
    context.clearTimeout(timeout);
    timeout = null;
  };
  var debounced = function debounced2() {
    var self2 = this;
    var args = arguments;
    var _later = function later() {
      timeout = null;
      _later = null;
      if (!immediate) {
        func.apply(self2, args);
      }
    };
    if (!timeout && immediate) {
      func.apply(self2, args);
    }
    context.clearTimeout(timeout);
    timeout = context.setTimeout(_later, wait);
  };
  debounced.cancel = cancel;
  return debounced;
};
var EventTarget$2 = function EventTarget() {
};
EventTarget$2.prototype.allowedEvents_ = {};
EventTarget$2.prototype.on = function(type2, fn) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  on(this, type2, fn);
  this.addEventListener = ael;
};
EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;
EventTarget$2.prototype.off = function(type2, fn) {
  off(this, type2, fn);
};
EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;
EventTarget$2.prototype.one = function(type2, fn) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  one(this, type2, fn);
  this.addEventListener = ael;
};
EventTarget$2.prototype.any = function(type2, fn) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  any(this, type2, fn);
  this.addEventListener = ael;
};
EventTarget$2.prototype.trigger = function(event) {
  var type2 = event.type || event;
  if (typeof event === "string") {
    event = {
      type: type2
    };
  }
  event = fixEvent(event);
  if (this.allowedEvents_[type2] && this["on" + type2]) {
    this["on" + type2](event);
  }
  trigger(this, event);
};
EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;
var EVENT_MAP;
EventTarget$2.prototype.queueTrigger = function(event) {
  var _this = this;
  if (!EVENT_MAP) {
    EVENT_MAP = /* @__PURE__ */ new Map();
  }
  var type2 = event.type || event;
  var map = EVENT_MAP.get(this);
  if (!map) {
    map = /* @__PURE__ */ new Map();
    EVENT_MAP.set(this, map);
  }
  var oldTimeout = map.get(type2);
  map["delete"](type2);
  import_window6.default.clearTimeout(oldTimeout);
  var timeout = import_window6.default.setTimeout(function() {
    map["delete"](type2);
    if (map.size === 0) {
      map = null;
      EVENT_MAP["delete"](_this);
    }
    _this.trigger(event);
  }, 0);
  map.set(type2, timeout);
};
var objName = function objName2(obj) {
  if (typeof obj.name === "function") {
    return obj.name();
  }
  if (typeof obj.name === "string") {
    return obj.name;
  }
  if (obj.name_) {
    return obj.name_;
  }
  if (obj.constructor && obj.constructor.name) {
    return obj.constructor.name;
  }
  return typeof obj;
};
var isEvented = function isEvented2(object) {
  return object instanceof EventTarget$2 || !!object.eventBusEl_ && ["on", "one", "off", "trigger"].every(function(k2) {
    return typeof object[k2] === "function";
  });
};
var addEventedCallback = function addEventedCallback2(target, callback2) {
  if (isEvented(target)) {
    callback2();
  } else {
    if (!target.eventedCallbacks) {
      target.eventedCallbacks = [];
    }
    target.eventedCallbacks.push(callback2);
  }
};
var isValidEventType = function isValidEventType2(type2) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type2 === "string" && /\S/.test(type2) || Array.isArray(type2) && !!type2.length
  );
};
var validateTarget = function validateTarget2(target, obj, fnName) {
  if (!target || !target.nodeName && !isEvented(target)) {
    throw new Error("Invalid target for " + objName(obj) + "#" + fnName + "; must be a DOM node or evented object.");
  }
};
var validateEventType = function validateEventType2(type2, obj, fnName) {
  if (!isValidEventType(type2)) {
    throw new Error("Invalid event type for " + objName(obj) + "#" + fnName + "; must be a non-empty string or array.");
  }
};
var validateListener = function validateListener2(listener, obj, fnName) {
  if (typeof listener !== "function") {
    throw new Error("Invalid listener for " + objName(obj) + "#" + fnName + "; must be a function.");
  }
};
var normalizeListenArgs = function normalizeListenArgs2(self2, args, fnName) {
  var isTargetingSelf = args.length < 3 || args[0] === self2 || args[0] === self2.eventBusEl_;
  var target;
  var type2;
  var listener;
  if (isTargetingSelf) {
    target = self2.eventBusEl_;
    if (args.length >= 3) {
      args.shift();
    }
    type2 = args[0];
    listener = args[1];
  } else {
    target = args[0];
    type2 = args[1];
    listener = args[2];
  }
  validateTarget(target, self2, fnName);
  validateEventType(type2, self2, fnName);
  validateListener(listener, self2, fnName);
  listener = bind(self2, listener);
  return {
    isTargetingSelf,
    target,
    type: type2,
    listener
  };
};
var listen = function listen2(target, method, type2, listener) {
  validateTarget(target, target, method);
  if (target.nodeName) {
    Events[method](target, type2, listener);
  } else {
    target[method](type2, listener);
  }
};
var EventedMixin = {
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function on2() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var _normalizeListenArgs = normalizeListenArgs(this, args, "on"), isTargetingSelf = _normalizeListenArgs.isTargetingSelf, target = _normalizeListenArgs.target, type2 = _normalizeListenArgs.type, listener = _normalizeListenArgs.listener;
    listen(target, "on", type2, listener);
    if (!isTargetingSelf) {
      var removeListenerOnDispose = function removeListenerOnDispose2() {
        return _this.off(target, type2, listener);
      };
      removeListenerOnDispose.guid = listener.guid;
      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose2() {
        return _this.off("dispose", removeListenerOnDispose);
      };
      removeRemoverOnTargetDispose.guid = listener.guid;
      listen(this, "on", "dispose", removeListenerOnDispose);
      listen(target, "on", "dispose", removeRemoverOnTargetDispose);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function one2() {
    var _this2 = this;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var _normalizeListenArgs2 = normalizeListenArgs(this, args, "one"), isTargetingSelf = _normalizeListenArgs2.isTargetingSelf, target = _normalizeListenArgs2.target, type2 = _normalizeListenArgs2.type, listener = _normalizeListenArgs2.listener;
    if (isTargetingSelf) {
      listen(target, "one", type2, listener);
    } else {
      var wrapper = function wrapper2() {
        _this2.off(target, type2, wrapper2);
        for (var _len3 = arguments.length, largs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          largs[_key3] = arguments[_key3];
        }
        listener.apply(null, largs);
      };
      wrapper.guid = listener.guid;
      listen(target, "one", type2, wrapper);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once for the first event that is triggered
   * then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  any: function any2() {
    var _this3 = this;
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    var _normalizeListenArgs3 = normalizeListenArgs(this, args, "any"), isTargetingSelf = _normalizeListenArgs3.isTargetingSelf, target = _normalizeListenArgs3.target, type2 = _normalizeListenArgs3.type, listener = _normalizeListenArgs3.listener;
    if (isTargetingSelf) {
      listen(target, "any", type2, listener);
    } else {
      var wrapper = function wrapper2() {
        _this3.off(target, type2, wrapper2);
        for (var _len5 = arguments.length, largs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          largs[_key5] = arguments[_key5];
        }
        listener.apply(null, largs);
      };
      wrapper.guid = listener.guid;
      listen(target, "any", type2, wrapper);
    }
  },
  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function off$1(targetOrType, typeOrListener, listener) {
    if (!targetOrType || isValidEventType(targetOrType)) {
      off(this.eventBusEl_, targetOrType, typeOrListener);
    } else {
      var target = targetOrType;
      var type2 = typeOrListener;
      validateTarget(target, this, "off");
      validateEventType(type2, this, "off");
      validateListener(listener, this, "off");
      listener = bind(this, listener);
      this.off("dispose", listener);
      if (target.nodeName) {
        off(target, type2, listener);
        off(target, "dispose", listener);
      } else if (isEvented(target)) {
        target.off(type2, listener);
        target.off("dispose", listener);
      }
    }
  },
  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function trigger$1(event, hash) {
    validateTarget(this.eventBusEl_, this, "trigger");
    var type2 = event && typeof event !== "string" ? event.type : event;
    if (!isValidEventType(type2)) {
      var error = "Invalid event type for " + objName(this) + "#trigger; must be a non-empty string or object with a type key that has a non-empty value.";
      if (event) {
        (this.log || log$1).error(error);
      } else {
        throw new Error(error);
      }
    }
    return trigger(this.eventBusEl_, event, hash);
  }
};
function evented(target, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, eventBusKey = _options.eventBusKey;
  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl("span", {
      className: "vjs-event-bus"
    });
  }
  assign(target, EventedMixin);
  if (target.eventedCallbacks) {
    target.eventedCallbacks.forEach(function(callback2) {
      callback2();
    });
  }
  target.on("dispose", function() {
    target.off();
    [target, target.el_, target.eventBusEl_].forEach(function(val) {
      if (val && DomData.has(val)) {
        DomData["delete"](val);
      }
    });
    import_window6.default.setTimeout(function() {
      target.eventBusEl_ = null;
    }, 0);
  });
  return target;
}
var StatefulMixin = {
  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},
  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @return {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function setState(stateUpdates) {
    var _this = this;
    if (typeof stateUpdates === "function") {
      stateUpdates = stateUpdates();
    }
    var changes;
    each(stateUpdates, function(value, key) {
      if (_this.state[key] !== value) {
        changes = changes || {};
        changes[key] = {
          from: _this.state[key],
          to: value
        };
      }
      _this.state[key] = value;
    });
    if (changes && isEvented(this)) {
      this.trigger({
        changes,
        type: "statechanged"
      });
    }
    return changes;
  }
};
function stateful(target, defaultState) {
  assign(target, StatefulMixin);
  target.state = assign({}, target.state, defaultState);
  if (typeof target.handleStateChanged === "function" && isEvented(target)) {
    target.on("statechanged", target.handleStateChanged);
  }
  return target;
}
var toLowerCase = function toLowerCase2(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w2) {
    return w2.toLowerCase();
  });
};
var toTitleCase$1 = function toTitleCase(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w2) {
    return w2.toUpperCase();
  });
};
var titleCaseEquals = function titleCaseEquals2(str1, str2) {
  return toTitleCase$1(str1) === toTitleCase$1(str2);
};
function mergeOptions$3() {
  var result = {};
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    each(source, function(value, key) {
      if (!isPlain(value)) {
        result[key] = value;
        return;
      }
      if (!isPlain(result[key])) {
        result[key] = {};
      }
      result[key] = mergeOptions$3(result[key], value);
    });
  });
  return result;
}
var MapSham = function() {
  function MapSham2() {
    this.map_ = {};
  }
  var _proto = MapSham2.prototype;
  _proto.has = function has(key) {
    return key in this.map_;
  };
  _proto["delete"] = function _delete(key) {
    var has = this.has(key);
    delete this.map_[key];
    return has;
  };
  _proto.set = function set4(key, value) {
    this.map_[key] = value;
    return this;
  };
  _proto.forEach = function forEach(callback2, thisArg) {
    for (var key in this.map_) {
      callback2.call(thisArg, this.map_[key], key, this);
    }
  };
  return MapSham2;
}();
var Map$1 = import_window6.default.Map ? import_window6.default.Map : MapSham;
var SetSham = function() {
  function SetSham2() {
    this.set_ = {};
  }
  var _proto = SetSham2.prototype;
  _proto.has = function has(key) {
    return key in this.set_;
  };
  _proto["delete"] = function _delete(key) {
    var has = this.has(key);
    delete this.set_[key];
    return has;
  };
  _proto.add = function add(key) {
    this.set_[key] = 1;
    return this;
  };
  _proto.forEach = function forEach(callback2, thisArg) {
    for (var key in this.set_) {
      callback2.call(thisArg, key, key, this);
    }
  };
  return SetSham2;
}();
var Set$1 = import_window6.default.Set ? import_window6.default.Set : SetSham;
var Component$1 = function() {
  function Component2(player, options, ready) {
    var _this = this;
    if (!player && this.play) {
      this.player_ = player = this;
    } else {
      this.player_ = player;
    }
    this.isDisposed_ = false;
    this.parentComponent_ = null;
    this.options_ = mergeOptions$3({}, this.options_);
    options = this.options_ = mergeOptions$3(this.options_, options);
    this.id_ = options.id || options.el && options.el.id;
    if (!this.id_) {
      var id = player && player.id && player.id() || "no_player";
      this.id_ = id + "_component_" + newGUID();
    }
    this.name_ = options.name || null;
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }
    if (options.className && this.el_) {
      options.className.split(" ").forEach(function(c) {
        return _this.addClass(c);
      });
    }
    if (options.evented !== false) {
      evented(this, {
        eventBusKey: this.el_ ? "el_" : null
      });
      this.handleLanguagechange = this.handleLanguagechange.bind(this);
      this.on(this.player_, "languagechange", this.handleLanguagechange);
    }
    stateful(this, this.constructor.defaultState);
    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};
    this.setTimeoutIds_ = new Set$1();
    this.setIntervalIds_ = new Set$1();
    this.rafIds_ = new Set$1();
    this.namedRafs_ = new Map$1();
    this.clearingTimersOnDispose_ = false;
    if (options.initChildren !== false) {
      this.initChildren();
    }
    this.ready(ready);
    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }
  var _proto = Component2.prototype;
  _proto.dispose = function dispose(options) {
    if (options === void 0) {
      options = {};
    }
    if (this.isDisposed_) {
      return;
    }
    if (this.readyQueue_) {
      this.readyQueue_.length = 0;
    }
    this.trigger({
      type: "dispose",
      bubbles: false
    });
    this.isDisposed_ = true;
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;
    this.parentComponent_ = null;
    if (this.el_) {
      if (this.el_.parentNode) {
        if (options.restoreEl) {
          this.el_.parentNode.replaceChild(options.restoreEl, this.el_);
        } else {
          this.el_.parentNode.removeChild(this.el_);
        }
      }
      this.el_ = null;
    }
    this.player_ = null;
  };
  _proto.isDisposed = function isDisposed() {
    return Boolean(this.isDisposed_);
  };
  _proto.player = function player() {
    return this.player_;
  };
  _proto.options = function options(obj) {
    if (!obj) {
      return this.options_;
    }
    this.options_ = mergeOptions$3(this.options_, obj);
    return this.options_;
  };
  _proto.el = function el() {
    return this.el_;
  };
  _proto.createEl = function createEl$1(tagName, properties, attributes) {
    return createEl(tagName, properties, attributes);
  };
  _proto.localize = function localize(string, tokens, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = string;
    }
    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();
    var language = languages && languages[code];
    var primaryCode = code && code.split("-")[0];
    var primaryLang = languages && languages[primaryCode];
    var localizedString = defaultValue;
    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }
    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function(match, index) {
        var value = tokens[index - 1];
        var ret = value;
        if (typeof value === "undefined") {
          ret = match;
        }
        return ret;
      });
    }
    return localizedString;
  };
  _proto.handleLanguagechange = function handleLanguagechange() {
  };
  _proto.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };
  _proto.id = function id() {
    return this.id_;
  };
  _proto.name = function name() {
    return this.name_;
  };
  _proto.children = function children() {
    return this.children_;
  };
  _proto.getChildById = function getChildById(id) {
    return this.childIndex_[id];
  };
  _proto.getChild = function getChild(name) {
    if (!name) {
      return;
    }
    return this.childNameIndex_[name];
  };
  _proto.getDescendant = function getDescendant() {
    for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
      names[_key] = arguments[_key];
    }
    names = names.reduce(function(acc, n) {
      return acc.concat(n);
    }, []);
    var currentChild = this;
    for (var i = 0; i < names.length; i++) {
      currentChild = currentChild.getChild(names[i]);
      if (!currentChild || !currentChild.getChild) {
        return;
      }
    }
    return currentChild;
  };
  _proto.addChild = function addChild(child, options, index) {
    if (options === void 0) {
      options = {};
    }
    if (index === void 0) {
      index = this.children_.length;
    }
    var component;
    var componentName;
    if (typeof child === "string") {
      componentName = toTitleCase$1(child);
      var componentClassName = options.componentClass || componentName;
      options.name = componentName;
      var ComponentClass = Component2.getComponent(componentClassName);
      if (!ComponentClass) {
        throw new Error("Component " + componentClassName + " does not exist");
      }
      if (typeof ComponentClass !== "function") {
        return null;
      }
      component = new ComponentClass(this.player_ || this, options);
    } else {
      component = child;
    }
    if (component.parentComponent_) {
      component.parentComponent_.removeChild(component);
    }
    this.children_.splice(index, 0, component);
    component.parentComponent_ = this;
    if (typeof component.id === "function") {
      this.childIndex_[component.id()] = component;
    }
    componentName = componentName || component.name && toTitleCase$1(component.name());
    if (componentName) {
      this.childNameIndex_[componentName] = component;
      this.childNameIndex_[toLowerCase(componentName)] = component;
    }
    if (typeof component.el === "function" && component.el()) {
      var refNode = null;
      if (this.children_[index + 1]) {
        if (this.children_[index + 1].el_) {
          refNode = this.children_[index + 1].el_;
        } else if (isEl(this.children_[index + 1])) {
          refNode = this.children_[index + 1];
        }
      }
      this.contentEl().insertBefore(component.el(), refNode);
    }
    return component;
  };
  _proto.removeChild = function removeChild(component) {
    if (typeof component === "string") {
      component = this.getChild(component);
    }
    if (!component || !this.children_) {
      return;
    }
    var childFound = false;
    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }
    if (!childFound) {
      return;
    }
    component.parentComponent_ = null;
    this.childIndex_[component.id()] = null;
    this.childNameIndex_[toTitleCase$1(component.name())] = null;
    this.childNameIndex_[toLowerCase(component.name())] = null;
    var compEl = component.el();
    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };
  _proto.initChildren = function initChildren() {
    var _this2 = this;
    var children = this.options_.children;
    if (children) {
      var parentOptions = this.options_;
      var handleAdd = function handleAdd2(child) {
        var name = child.name;
        var opts = child.opts;
        if (parentOptions[name] !== void 0) {
          opts = parentOptions[name];
        }
        if (opts === false) {
          return;
        }
        if (opts === true) {
          opts = {};
        }
        opts.playerOptions = _this2.options_.playerOptions;
        var newChild = _this2.addChild(name, opts);
        if (newChild) {
          _this2[name] = newChild;
        }
      };
      var workingChildren;
      var Tech2 = Component2.getComponent("Tech");
      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }
      workingChildren.concat(Object.keys(this.options_).filter(function(child) {
        return !workingChildren.some(function(wchild) {
          if (typeof wchild === "string") {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map(function(child) {
        var name;
        var opts;
        if (typeof child === "string") {
          name = child;
          opts = children[name] || _this2.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }
        return {
          name,
          opts
        };
      }).filter(function(child) {
        var c = Component2.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
        return c && !Tech2.isTech(c);
      }).forEach(handleAdd);
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "";
  };
  _proto.ready = function ready(fn, sync) {
    if (sync === void 0) {
      sync = false;
    }
    if (!fn) {
      return;
    }
    if (!this.isReady_) {
      this.readyQueue_ = this.readyQueue_ || [];
      this.readyQueue_.push(fn);
      return;
    }
    if (sync) {
      fn.call(this);
    } else {
      this.setTimeout(fn, 1);
    }
  };
  _proto.triggerReady = function triggerReady() {
    this.isReady_ = true;
    this.setTimeout(function() {
      var readyQueue = this.readyQueue_;
      this.readyQueue_ = [];
      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function(fn) {
          fn.call(this);
        }, this);
      }
      this.trigger("ready");
    }, 1);
  };
  _proto.$ = function $$1(selector, context) {
    return $(selector, context || this.contentEl());
  };
  _proto.$$ = function $$$1(selector, context) {
    return $$(selector, context || this.contentEl());
  };
  _proto.hasClass = function hasClass$1(classToCheck) {
    return hasClass(this.el_, classToCheck);
  };
  _proto.addClass = function addClass$1(classToAdd) {
    addClass(this.el_, classToAdd);
  };
  _proto.removeClass = function removeClass$1(classToRemove) {
    removeClass(this.el_, classToRemove);
  };
  _proto.toggleClass = function toggleClass$1(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  };
  _proto.show = function show() {
    this.removeClass("vjs-hidden");
  };
  _proto.hide = function hide() {
    this.addClass("vjs-hidden");
  };
  _proto.lockShowing = function lockShowing() {
    this.addClass("vjs-lock-showing");
  };
  _proto.unlockShowing = function unlockShowing() {
    this.removeClass("vjs-lock-showing");
  };
  _proto.getAttribute = function getAttribute$1(attribute) {
    return getAttribute(this.el_, attribute);
  };
  _proto.setAttribute = function setAttribute$1(attribute, value) {
    setAttribute(this.el_, attribute, value);
  };
  _proto.removeAttribute = function removeAttribute$1(attribute) {
    removeAttribute(this.el_, attribute);
  };
  _proto.width = function width2(num, skipListeners) {
    return this.dimension("width", num, skipListeners);
  };
  _proto.height = function height2(num, skipListeners) {
    return this.dimension("height", num, skipListeners);
  };
  _proto.dimensions = function dimensions(width2, height2) {
    this.width(width2, true);
    this.height(height2);
  };
  _proto.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== void 0) {
      if (num === null || num !== num) {
        num = 0;
      }
      if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === "auto") {
        this.el_.style[widthOrHeight] = "";
      } else {
        this.el_.style[widthOrHeight] = num + "px";
      }
      if (!skipListeners) {
        this.trigger("componentresize");
      }
      return;
    }
    if (!this.el_) {
      return 0;
    }
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf("px");
    if (pxIndex !== -1) {
      return parseInt(val.slice(0, pxIndex), 10);
    }
    return parseInt(this.el_["offset" + toTitleCase$1(widthOrHeight)], 10);
  };
  _proto.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;
    if (widthOrHeight !== "width" && widthOrHeight !== "height") {
      throw new Error("currentDimension only accepts width or height value");
    }
    computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);
    if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
      var rule = "offset" + toTitleCase$1(widthOrHeight);
      computedWidthOrHeight = this.el_[rule];
    }
    return computedWidthOrHeight;
  };
  _proto.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension("width"),
      height: this.currentDimension("height")
    };
  };
  _proto.currentWidth = function currentWidth() {
    return this.currentDimension("width");
  };
  _proto.currentHeight = function currentHeight() {
    return this.currentDimension("height");
  };
  _proto.focus = function focus() {
    this.el_.focus();
  };
  _proto.blur = function blur() {
    this.el_.blur();
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (this.player_) {
      if (!import_keycode.default.isEventKey(event, "Tab")) {
        event.stopPropagation();
      }
      this.player_.handleKeyDown(event);
    }
  };
  _proto.handleKeyPress = function handleKeyPress(event) {
    this.handleKeyDown(event);
  };
  _proto.emitTapEvents = function emitTapEvents() {
    var touchStart = 0;
    var firstTouch = null;
    var tapMovementThreshold = 10;
    var touchTimeThreshold = 200;
    var couldBeTap;
    this.on("touchstart", function(event) {
      if (event.touches.length === 1) {
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        touchStart = import_window6.default.performance.now();
        couldBeTap = true;
      }
    });
    this.on("touchmove", function(event) {
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });
    var noTap = function noTap2() {
      couldBeTap = false;
    };
    this.on("touchleave", noTap);
    this.on("touchcancel", noTap);
    this.on("touchend", function(event) {
      firstTouch = null;
      if (couldBeTap === true) {
        var touchTime = import_window6.default.performance.now() - touchStart;
        if (touchTime < touchTimeThreshold) {
          event.preventDefault();
          this.trigger("tap");
        }
      }
    });
  };
  _proto.enableTouchActivity = function enableTouchActivity() {
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }
    var report = bind(this.player(), this.player().reportUserActivity);
    var touchHolding;
    this.on("touchstart", function() {
      report();
      this.clearInterval(touchHolding);
      touchHolding = this.setInterval(report, 250);
    });
    var touchEnd = function touchEnd2(event) {
      report();
      this.clearInterval(touchHolding);
    };
    this.on("touchmove", report);
    this.on("touchend", touchEnd);
    this.on("touchcancel", touchEnd);
  };
  _proto.setTimeout = function setTimeout2(fn, timeout) {
    var _this3 = this;
    var timeoutId;
    fn = bind(this, fn);
    this.clearTimersOnDispose_();
    timeoutId = import_window6.default.setTimeout(function() {
      if (_this3.setTimeoutIds_.has(timeoutId)) {
        _this3.setTimeoutIds_["delete"](timeoutId);
      }
      fn();
    }, timeout);
    this.setTimeoutIds_.add(timeoutId);
    return timeoutId;
  };
  _proto.clearTimeout = function clearTimeout2(timeoutId) {
    if (this.setTimeoutIds_.has(timeoutId)) {
      this.setTimeoutIds_["delete"](timeoutId);
      import_window6.default.clearTimeout(timeoutId);
    }
    return timeoutId;
  };
  _proto.setInterval = function setInterval(fn, interval) {
    fn = bind(this, fn);
    this.clearTimersOnDispose_();
    var intervalId = import_window6.default.setInterval(fn, interval);
    this.setIntervalIds_.add(intervalId);
    return intervalId;
  };
  _proto.clearInterval = function clearInterval(intervalId) {
    if (this.setIntervalIds_.has(intervalId)) {
      this.setIntervalIds_["delete"](intervalId);
      import_window6.default.clearInterval(intervalId);
    }
    return intervalId;
  };
  _proto.requestAnimationFrame = function requestAnimationFrame(fn) {
    var _this4 = this;
    if (!this.supportsRaf_) {
      return this.setTimeout(fn, 1e3 / 60);
    }
    this.clearTimersOnDispose_();
    var id;
    fn = bind(this, fn);
    id = import_window6.default.requestAnimationFrame(function() {
      if (_this4.rafIds_.has(id)) {
        _this4.rafIds_["delete"](id);
      }
      fn();
    });
    this.rafIds_.add(id);
    return id;
  };
  _proto.requestNamedAnimationFrame = function requestNamedAnimationFrame(name, fn) {
    var _this5 = this;
    if (this.namedRafs_.has(name)) {
      return;
    }
    this.clearTimersOnDispose_();
    fn = bind(this, fn);
    var id = this.requestAnimationFrame(function() {
      fn();
      if (_this5.namedRafs_.has(name)) {
        _this5.namedRafs_["delete"](name);
      }
    });
    this.namedRafs_.set(name, id);
    return name;
  };
  _proto.cancelNamedAnimationFrame = function cancelNamedAnimationFrame(name) {
    if (!this.namedRafs_.has(name)) {
      return;
    }
    this.cancelAnimationFrame(this.namedRafs_.get(name));
    this.namedRafs_["delete"](name);
  };
  _proto.cancelAnimationFrame = function cancelAnimationFrame(id) {
    if (!this.supportsRaf_) {
      return this.clearTimeout(id);
    }
    if (this.rafIds_.has(id)) {
      this.rafIds_["delete"](id);
      import_window6.default.cancelAnimationFrame(id);
    }
    return id;
  };
  _proto.clearTimersOnDispose_ = function clearTimersOnDispose_() {
    var _this6 = this;
    if (this.clearingTimersOnDispose_) {
      return;
    }
    this.clearingTimersOnDispose_ = true;
    this.one("dispose", function() {
      [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(function(_ref) {
        var idName = _ref[0], cancelName = _ref[1];
        _this6[idName].forEach(function(val, key) {
          return _this6[cancelName](key);
        });
      });
      _this6.clearingTimersOnDispose_ = false;
    });
  };
  Component2.registerComponent = function registerComponent(name, ComponentToRegister) {
    if (typeof name !== "string" || !name) {
      throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
    }
    var Tech2 = Component2.getComponent("Tech");
    var isTech = Tech2 && Tech2.isTech(ComponentToRegister);
    var isComp = Component2 === ComponentToRegister || Component2.prototype.isPrototypeOf(ComponentToRegister.prototype);
    if (isTech || !isComp) {
      var reason;
      if (isTech) {
        reason = "techs must be registered using Tech.registerTech()";
      } else {
        reason = "must be a Component subclass";
      }
      throw new Error('Illegal component, "' + name + '"; ' + reason + ".");
    }
    name = toTitleCase$1(name);
    if (!Component2.components_) {
      Component2.components_ = {};
    }
    var Player2 = Component2.getComponent("Player");
    if (name === "Player" && Player2 && Player2.players) {
      var players = Player2.players;
      var playerNames = Object.keys(players);
      if (players && playerNames.length > 0 && playerNames.map(function(pname) {
        return players[pname];
      }).every(Boolean)) {
        throw new Error("Can not register Player component after player has been created.");
      }
    }
    Component2.components_[name] = ComponentToRegister;
    Component2.components_[toLowerCase(name)] = ComponentToRegister;
    return ComponentToRegister;
  };
  Component2.getComponent = function getComponent(name) {
    if (!name || !Component2.components_) {
      return;
    }
    return Component2.components_[name];
  };
  return Component2;
}();
Component$1.prototype.supportsRaf_ = typeof import_window6.default.requestAnimationFrame === "function" && typeof import_window6.default.cancelAnimationFrame === "function";
Component$1.registerComponent("Component", Component$1);
function rangeCheck(fnName, index, maxIndex) {
  if (typeof index !== "number" || index < 0 || index > maxIndex) {
    throw new Error("Failed to execute '" + fnName + "' on 'TimeRanges': The index provided (" + index + ") is non-numeric or out of bounds (0-" + maxIndex + ").");
  }
}
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}
function createTimeRangesObj(ranges) {
  var timeRangesObj;
  if (ranges === void 0 || ranges.length === 0) {
    timeRangesObj = {
      length: 0,
      start: function start2() {
        throw new Error("This TimeRanges object is empty");
      },
      end: function end() {
        throw new Error("This TimeRanges object is empty");
      }
    };
  } else {
    timeRangesObj = {
      length: ranges.length,
      start: getRange.bind(null, "start", 0, ranges),
      end: getRange.bind(null, "end", 1, ranges)
    };
  }
  if (import_window6.default.Symbol && import_window6.default.Symbol.iterator) {
    timeRangesObj[import_window6.default.Symbol.iterator] = function() {
      return (ranges || []).values();
    };
  }
  return timeRangesObj;
}
function createTimeRanges(start2, end) {
  if (Array.isArray(start2)) {
    return createTimeRangesObj(start2);
  } else if (start2 === void 0 || end === void 0) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start2, end]]);
}
function bufferedPercent(buffered, duration5) {
  var bufferedDuration = 0;
  var start2;
  var end;
  if (!duration5) {
    return 0;
  }
  if (!buffered || !buffered.length) {
    buffered = createTimeRanges(0, 0);
  }
  for (var i = 0; i < buffered.length; i++) {
    start2 = buffered.start(i);
    end = buffered.end(i);
    if (end > duration5) {
      end = duration5;
    }
    bufferedDuration += end - start2;
  }
  return bufferedDuration / duration5;
}
function MediaError(value) {
  if (value instanceof MediaError) {
    return value;
  }
  if (typeof value === "number") {
    this.code = value;
  } else if (typeof value === "string") {
    this.message = value;
  } else if (isObject3(value)) {
    if (typeof value.code === "number") {
      this.code = value.code;
    }
    assign(this, value);
  }
  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || "";
  }
}
MediaError.prototype.code = 0;
MediaError.prototype.message = "";
MediaError.prototype.status = null;
MediaError.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
MediaError.defaultMessages = {
  1: "You aborted the media playback",
  2: "A network error caused the media download to fail part-way.",
  3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
  5: "The media is encrypted and we do not have the keys to decrypt it."
};
for (errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}
var errNum;
function isPromise(value) {
  return value !== void 0 && value !== null && typeof value.then === "function";
}
function silencePromise(value) {
  if (isPromise(value)) {
    value.then(null, function(e) {
    });
  }
}
var trackToJson_ = function trackToJson_2(track) {
  var ret = ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce(function(acc, prop, i) {
    if (track[prop]) {
      acc[prop] = track[prop];
    }
    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function(cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });
  return ret;
};
var textTracksToJson = function textTracksToJson2(tech) {
  var trackEls = tech.$$("track");
  var trackObjs = Array.prototype.map.call(trackEls, function(t2) {
    return t2.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function(trackEl) {
    var json = trackToJson_(trackEl.track);
    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });
  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function(track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};
var jsonToTextTracks = function jsonToTextTracks2(json, tech) {
  json.forEach(function(track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;
    if (!track.src && track.cues) {
      track.cues.forEach(function(cue) {
        return addedTrack.addCue(cue);
      });
    }
  });
  return tech.textTracks();
};
var textTrackConverter = {
  textTracksToJson,
  jsonToTextTracks,
  trackToJson_
};
var MODAL_CLASS_NAME = "vjs-modal-dialog";
var ModalDialog = function(_Component) {
  _inheritsLoose(ModalDialog2, _Component);
  function ModalDialog2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleKeyDown_ = function(e) {
      return _this.handleKeyDown(e);
    };
    _this.close_ = function(e) {
      return _this.close(e);
    };
    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;
    _this.closeable(!_this.options_.uncloseable);
    _this.content(_this.options_.content);
    _this.contentEl_ = createEl("div", {
      className: MODAL_CLASS_NAME + "-content"
    }, {
      role: "document"
    });
    _this.descEl_ = createEl("p", {
      className: MODAL_CLASS_NAME + "-description vjs-control-text",
      id: _this.el().getAttribute("aria-describedby")
    });
    textContent(_this.descEl_, _this.description());
    _this.el_.appendChild(_this.descEl_);
    _this.el_.appendChild(_this.contentEl_);
    return _this;
  }
  var _proto = ModalDialog2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      "aria-describedby": this.id() + "_description",
      "aria-hidden": "true",
      "aria-label": this.label(),
      "role": "dialog"
    });
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.descEl_ = null;
    this.previouslyActiveEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + " vjs-hidden " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.label = function label() {
    return this.localize(this.options_.label || "Modal Window");
  };
  _proto.description = function description() {
    var desc = this.options_.description || this.localize("This is a modal window.");
    if (this.closeable()) {
      desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
    }
    return desc;
  };
  _proto.open = function open() {
    if (!this.opened_) {
      var player = this.player();
      this.trigger("beforemodalopen");
      this.opened_ = true;
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }
      this.wasPlaying_ = !player.paused();
      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }
      this.on("keydown", this.handleKeyDown_);
      this.hadControls_ = player.controls();
      player.controls(false);
      this.show();
      this.conditionalFocus_();
      this.el().setAttribute("aria-hidden", "false");
      this.trigger("modalopen");
      this.hasBeenOpened_ = true;
    }
  };
  _proto.opened = function opened(value) {
    if (typeof value === "boolean") {
      this[value ? "open" : "close"]();
    }
    return this.opened_;
  };
  _proto.close = function close() {
    if (!this.opened_) {
      return;
    }
    var player = this.player();
    this.trigger("beforemodalclose");
    this.opened_ = false;
    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }
    this.off("keydown", this.handleKeyDown_);
    if (this.hadControls_) {
      player.controls(true);
    }
    this.hide();
    this.el().setAttribute("aria-hidden", "true");
    this.trigger("modalclose");
    this.conditionalBlur_();
    if (this.options_.temporary) {
      this.dispose();
    }
  };
  _proto.closeable = function closeable(value) {
    if (typeof value === "boolean") {
      var closeable2 = this.closeable_ = !!value;
      var close = this.getChild("closeButton");
      if (closeable2 && !close) {
        var temp = this.contentEl_;
        this.contentEl_ = this.el_;
        close = this.addChild("closeButton", {
          controlText: "Close Modal Dialog"
        });
        this.contentEl_ = temp;
        this.on(close, "close", this.close_);
      }
      if (!closeable2 && close) {
        this.off(close, "close", this.close_);
        this.removeChild(close);
        close.dispose();
      }
    }
    return this.closeable_;
  };
  _proto.fill = function fill() {
    this.fillWith(this.content());
  };
  _proto.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;
    this.trigger("beforemodalfill");
    this.hasBeenFilled_ = true;
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    this.trigger("modalfill");
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }
    var closeButton = this.getChild("closeButton");
    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
  };
  _proto.empty = function empty() {
    this.trigger("beforemodalempty");
    emptyEl(this.contentEl());
    this.trigger("modalempty");
  };
  _proto.content = function content(value) {
    if (typeof value !== "undefined") {
      this.content_ = value;
    }
    return this.content_;
  };
  _proto.conditionalFocus_ = function conditionalFocus_() {
    var activeEl = import_document.default.activeElement;
    var playerEl = this.player_.el_;
    this.previouslyActiveEl_ = null;
    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;
      this.focus();
    }
  };
  _proto.conditionalBlur_ = function conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    event.stopPropagation();
    if (import_keycode.default.isEventKey(event, "Escape") && this.closeable()) {
      event.preventDefault();
      this.close();
      return;
    }
    if (!import_keycode.default.isEventKey(event, "Tab")) {
      return;
    }
    var focusableEls = this.focusableEls_();
    var activeEl = this.el_.querySelector(":focus");
    var focusIndex;
    for (var i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }
    if (import_document.default.activeElement === this.el_) {
      focusIndex = 0;
    }
    if (event.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event.preventDefault();
    }
  };
  _proto.focusableEls_ = function focusableEls_() {
    var allChildren = this.el_.querySelectorAll("*");
    return Array.prototype.filter.call(allChildren, function(child) {
      return (child instanceof import_window6.default.HTMLAnchorElement || child instanceof import_window6.default.HTMLAreaElement) && child.hasAttribute("href") || (child instanceof import_window6.default.HTMLInputElement || child instanceof import_window6.default.HTMLSelectElement || child instanceof import_window6.default.HTMLTextAreaElement || child instanceof import_window6.default.HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof import_window6.default.HTMLIFrameElement || child instanceof import_window6.default.HTMLObjectElement || child instanceof import_window6.default.HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable");
    });
  };
  return ModalDialog2;
}(Component$1);
ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};
Component$1.registerComponent("ModalDialog", ModalDialog);
var TrackList = function(_EventTarget) {
  _inheritsLoose(TrackList2, _EventTarget);
  function TrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    _this = _EventTarget.call(this) || this;
    _this.tracks_ = [];
    Object.defineProperty(_assertThisInitialized(_this), "length", {
      get: function get7() {
        return this.tracks_.length;
      }
    });
    for (var i = 0; i < tracks.length; i++) {
      _this.addTrack(tracks[i]);
    }
    return _this;
  }
  var _proto = TrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    var index = this.tracks_.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get: function get7() {
          return this.tracks_[index];
        }
      });
    }
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      this.trigger({
        track,
        type: "addtrack",
        target: this
      });
    }
    track.labelchange_ = function() {
      _this2.trigger({
        track,
        type: "labelchange",
        target: _this2
      });
    };
    if (isEvented(track)) {
      track.addEventListener("labelchange", track.labelchange_);
    }
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    var track;
    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }
        this.tracks_.splice(i, 1);
        break;
      }
    }
    if (!track) {
      return;
    }
    this.trigger({
      track,
      type: "removetrack",
      target: this
    });
  };
  _proto.getTrackById = function getTrackById(id) {
    var result = null;
    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];
      if (track.id === id) {
        result = track;
        break;
      }
    }
    return result;
  };
  return TrackList2;
}(EventTarget$2);
TrackList.prototype.allowedEvents_ = {
  change: "change",
  addtrack: "addtrack",
  removetrack: "removetrack",
  labelchange: "labelchange"
};
for (event in TrackList.prototype.allowedEvents_) {
  TrackList.prototype["on" + event] = null;
}
var event;
var disableOthers$1 = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    list[i].enabled = false;
  }
};
var AudioTrackList = function(_TrackList) {
  _inheritsLoose(AudioTrackList2, _TrackList);
  function AudioTrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }
    _this = _TrackList.call(this, tracks) || this;
    _this.changing_ = false;
    return _this;
  }
  var _proto = AudioTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    if (track.enabled) {
      disableOthers$1(this, track);
    }
    _TrackList.prototype.addTrack.call(this, track);
    if (!track.addEventListener) {
      return;
    }
    track.enabledChange_ = function() {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers$1(_this2, track);
      _this2.changing_ = false;
      _this2.trigger("change");
    };
    track.addEventListener("enabledchange", track.enabledChange_);
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener && rtrack.enabledChange_) {
      rtrack.removeEventListener("enabledchange", rtrack.enabledChange_);
      rtrack.enabledChange_ = null;
    }
  };
  return AudioTrackList2;
}(TrackList);
var disableOthers2 = function disableOthers3(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    list[i].selected = false;
  }
};
var VideoTrackList = function(_TrackList) {
  _inheritsLoose(VideoTrackList2, _TrackList);
  function VideoTrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers2(tracks, tracks[i]);
        break;
      }
    }
    _this = _TrackList.call(this, tracks) || this;
    _this.changing_ = false;
    Object.defineProperty(_assertThisInitialized(_this), "selectedIndex", {
      get: function get7() {
        for (var _i = 0; _i < this.length; _i++) {
          if (this[_i].selected) {
            return _i;
          }
        }
        return -1;
      },
      set: function set4() {
      }
    });
    return _this;
  }
  var _proto = VideoTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    if (track.selected) {
      disableOthers2(this, track);
    }
    _TrackList.prototype.addTrack.call(this, track);
    if (!track.addEventListener) {
      return;
    }
    track.selectedChange_ = function() {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers2(_this2, track);
      _this2.changing_ = false;
      _this2.trigger("change");
    };
    track.addEventListener("selectedchange", track.selectedChange_);
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener && rtrack.selectedChange_) {
      rtrack.removeEventListener("selectedchange", rtrack.selectedChange_);
      rtrack.selectedChange_ = null;
    }
  };
  return VideoTrackList2;
}(TrackList);
var TextTrackList = function(_TrackList) {
  _inheritsLoose(TextTrackList2, _TrackList);
  function TextTrackList2() {
    return _TrackList.apply(this, arguments) || this;
  }
  var _proto = TextTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this = this;
    _TrackList.prototype.addTrack.call(this, track);
    if (!this.queueChange_) {
      this.queueChange_ = function() {
        return _this.queueTrigger("change");
      };
    }
    if (!this.triggerSelectedlanguagechange) {
      this.triggerSelectedlanguagechange_ = function() {
        return _this.trigger("selectedlanguagechange");
      };
    }
    track.addEventListener("modechange", this.queueChange_);
    var nonLanguageTextTrackKind = ["metadata", "chapters"];
    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
    }
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener) {
      if (this.queueChange_) {
        rtrack.removeEventListener("modechange", this.queueChange_);
      }
      if (this.selectedlanguagechange_) {
        rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_);
      }
    }
  };
  return TextTrackList2;
}(TrackList);
var HtmlTrackElementList = function() {
  function HtmlTrackElementList2(trackElements) {
    if (trackElements === void 0) {
      trackElements = [];
    }
    this.trackElements_ = [];
    Object.defineProperty(this, "length", {
      get: function get7() {
        return this.trackElements_.length;
      }
    });
    for (var i = 0, length = trackElements.length; i < length; i++) {
      this.addTrackElement_(trackElements[i]);
    }
  }
  var _proto = HtmlTrackElementList2.prototype;
  _proto.addTrackElement_ = function addTrackElement_(trackElement) {
    var index = this.trackElements_.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get: function get7() {
          return this.trackElements_[index];
        }
      });
    }
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  };
  _proto.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_;
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];
        break;
      }
    }
    return trackElement_;
  };
  _proto.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (trackElement === this.trackElements_[i]) {
        if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === "function") {
          this.trackElements_[i].track.off();
        }
        if (typeof this.trackElements_[i].off === "function") {
          this.trackElements_[i].off();
        }
        this.trackElements_.splice(i, 1);
        break;
      }
    }
  };
  return HtmlTrackElementList2;
}();
var TextTrackCueList = function() {
  function TextTrackCueList2(cues) {
    TextTrackCueList2.prototype.setCues_.call(this, cues);
    Object.defineProperty(this, "length", {
      get: function get7() {
        return this.length_;
      }
    });
  }
  var _proto = TextTrackCueList2.prototype;
  _proto.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l = cues.length;
    this.cues_ = cues;
    this.length_ = cues.length;
    var defineProp = function defineProp2(index) {
      if (!("" + index in this)) {
        Object.defineProperty(this, "" + index, {
          get: function get7() {
            return this.cues_[index];
          }
        });
      }
    };
    if (oldLength < l) {
      i = oldLength;
      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  };
  _proto.getCueById = function getCueById(id) {
    var result = null;
    for (var i = 0, l = this.length; i < l; i++) {
      var cue = this[i];
      if (cue.id === id) {
        result = cue;
        break;
      }
    }
    return result;
  };
  return TextTrackCueList2;
}();
var VideoTrackKind = {
  alternative: "alternative",
  captions: "captions",
  main: "main",
  sign: "sign",
  subtitles: "subtitles",
  commentary: "commentary"
};
var AudioTrackKind = {
  "alternative": "alternative",
  "descriptions": "descriptions",
  "main": "main",
  "main-desc": "main-desc",
  "translation": "translation",
  "commentary": "commentary"
};
var TextTrackKind = {
  subtitles: "subtitles",
  captions: "captions",
  descriptions: "descriptions",
  chapters: "chapters",
  metadata: "metadata"
};
var TextTrackMode = {
  disabled: "disabled",
  hidden: "hidden",
  showing: "showing"
};
var Track = function(_EventTarget) {
  _inheritsLoose(Track2, _EventTarget);
  function Track2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    var trackProps = {
      id: options.id || "vjs_track_" + newGUID(),
      kind: options.kind || "",
      language: options.language || ""
    };
    var label = options.label || "";
    var _loop = function _loop2(key2) {
      Object.defineProperty(_assertThisInitialized(_this), key2, {
        get: function get7() {
          return trackProps[key2];
        },
        set: function set4() {
        }
      });
    };
    for (var key in trackProps) {
      _loop(key);
    }
    Object.defineProperty(_assertThisInitialized(_this), "label", {
      get: function get7() {
        return label;
      },
      set: function set4(newLabel) {
        if (newLabel !== label) {
          label = newLabel;
          this.trigger("labelchange");
        }
      }
    });
    return _this;
  }
  return Track2;
}(EventTarget$2);
var parseUrl = function parseUrl2(url) {
  var props = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"];
  var a = import_document.default.createElement("a");
  a.href = url;
  var details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }
  if (details.protocol === "http:") {
    details.host = details.host.replace(/:80$/, "");
  }
  if (details.protocol === "https:") {
    details.host = details.host.replace(/:443$/, "");
  }
  if (!details.protocol) {
    details.protocol = import_window6.default.location.protocol;
  }
  if (!details.host) {
    details.host = import_window6.default.location.host;
  }
  return details;
};
var getAbsoluteURL = function getAbsoluteURL2(url) {
  if (!url.match(/^https?:\/\//)) {
    var a = import_document.default.createElement("a");
    a.href = url;
    url = a.href;
  }
  return url;
};
var getFileExtension = function getFileExtension2(path) {
  if (typeof path === "string") {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
    var pathParts = splitPathRe.exec(path);
    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }
  return "";
};
var isCrossOrigin = function isCrossOrigin2(url, winLoc) {
  if (winLoc === void 0) {
    winLoc = import_window6.default.location;
  }
  var urlInfo = parseUrl(url);
  var srcProtocol = urlInfo.protocol === ":" ? winLoc.protocol : urlInfo.protocol;
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
  return crossOrigin;
};
var Url = Object.freeze({
  __proto__: null,
  parseUrl,
  getAbsoluteURL,
  getFileExtension,
  isCrossOrigin
});
var parseCues = function parseCues2(srcContent, track) {
  var parser6 = new import_window6.default.WebVTT.Parser(import_window6.default, import_window6.default.vttjs, import_window6.default.WebVTT.StringDecoder());
  var errors2 = [];
  parser6.oncue = function(cue) {
    track.addCue(cue);
  };
  parser6.onparsingerror = function(error) {
    errors2.push(error);
  };
  parser6.onflush = function() {
    track.trigger({
      type: "loadeddata",
      target: track
    });
  };
  parser6.parse(srcContent);
  if (errors2.length > 0) {
    if (import_window6.default.console && import_window6.default.console.groupCollapsed) {
      import_window6.default.console.groupCollapsed("Text Track parsing errors for " + track.src);
    }
    errors2.forEach(function(error) {
      return log$1.error(error);
    });
    if (import_window6.default.console && import_window6.default.console.groupEnd) {
      import_window6.default.console.groupEnd();
    }
  }
  parser6.flush();
};
var loadTrack = function loadTrack2(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = isCrossOrigin(src);
  if (crossOrigin) {
    opts.cors = crossOrigin;
  }
  var withCredentials = track.tech_.crossOrigin() === "use-credentials";
  if (withCredentials) {
    opts.withCredentials = withCredentials;
  }
  (0, import_xhr.default)(opts, bind(this, function(err, response, responseBody) {
    if (err) {
      return log$1.error(err, response);
    }
    track.loaded_ = true;
    if (typeof import_window6.default.WebVTT !== "function") {
      if (track.tech_) {
        track.tech_.any(["vttjsloaded", "vttjserror"], function(event) {
          if (event.type === "vttjserror") {
            log$1.error("vttjs failed to load, stopping trying to process " + track.src);
            return;
          }
          return parseCues(responseBody, track);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};
var TextTrack = function(_Track) {
  _inheritsLoose(TextTrack2, _Track);
  function TextTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (!options.tech) {
      throw new Error("A tech was not provided.");
    }
    var settings = mergeOptions$3(options, {
      kind: TextTrackKind[options.kind] || "subtitles",
      language: options.language || options.srclang || ""
    });
    var mode = TextTrackMode[settings.mode] || "disabled";
    var default_ = settings["default"];
    if (settings.kind === "metadata" || settings.kind === "chapters") {
      mode = "hidden";
    }
    _this = _Track.call(this, settings) || this;
    _this.tech_ = settings.tech;
    _this.cues_ = [];
    _this.activeCues_ = [];
    _this.preload_ = _this.tech_.preloadTextTracks !== false;
    var cues = new TextTrackCueList(_this.cues_);
    var activeCues = new TextTrackCueList(_this.activeCues_);
    var changed = false;
    _this.timeupdateHandler = bind(_assertThisInitialized(_this), function(event) {
      if (event === void 0) {
        event = {};
      }
      if (this.tech_.isDisposed()) {
        return;
      }
      if (!this.tech_.isReady_) {
        if (event.type !== "timeupdate") {
          this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
        }
        return;
      }
      this.activeCues = this.activeCues;
      if (changed) {
        this.trigger("cuechange");
        changed = false;
      }
      if (event.type !== "timeupdate") {
        this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
      }
    });
    var disposeHandler = function disposeHandler2() {
      _this.stopTracking();
    };
    _this.tech_.one("dispose", disposeHandler);
    if (mode !== "disabled") {
      _this.startTracking();
    }
    Object.defineProperties(_assertThisInitialized(_this), {
      /**
       * @memberof TextTrack
       * @member {boolean} default
       *         If this track was set to be on or off by default. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */
      "default": {
        get: function get7() {
          return default_;
        },
        set: function set4() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {string} mode
       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
       *         not be set if setting to an invalid mode.
       * @instance
       *
       * @fires TextTrack#modechange
       */
      mode: {
        get: function get7() {
          return mode;
        },
        set: function set4(newMode) {
          if (!TextTrackMode[newMode]) {
            return;
          }
          if (mode === newMode) {
            return;
          }
          mode = newMode;
          if (!this.preload_ && mode !== "disabled" && this.cues.length === 0) {
            loadTrack(this.src, this);
          }
          this.stopTracking();
          if (mode !== "disabled") {
            this.startTracking();
          }
          this.trigger("modechange");
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} cues
       *         The text track cue list for this TextTrack.
       * @instance
       */
      cues: {
        get: function get7() {
          if (!this.loaded_) {
            return null;
          }
          return cues;
        },
        set: function set4() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} activeCues
       *         The list text track cues that are currently active for this TextTrack.
       * @instance
       */
      activeCues: {
        get: function get7() {
          if (!this.loaded_) {
            return null;
          }
          if (this.cues.length === 0) {
            return activeCues;
          }
          var ct = this.tech_.currentTime();
          var active = [];
          for (var i = 0, l = this.cues.length; i < l; i++) {
            var cue = this.cues[i];
            if (cue.startTime <= ct && cue.endTime >= ct) {
              active.push(cue);
            } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
              active.push(cue);
            }
          }
          changed = false;
          if (active.length !== this.activeCues_.length) {
            changed = true;
          } else {
            for (var _i = 0; _i < active.length; _i++) {
              if (this.activeCues_.indexOf(active[_i]) === -1) {
                changed = true;
              }
            }
          }
          this.activeCues_ = active;
          activeCues.setCues_(this.activeCues_);
          return activeCues;
        },
        // /!\ Keep this setter empty (see the timeupdate handler above)
        set: function set4() {
        }
      }
    });
    if (settings.src) {
      _this.src = settings.src;
      if (!_this.preload_) {
        _this.loaded_ = true;
      }
      if (_this.preload_ || settings.kind !== "subtitles" && settings.kind !== "captions") {
        loadTrack(_this.src, _assertThisInitialized(_this));
      }
    } else {
      _this.loaded_ = true;
    }
    return _this;
  }
  var _proto = TextTrack2.prototype;
  _proto.startTracking = function startTracking() {
    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
    this.tech_.on("timeupdate", this.timeupdateHandler);
  };
  _proto.stopTracking = function stopTracking() {
    if (this.rvf_) {
      this.tech_.cancelVideoFrameCallback(this.rvf_);
      this.rvf_ = void 0;
    }
    this.tech_.off("timeupdate", this.timeupdateHandler);
  };
  _proto.addCue = function addCue(originalCue) {
    var cue = originalCue;
    if (!("getCueAsHTML" in cue)) {
      cue = new import_window6.default.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
      for (var prop in originalCue) {
        if (!(prop in cue)) {
          cue[prop] = originalCue[prop];
        }
      }
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }
    var tracks = this.tech_.textTracks();
    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }
    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };
  _proto.removeCue = function removeCue(_removeCue) {
    var i = this.cues_.length;
    while (i--) {
      var cue = this.cues_[i];
      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  };
  return TextTrack2;
}(Track);
TextTrack.prototype.allowedEvents_ = {
  cuechange: "cuechange"
};
var AudioTrack = function(_Track) {
  _inheritsLoose(AudioTrack2, _Track);
  function AudioTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    var settings = mergeOptions$3(options, {
      kind: AudioTrackKind[options.kind] || ""
    });
    _this = _Track.call(this, settings) || this;
    var enabled = false;
    Object.defineProperty(_assertThisInitialized(_this), "enabled", {
      get: function get7() {
        return enabled;
      },
      set: function set4(newEnabled) {
        if (typeof newEnabled !== "boolean" || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;
        this.trigger("enabledchange");
      }
    });
    if (settings.enabled) {
      _this.enabled = settings.enabled;
    }
    _this.loaded_ = true;
    return _this;
  }
  return AudioTrack2;
}(Track);
var VideoTrack = function(_Track) {
  _inheritsLoose(VideoTrack2, _Track);
  function VideoTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    var settings = mergeOptions$3(options, {
      kind: VideoTrackKind[options.kind] || ""
    });
    _this = _Track.call(this, settings) || this;
    var selected = false;
    Object.defineProperty(_assertThisInitialized(_this), "selected", {
      get: function get7() {
        return selected;
      },
      set: function set4(newSelected) {
        if (typeof newSelected !== "boolean" || newSelected === selected) {
          return;
        }
        selected = newSelected;
        this.trigger("selectedchange");
      }
    });
    if (settings.selected) {
      _this.selected = settings.selected;
    }
    return _this;
  }
  return VideoTrack2;
}(Track);
var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;
var HTMLTrackElement = function(_EventTarget) {
  _inheritsLoose(HTMLTrackElement2, _EventTarget);
  function HTMLTrackElement2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    var readyState;
    var track = new TextTrack(options);
    _this.kind = track.kind;
    _this.src = track.src;
    _this.srclang = track.language;
    _this.label = track.label;
    _this["default"] = track["default"];
    Object.defineProperties(_assertThisInitialized(_this), {
      /**
       * @memberof HTMLTrackElement
       * @member {HTMLTrackElement~ReadyState} readyState
       *         The current ready state of the track element.
       * @instance
       */
      readyState: {
        get: function get7() {
          return readyState;
        }
      },
      /**
       * @memberof HTMLTrackElement
       * @member {TextTrack} track
       *         The underlying TextTrack object.
       * @instance
       *
       */
      track: {
        get: function get7() {
          return track;
        }
      }
    });
    readyState = NONE;
    track.addEventListener("loadeddata", function() {
      readyState = LOADED;
      _this.trigger({
        type: "load",
        target: _assertThisInitialized(_this)
      });
    });
    return _this;
  }
  return HTMLTrackElement2;
}(EventTarget$2);
HTMLTrackElement.prototype.allowedEvents_ = {
  load: "load"
};
HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;
var NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: "Audio"
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: "Video"
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: "Text"
  }
};
Object.keys(NORMAL).forEach(function(type2) {
  NORMAL[type2].getterName = type2 + "Tracks";
  NORMAL[type2].privateName = type2 + "Tracks_";
});
var REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: "RemoteText",
    getterName: "remoteTextTracks",
    privateName: "remoteTextTracks_"
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: "RemoteTextTrackEls",
    getterName: "remoteTextTrackEls",
    privateName: "remoteTextTrackEls_"
  }
};
var ALL = _extends({}, NORMAL, REMOTE);
REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
function createTrackHelper(self2, kind, label, language, options) {
  if (options === void 0) {
    options = {};
  }
  var tracks = self2.textTracks();
  options.kind = kind;
  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self2;
  var track = new ALL.text.TrackClass(options);
  tracks.addTrack(track);
  return track;
}
var Tech = function(_Component) {
  _inheritsLoose(Tech2, _Component);
  function Tech2(options, ready) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (ready === void 0) {
      ready = function ready2() {
      };
    }
    options.reportTouchActivity = false;
    _this = _Component.call(this, null, options, ready) || this;
    _this.onDurationChange_ = function(e) {
      return _this.onDurationChange(e);
    };
    _this.trackProgress_ = function(e) {
      return _this.trackProgress(e);
    };
    _this.trackCurrentTime_ = function(e) {
      return _this.trackCurrentTime(e);
    };
    _this.stopTrackingCurrentTime_ = function(e) {
      return _this.stopTrackingCurrentTime(e);
    };
    _this.disposeSourceHandler_ = function(e) {
      return _this.disposeSourceHandler(e);
    };
    _this.queuedHanders_ = /* @__PURE__ */ new Set();
    _this.hasStarted_ = false;
    _this.on("playing", function() {
      this.hasStarted_ = true;
    });
    _this.on("loadstart", function() {
      this.hasStarted_ = false;
    });
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      if (options && options[props.getterName]) {
        _this[props.privateName] = options[props.getterName];
      }
    });
    if (!_this.featuresProgressEvents) {
      _this.manualProgressOn();
    }
    if (!_this.featuresTimeupdateEvents) {
      _this.manualTimeUpdatesOn();
    }
    ["Text", "Audio", "Video"].forEach(function(track) {
      if (options["native" + track + "Tracks"] === false) {
        _this["featuresNative" + track + "Tracks"] = false;
      }
    });
    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      _this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      _this.featuresNativeTextTracks = true;
    }
    if (!_this.featuresNativeTextTracks) {
      _this.emulateTextTracks();
    }
    _this.preloadTextTracks = options.preloadTextTracks !== false;
    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();
    _this.initTrackListeners();
    if (!options.nativeControlsForTouch) {
      _this.emitTapEvents();
    }
    if (_this.constructor) {
      _this.name_ = _this.constructor.name || "Unknown Tech";
    }
    return _this;
  }
  var _proto = Tech2.prototype;
  _proto.triggerSourceset = function triggerSourceset(src) {
    var _this2 = this;
    if (!this.isReady_) {
      this.one("ready", function() {
        return _this2.setTimeout(function() {
          return _this2.triggerSourceset(src);
        }, 1);
      });
    }
    this.trigger({
      src,
      type: "sourceset"
    });
  };
  _proto.manualProgressOn = function manualProgressOn() {
    this.on("durationchange", this.onDurationChange_);
    this.manualProgress = true;
    this.one("ready", this.trackProgress_);
  };
  _proto.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();
    this.off("durationchange", this.onDurationChange_);
  };
  _proto.trackProgress = function trackProgress(event) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind(this, function() {
      var numBufferedPercent = this.bufferedPercent();
      if (this.bufferedPercent_ !== numBufferedPercent) {
        this.trigger("progress");
      }
      this.bufferedPercent_ = numBufferedPercent;
      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };
  _proto.onDurationChange = function onDurationChange(event) {
    this.duration_ = this.duration();
  };
  _proto.buffered = function buffered() {
    return createTimeRanges(0, 0);
  };
  _proto.bufferedPercent = function bufferedPercent$1() {
    return bufferedPercent(this.buffered(), this.duration_);
  };
  _proto.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };
  _proto.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;
    this.on("play", this.trackCurrentTime_);
    this.on("pause", this.stopTrackingCurrentTime_);
  };
  _proto.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off("play", this.trackCurrentTime_);
    this.off("pause", this.stopTrackingCurrentTime_);
  };
  _proto.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function() {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }, 250);
  };
  _proto.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);
    this.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: true
    });
  };
  _proto.dispose = function dispose() {
    this.clearTracks(NORMAL.names);
    if (this.manualProgress) {
      this.manualProgressOff();
    }
    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }
    _Component.prototype.dispose.call(this);
  };
  _proto.clearTracks = function clearTracks(types) {
    var _this3 = this;
    types = [].concat(types);
    types.forEach(function(type2) {
      var list = _this3[type2 + "Tracks"]() || [];
      var i = list.length;
      while (i--) {
        var track = list[i];
        if (type2 === "text") {
          _this3.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  };
  _proto.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
    var list = this.autoRemoteTextTracks_ || [];
    var i = list.length;
    while (i--) {
      var track = list[i];
      this.removeRemoteTextTrack(track);
    }
  };
  _proto.reset = function reset3() {
  };
  _proto.crossOrigin = function crossOrigin() {
  };
  _proto.setCrossOrigin = function setCrossOrigin() {
  };
  _proto.error = function error(err) {
    if (err !== void 0) {
      this.error_ = new MediaError(err);
      this.trigger("error");
    }
    return this.error_;
  };
  _proto.played = function played() {
    if (this.hasStarted_) {
      return createTimeRanges(0, 0);
    }
    return createTimeRanges();
  };
  _proto.play = function play() {
  };
  _proto.setScrubbing = function setScrubbing() {
  };
  _proto.scrubbing = function scrubbing() {
  };
  _proto.setCurrentTime = function setCurrentTime() {
    if (this.manualTimeUpdates) {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }
  };
  _proto.initTrackListeners = function initTrackListeners() {
    var _this4 = this;
    NORMAL.names.forEach(function(name) {
      var props = NORMAL[name];
      var trackListChanges = function trackListChanges2() {
        _this4.trigger(name + "trackchange");
      };
      var tracks = _this4[props.getterName]();
      tracks.addEventListener("removetrack", trackListChanges);
      tracks.addEventListener("addtrack", trackListChanges);
      _this4.on("dispose", function() {
        tracks.removeEventListener("removetrack", trackListChanges);
        tracks.removeEventListener("addtrack", trackListChanges);
      });
    });
  };
  _proto.addWebVttScript_ = function addWebVttScript_() {
    var _this5 = this;
    if (import_window6.default.WebVTT) {
      return;
    }
    if (import_document.default.body.contains(this.el())) {
      if (!this.options_["vtt.js"] && isPlain(import_videojs_vtt.default) && Object.keys(import_videojs_vtt.default).length > 0) {
        this.trigger("vttjsloaded");
        return;
      }
      var script = import_document.default.createElement("script");
      script.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js";
      script.onload = function() {
        _this5.trigger("vttjsloaded");
      };
      script.onerror = function() {
        _this5.trigger("vttjserror");
      };
      this.on("dispose", function() {
        script.onload = null;
        script.onerror = null;
      });
      import_window6.default.WebVTT = true;
      this.el().parentNode.appendChild(script);
    } else {
      this.ready(this.addWebVttScript_);
    }
  };
  _proto.emulateTextTracks = function emulateTextTracks() {
    var _this6 = this;
    var tracks = this.textTracks();
    var remoteTracks = this.remoteTextTracks();
    var handleAddTrack = function handleAddTrack2(e) {
      return tracks.addTrack(e.track);
    };
    var handleRemoveTrack = function handleRemoveTrack2(e) {
      return tracks.removeTrack(e.track);
    };
    remoteTracks.on("addtrack", handleAddTrack);
    remoteTracks.on("removetrack", handleRemoveTrack);
    this.addWebVttScript_();
    var updateDisplay = function updateDisplay2() {
      return _this6.trigger("texttrackchange");
    };
    var textTracksChanges = function textTracksChanges2() {
      updateDisplay();
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        track.removeEventListener("cuechange", updateDisplay);
        if (track.mode === "showing") {
          track.addEventListener("cuechange", updateDisplay);
        }
      }
    };
    textTracksChanges();
    tracks.addEventListener("change", textTracksChanges);
    tracks.addEventListener("addtrack", textTracksChanges);
    tracks.addEventListener("removetrack", textTracksChanges);
    this.on("dispose", function() {
      remoteTracks.off("addtrack", handleAddTrack);
      remoteTracks.off("removetrack", handleRemoveTrack);
      tracks.removeEventListener("change", textTracksChanges);
      tracks.removeEventListener("addtrack", textTracksChanges);
      tracks.removeEventListener("removetrack", textTracksChanges);
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        track.removeEventListener("cuechange", updateDisplay);
      }
    });
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error("TextTrack kind is required but was not provided");
    }
    return createTrackHelper(this, kind, label, language);
  };
  _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
    var track = mergeOptions$3(options, {
      tech: this
    });
    return new REMOTE.remoteTextEl.TrackClass(track);
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var _this7 = this;
    if (options === void 0) {
      options = {};
    }
    var htmlTrackElement = this.createRemoteTextTrack(options);
    if (manualCleanup !== true && manualCleanup !== false) {
      log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
      manualCleanup = true;
    }
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);
    if (manualCleanup !== true) {
      this.ready(function() {
        return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
      });
    }
    return htmlTrackElement;
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return {};
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      return PromiseClass.reject();
    }
  };
  _proto.disablePictureInPicture = function disablePictureInPicture() {
    return true;
  };
  _proto.setDisablePictureInPicture = function setDisablePictureInPicture() {
  };
  _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb) {
    var _this8 = this;
    var id = newGUID();
    if (!this.isReady_ || this.paused()) {
      this.queuedHanders_.add(id);
      this.one("playing", function() {
        if (_this8.queuedHanders_.has(id)) {
          _this8.queuedHanders_["delete"](id);
          cb();
        }
      });
    } else {
      this.requestNamedAnimationFrame(id, cb);
    }
    return id;
  };
  _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id) {
    if (this.queuedHanders_.has(id)) {
      this.queuedHanders_["delete"](id);
    } else {
      this.cancelNamedAnimationFrame(id);
    }
  };
  _proto.setPoster = function setPoster() {
  };
  _proto.playsinline = function playsinline() {
  };
  _proto.setPlaysinline = function setPlaysinline() {
  };
  _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks() {
  };
  _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks() {
  };
  _proto.canPlayType = function canPlayType3() {
    return "";
  };
  Tech2.canPlayType = function canPlayType3() {
    return "";
  };
  Tech2.canPlaySource = function canPlaySource(srcObj, options) {
    return Tech2.canPlayType(srcObj.type);
  };
  Tech2.isTech = function isTech(component) {
    return component.prototype instanceof Tech2 || component instanceof Tech2 || component === Tech2;
  };
  Tech2.registerTech = function registerTech(name, tech) {
    if (!Tech2.techs_) {
      Tech2.techs_ = {};
    }
    if (!Tech2.isTech(tech)) {
      throw new Error("Tech " + name + " must be a Tech");
    }
    if (!Tech2.canPlayType) {
      throw new Error("Techs must have a static canPlayType method on them");
    }
    if (!Tech2.canPlaySource) {
      throw new Error("Techs must have a static canPlaySource method on them");
    }
    name = toTitleCase$1(name);
    Tech2.techs_[name] = tech;
    Tech2.techs_[toLowerCase(name)] = tech;
    if (name !== "Tech") {
      Tech2.defaultTechOrder_.push(name);
    }
    return tech;
  };
  Tech2.getTech = function getTech(name) {
    if (!name) {
      return;
    }
    if (Tech2.techs_ && Tech2.techs_[name]) {
      return Tech2.techs_[name];
    }
    name = toTitleCase$1(name);
    if (import_window6.default && import_window6.default.videojs && import_window6.default.videojs[name]) {
      log$1.warn("The " + name + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)");
      return import_window6.default.videojs[name];
    }
  };
  return Tech2;
}(Component$1);
ALL.names.forEach(function(name) {
  var props = ALL[name];
  Tech.prototype[props.getterName] = function() {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});
Tech.prototype.featuresVolumeControl = true;
Tech.prototype.featuresMuteControl = true;
Tech.prototype.featuresFullscreenResize = false;
Tech.prototype.featuresPlaybackRate = false;
Tech.prototype.featuresProgressEvents = false;
Tech.prototype.featuresSourceset = false;
Tech.prototype.featuresTimeupdateEvents = false;
Tech.prototype.featuresNativeTextTracks = false;
Tech.prototype.featuresVideoFrameCallback = false;
Tech.withSourceHandlers = function(_Tech) {
  _Tech.registerSourceHandler = function(handler, index) {
    var handlers = _Tech.sourceHandlers;
    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }
    if (index === void 0) {
      index = handlers.length;
    }
    handlers.splice(index, 0, handler);
  };
  _Tech.canPlayType = function(type2) {
    var handlers = _Tech.sourceHandlers || [];
    var can;
    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type2);
      if (can) {
        return can;
      }
    }
    return "";
  };
  _Tech.selectSourceHandler = function(source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can;
    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);
      if (can) {
        return handlers[i];
      }
    }
    return null;
  };
  _Tech.canPlaySource = function(srcObj, options) {
    var sh = _Tech.selectSourceHandler(srcObj, options);
    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }
    return "";
  };
  var deferrable = ["seekable", "seeking", "duration"];
  deferrable.forEach(function(fnName) {
    var originalFn = this[fnName];
    if (typeof originalFn !== "function") {
      return;
    }
    this[fnName] = function() {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);
  _Tech.prototype.setSource = function(source) {
    var sh = _Tech.selectSourceHandler(source, this.options_);
    if (!sh) {
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        log$1.error("No source handler found for the current source.");
      }
    }
    this.disposeSourceHandler();
    this.off("dispose", this.disposeSourceHandler_);
    if (sh !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }
    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.one("dispose", this.disposeSourceHandler_);
  };
  _Tech.prototype.disposeSourceHandler = function() {
    if (this.currentSource_) {
      this.clearTracks(["audio", "video"]);
      this.currentSource_ = null;
    }
    this.cleanupAutoTextTracks();
    if (this.sourceHandler_) {
      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }
      this.sourceHandler_ = null;
    }
  };
};
Component$1.registerComponent("Tech", Tech);
Tech.registerTech("Tech", Tech);
Tech.defaultTechOrder_ = [];
var middlewares = {};
var middlewareInstances = {};
var TERMINATOR = {};
function use(type2, middleware) {
  middlewares[type2] = middlewares[type2] || [];
  middlewares[type2].push(middleware);
}
function setSource(player, src, next) {
  player.setTimeout(function() {
    return setSourceHelper(src, middlewares[src.type], next, player);
  }, 1);
}
function setTech(middleware, tech) {
  middleware.forEach(function(mw) {
    return mw.setTech && mw.setTech(tech);
  });
}
function get(middleware, tech, method) {
  return middleware.reduceRight(middlewareIterator(method), tech[method]());
}
function set(middleware, tech, method, arg) {
  return tech[method](middleware.reduce(middlewareIterator(method), arg));
}
function mediate(middleware, tech, method, arg) {
  if (arg === void 0) {
    arg = null;
  }
  var callMethod = "call" + toTitleCase$1(method);
  var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
  var terminated = middlewareValue === TERMINATOR;
  var returnValue = terminated ? null : tech[method](middlewareValue);
  executeRight(middleware, method, returnValue, terminated);
  return returnValue;
}
var allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  muted: 1,
  played: 1,
  paused: 1,
  seekable: 1,
  volume: 1,
  ended: 1
};
var allowedSetters = {
  setCurrentTime: 1,
  setMuted: 1,
  setVolume: 1
};
var allowedMediators = {
  play: 1,
  pause: 1
};
function middlewareIterator(method) {
  return function(value, mw) {
    if (value === TERMINATOR) {
      return TERMINATOR;
    }
    if (mw[method]) {
      return mw[method](value);
    }
    return value;
  };
}
function executeRight(mws, method, value, terminated) {
  for (var i = mws.length - 1; i >= 0; i--) {
    var mw = mws[i];
    if (mw[method]) {
      mw[method](terminated, value);
    }
  }
}
function clearCacheForPlayer(player) {
  middlewareInstances[player.id()] = null;
}
function getOrCreateFactory(player, mwFactory) {
  var mws = middlewareInstances[player.id()];
  var mw = null;
  if (mws === void 0 || mws === null) {
    mw = mwFactory(player);
    middlewareInstances[player.id()] = [[mwFactory, mw]];
    return mw;
  }
  for (var i = 0; i < mws.length; i++) {
    var _mws$i = mws[i], mwf = _mws$i[0], mwi = _mws$i[1];
    if (mwf !== mwFactory) {
      continue;
    }
    mw = mwi;
  }
  if (mw === null) {
    mw = mwFactory(player);
    mws.push([mwFactory, mw]);
  }
  return mw;
}
function setSourceHelper(src, middleware, next, player, acc, lastRun) {
  if (src === void 0) {
    src = {};
  }
  if (middleware === void 0) {
    middleware = [];
  }
  if (acc === void 0) {
    acc = [];
  }
  if (lastRun === void 0) {
    lastRun = false;
  }
  var _middleware = middleware, mwFactory = _middleware[0], mwrest = _middleware.slice(1);
  if (typeof mwFactory === "string") {
    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
  } else if (mwFactory) {
    var mw = getOrCreateFactory(player, mwFactory);
    if (!mw.setSource) {
      acc.push(mw);
      return setSourceHelper(src, mwrest, next, player, acc, lastRun);
    }
    mw.setSource(assign({}, src), function(err, _src) {
      if (err) {
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }
      acc.push(mw);
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next, player, acc, lastRun);
  } else if (lastRun) {
    next(src, acc);
  } else {
    setSourceHelper(src, middlewares["*"], next, player, acc, true);
  }
}
var MimetypesKind = {
  opus: "video/ogg",
  ogv: "video/ogg",
  mp4: "video/mp4",
  mov: "video/mp4",
  m4v: "video/mp4",
  mkv: "video/x-matroska",
  m4a: "audio/mp4",
  mp3: "audio/mpeg",
  aac: "audio/aac",
  caf: "audio/x-caf",
  flac: "audio/flac",
  oga: "audio/ogg",
  wav: "audio/wav",
  m3u8: "application/x-mpegURL",
  mpd: "application/dash+xml",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  gif: "image/gif",
  png: "image/png",
  svg: "image/svg+xml",
  webp: "image/webp"
};
var getMimetype = function getMimetype2(src) {
  if (src === void 0) {
    src = "";
  }
  var ext = getFileExtension(src);
  var mimetype = MimetypesKind[ext.toLowerCase()];
  return mimetype || "";
};
var findMimetype = function findMimetype2(player, src) {
  if (!src) {
    return "";
  }
  if (player.cache_.source.src === src && player.cache_.source.type) {
    return player.cache_.source.type;
  }
  var matchingSources = player.cache_.sources.filter(function(s2) {
    return s2.src === src;
  });
  if (matchingSources.length) {
    return matchingSources[0].type;
  }
  var sources = player.$$("source");
  for (var i = 0; i < sources.length; i++) {
    var s = sources[i];
    if (s.type && s.src && s.src === src) {
      return s.type;
    }
  }
  return getMimetype(src);
};
var filterSource = function filterSource2(src) {
  if (Array.isArray(src)) {
    var newsrc = [];
    src.forEach(function(srcobj) {
      srcobj = filterSource2(srcobj);
      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject3(srcobj)) {
        newsrc.push(srcobj);
      }
    });
    src = newsrc;
  } else if (typeof src === "string" && src.trim()) {
    src = [fixSource({
      src
    })];
  } else if (isObject3(src) && typeof src.src === "string" && src.src && src.src.trim()) {
    src = [fixSource(src)];
  } else {
    src = [];
  }
  return src;
};
function fixSource(src) {
  if (!src.type) {
    var mimetype = getMimetype(src.src);
    if (mimetype) {
      src.type = mimetype;
    }
  }
  return src;
}
var MediaLoader = function(_Component) {
  _inheritsLoose(MediaLoader2, _Component);
  function MediaLoader2(player, options, ready) {
    var _this;
    var options_ = mergeOptions$3({
      createEl: false
    }, options);
    _this = _Component.call(this, player, options_, ready) || this;
    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (var i = 0, j2 = options.playerOptions.techOrder; i < j2.length; i++) {
        var techName = toTitleCase$1(j2[i]);
        var tech = Tech.getTech(techName);
        if (!techName) {
          tech = Component$1.getComponent(techName);
        }
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      player.src(options.playerOptions.sources);
    }
    return _this;
  }
  return MediaLoader2;
}(Component$1);
Component$1.registerComponent("MediaLoader", MediaLoader);
var ClickableComponent = function(_Component) {
  _inheritsLoose(ClickableComponent2, _Component);
  function ClickableComponent2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    if (_this.options_.controlText) {
      _this.controlText(_this.options_.controlText);
    }
    _this.handleMouseOver_ = function(e) {
      return _this.handleMouseOver(e);
    };
    _this.handleMouseOut_ = function(e) {
      return _this.handleMouseOut(e);
    };
    _this.handleClick_ = function(e) {
      return _this.handleClick(e);
    };
    _this.handleKeyDown_ = function(e) {
      return _this.handleKeyDown(e);
    };
    _this.emitTapEvents();
    _this.enable();
    return _this;
  }
  var _proto = ClickableComponent2.prototype;
  _proto.createEl = function createEl$1(tag, props, attributes) {
    if (tag === void 0) {
      tag = "div";
    }
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    props = assign({
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);
    if (tag === "button") {
      log$1.error("Creating a ClickableComponent with an HTML element of " + tag + " is not supported; use a Button instead.");
    }
    attributes = assign({
      role: "button"
    }, attributes);
    this.tabIndex_ = props.tabIndex;
    var el = createEl(tag, props, attributes);
    el.appendChild(createEl("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": true
    }));
    this.createControlTextEl(el);
    return el;
  };
  _proto.dispose = function dispose() {
    this.controlTextEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.createControlTextEl = function createControlTextEl(el) {
    this.controlTextEl_ = createEl("span", {
      className: "vjs-control-text"
    }, {
      // let the screen reader user know that the text of the element may change
      "aria-live": "polite"
    });
    if (el) {
      el.appendChild(this.controlTextEl_);
    }
    this.controlText(this.controlText_, el);
    return this.controlTextEl_;
  };
  _proto.controlText = function controlText(text, el) {
    if (el === void 0) {
      el = this.el();
    }
    if (text === void 0) {
      return this.controlText_ || "Need Text";
    }
    var localizedText = this.localize(text);
    this.controlText_ = text;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {
      el.setAttribute("title", localizedText);
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-control vjs-button " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.enable = function enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass("vjs-disabled");
      this.el_.setAttribute("aria-disabled", "false");
      if (typeof this.tabIndex_ !== "undefined") {
        this.el_.setAttribute("tabIndex", this.tabIndex_);
      }
      this.on(["tap", "click"], this.handleClick_);
      this.on("keydown", this.handleKeyDown_);
    }
  };
  _proto.disable = function disable() {
    this.enabled_ = false;
    this.addClass("vjs-disabled");
    this.el_.setAttribute("aria-disabled", "true");
    if (typeof this.tabIndex_ !== "undefined") {
      this.el_.removeAttribute("tabIndex");
    }
    this.off("mouseover", this.handleMouseOver_);
    this.off("mouseout", this.handleMouseOut_);
    this.off(["tap", "click"], this.handleClick_);
    this.off("keydown", this.handleKeyDown_);
  };
  _proto.handleLanguagechange = function handleLanguagechange() {
    this.controlText(this.controlText_);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.options_.clickHandler) {
      this.options_.clickHandler.call(this, arguments);
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Space") || import_keycode.default.isEventKey(event, "Enter")) {
      event.preventDefault();
      event.stopPropagation();
      this.trigger("click");
    } else {
      _Component.prototype.handleKeyDown.call(this, event);
    }
  };
  return ClickableComponent2;
}(Component$1);
Component$1.registerComponent("ClickableComponent", ClickableComponent);
var PosterImage = function(_ClickableComponent) {
  _inheritsLoose(PosterImage2, _ClickableComponent);
  function PosterImage2(player, options) {
    var _this;
    _this = _ClickableComponent.call(this, player, options) || this;
    _this.update();
    _this.update_ = function(e) {
      return _this.update(e);
    };
    player.on("posterchange", _this.update_);
    return _this;
  }
  var _proto = PosterImage2.prototype;
  _proto.dispose = function dispose() {
    this.player().off("posterchange", this.update_);
    _ClickableComponent.prototype.dispose.call(this);
  };
  _proto.createEl = function createEl$1() {
    var el = createEl("div", {
      className: "vjs-poster",
      // Don't want poster to be tabbable.
      tabIndex: -1
    });
    return el;
  };
  _proto.update = function update(event) {
    var url = this.player().poster();
    this.setSrc(url);
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };
  _proto.setSrc = function setSrc(url) {
    var backgroundImage = "";
    if (url) {
      backgroundImage = 'url("' + url + '")';
    }
    this.el_.style.backgroundImage = backgroundImage;
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.controls()) {
      return;
    }
    var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
    if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where
    // calling .focus() on the video element causes the video to go black,
    // so we avoid it in that specific case
    !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
      this.player_.tech(true).focus();
    }
    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  };
  return PosterImage2;
}(ClickableComponent);
Component$1.registerComponent("PosterImage", PosterImage);
var darkGray = "#222";
var lightGray = "#ccc";
var fontMap = {
  monospace: "monospace",
  sansSerif: "sans-serif",
  serif: "serif",
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: "sans-serif",
  proportionalSerif: "serif",
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};
function constructColor(color, opacity) {
  var hex;
  if (color.length === 4) {
    hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
  } else if (color.length === 7) {
    hex = color.slice(1);
  } else {
    throw new Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
  }
  return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
}
function tryUpdateStyle(el, style, rule) {
  try {
    el.style[style] = rule;
  } catch (e) {
    return;
  }
}
var TextTrackDisplay = function(_Component) {
  _inheritsLoose(TextTrackDisplay2, _Component);
  function TextTrackDisplay2(player, options, ready) {
    var _this;
    _this = _Component.call(this, player, options, ready) || this;
    var updateDisplayHandler = function updateDisplayHandler2(e) {
      return _this.updateDisplay(e);
    };
    player.on("loadstart", function(e) {
      return _this.toggleDisplay(e);
    });
    player.on("texttrackchange", updateDisplayHandler);
    player.on("loadedmetadata", function(e) {
      return _this.preselectTrack(e);
    });
    player.ready(bind(_assertThisInitialized(_this), function() {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }
      player.on("fullscreenchange", updateDisplayHandler);
      player.on("playerresize", updateDisplayHandler);
      import_window6.default.addEventListener("orientationchange", updateDisplayHandler);
      player.on("dispose", function() {
        return import_window6.default.removeEventListener("orientationchange", updateDisplayHandler);
      });
      var tracks = this.options_.playerOptions.tracks || [];
      for (var i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }
      this.preselectTrack();
    }));
    return _this;
  }
  var _proto = TextTrackDisplay2.prototype;
  _proto.preselectTrack = function preselectTrack() {
    var modes = {
      captions: 1,
      subtitles: 1
    };
    var trackList = this.player_.textTracks();
    var userPref = this.player_.cache_.selectedLanguage;
    var firstDesc;
    var firstCaptions;
    var preferredTrack;
    for (var i = 0; i < trackList.length; i++) {
      var track = trackList[i];
      if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
        if (track.kind === userPref.kind) {
          preferredTrack = track;
        } else if (!preferredTrack) {
          preferredTrack = track;
        }
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track["default"]) {
        if (track.kind === "descriptions" && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }
    if (preferredTrack) {
      preferredTrack.mode = "showing";
    } else if (firstCaptions) {
      firstCaptions.mode = "showing";
    } else if (firstDesc) {
      firstDesc.mode = "showing";
    }
  };
  _proto.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  };
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-text-track-display"
    }, {
      "translate": "yes",
      "aria-live": "off",
      "aria-atomic": "true"
    });
  };
  _proto.clearDisplay = function clearDisplay() {
    if (typeof import_window6.default.WebVTT === "function") {
      import_window6.default.WebVTT.processCues(import_window6.default, [], this.el_);
    }
  };
  _proto.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();
    var allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
    this.clearDisplay();
    if (allowMultipleShowingTracks) {
      var showingTracks = [];
      for (var _i = 0; _i < tracks.length; ++_i) {
        var track = tracks[_i];
        if (track.mode !== "showing") {
          continue;
        }
        showingTracks.push(track);
      }
      this.updateForTrack(showingTracks);
      return;
    }
    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;
    var i = tracks.length;
    while (i--) {
      var _track = tracks[i];
      if (_track.mode === "showing") {
        if (_track.kind === "descriptions") {
          descriptionsTrack = _track;
        } else {
          captionsSubtitlesTrack = _track;
        }
      }
    }
    if (captionsSubtitlesTrack) {
      if (this.getAttribute("aria-live") !== "off") {
        this.setAttribute("aria-live", "off");
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute("aria-live") !== "assertive") {
        this.setAttribute("aria-live", "assertive");
      }
      this.updateForTrack(descriptionsTrack);
    }
  };
  _proto.updateDisplayState = function updateDisplayState(track) {
    var overrides = this.player_.textTrackSettings.getValues();
    var cues = track.activeCues;
    var i = cues.length;
    while (i--) {
      var cue = cues[i];
      if (!cue) {
        continue;
      }
      var cueDiv = cue.displayState;
      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === "dropshadow") {
          cueDiv.firstChild.style.textShadow = "2px 2px 3px " + darkGray + ", 2px 2px 4px " + darkGray + ", 2px 2px 5px " + darkGray;
        } else if (overrides.edgeStyle === "raised") {
          cueDiv.firstChild.style.textShadow = "1px 1px " + darkGray + ", 2px 2px " + darkGray + ", 3px 3px " + darkGray;
        } else if (overrides.edgeStyle === "depressed") {
          cueDiv.firstChild.style.textShadow = "1px 1px " + lightGray + ", 0 1px " + lightGray + ", -1px -1px " + darkGray + ", 0 -1px " + darkGray;
        } else if (overrides.edgeStyle === "uniform") {
          cueDiv.firstChild.style.textShadow = "0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize = import_window6.default.parseFloat(cueDiv.style.fontSize);
        cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px";
        cueDiv.style.height = "auto";
        cueDiv.style.top = "auto";
      }
      if (overrides.fontFamily && overrides.fontFamily !== "default") {
        if (overrides.fontFamily === "small-caps") {
          cueDiv.firstChild.style.fontVariant = "small-caps";
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };
  _proto.updateForTrack = function updateForTrack(tracks) {
    if (!Array.isArray(tracks)) {
      tracks = [tracks];
    }
    if (typeof import_window6.default.WebVTT !== "function" || tracks.every(function(track2) {
      return !track2.activeCues;
    })) {
      return;
    }
    var cues = [];
    for (var i = 0; i < tracks.length; ++i) {
      var track = tracks[i];
      for (var j2 = 0; j2 < track.activeCues.length; ++j2) {
        cues.push(track.activeCues[j2]);
      }
    }
    import_window6.default.WebVTT.processCues(import_window6.default, cues, this.el_);
    for (var _i2 = 0; _i2 < tracks.length; ++_i2) {
      var _track2 = tracks[_i2];
      for (var _j = 0; _j < _track2.activeCues.length; ++_j) {
        var cueEl = _track2.activeCues[_j].displayState;
        addClass(cueEl, "vjs-text-track-cue");
        addClass(cueEl, "vjs-text-track-cue-" + (_track2.language ? _track2.language : _i2));
        if (_track2.language) {
          setAttribute(cueEl, "lang", _track2.language);
        }
      }
      if (this.player_.textTrackSettings) {
        this.updateDisplayState(_track2);
      }
    }
  };
  return TextTrackDisplay2;
}(Component$1);
Component$1.registerComponent("TextTrackDisplay", TextTrackDisplay);
var LoadingSpinner = function(_Component) {
  _inheritsLoose(LoadingSpinner2, _Component);
  function LoadingSpinner2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = LoadingSpinner2.prototype;
  _proto.createEl = function createEl$1() {
    var isAudio = this.player_.isAudio();
    var playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
    var controlText = createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize("{1} is loading.", [playerType])
    });
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-loading-spinner",
      dir: "ltr"
    });
    el.appendChild(controlText);
    return el;
  };
  return LoadingSpinner2;
}(Component$1);
Component$1.registerComponent("LoadingSpinner", LoadingSpinner);
var Button = function(_ClickableComponent) {
  _inheritsLoose(Button2, _ClickableComponent);
  function Button2() {
    return _ClickableComponent.apply(this, arguments) || this;
  }
  var _proto = Button2.prototype;
  _proto.createEl = function createEl$1(tag, props, attributes) {
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    tag = "button";
    props = assign({
      className: this.buildCSSClass()
    }, props);
    attributes = assign({
      // Necessary since the default button type is "submit"
      type: "button"
    }, attributes);
    var el = createEl(tag, props, attributes);
    el.appendChild(createEl("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": true
    }));
    this.createControlTextEl(el);
    return el;
  };
  _proto.addChild = function addChild(child, options) {
    if (options === void 0) {
      options = {};
    }
    var className = this.constructor.name;
    log$1.warn("Adding an actionable (user controllable) child to a Button (" + className + ") is not supported; use a ClickableComponent instead.");
    return Component$1.prototype.addChild.call(this, child, options);
  };
  _proto.enable = function enable() {
    _ClickableComponent.prototype.enable.call(this);
    this.el_.removeAttribute("disabled");
  };
  _proto.disable = function disable() {
    _ClickableComponent.prototype.disable.call(this);
    this.el_.setAttribute("disabled", "disabled");
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Space") || import_keycode.default.isEventKey(event, "Enter")) {
      event.stopPropagation();
      return;
    }
    _ClickableComponent.prototype.handleKeyDown.call(this, event);
  };
  return Button2;
}(ClickableComponent);
Component$1.registerComponent("Button", Button);
var BigPlayButton = function(_Button) {
  _inheritsLoose(BigPlayButton2, _Button);
  function BigPlayButton2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.mouseused_ = false;
    _this.on("mousedown", function(e) {
      return _this.handleMouseDown(e);
    });
    return _this;
  }
  var _proto = BigPlayButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-big-play-button";
  };
  _proto.handleClick = function handleClick(event) {
    var playPromise = this.player_.play();
    if (this.mouseused_ && event.clientX && event.clientY) {
      var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
      silencePromise(playPromise);
      if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where
      // calling .focus() on the video element causes the video to go black,
      // so we avoid it in that specific case
      !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
        this.player_.tech(true).focus();
      }
      return;
    }
    var cb = this.player_.getChild("controlBar");
    var playToggle = cb && cb.getChild("playToggle");
    if (!playToggle) {
      this.player_.tech(true).focus();
      return;
    }
    var playFocus = function playFocus2() {
      return playToggle.focus();
    };
    if (isPromise(playPromise)) {
      playPromise.then(playFocus, function() {
      });
    } else {
      this.setTimeout(playFocus, 1);
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    this.mouseused_ = false;
    _Button.prototype.handleKeyDown.call(this, event);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    this.mouseused_ = true;
  };
  return BigPlayButton2;
}(Button);
BigPlayButton.prototype.controlText_ = "Play Video";
Component$1.registerComponent("BigPlayButton", BigPlayButton);
var CloseButton = function(_Button) {
  _inheritsLoose(CloseButton2, _Button);
  function CloseButton2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.controlText(options && options.controlText || _this.localize("Close"));
    return _this;
  }
  var _proto = CloseButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-close-button " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    this.trigger({
      type: "close",
      bubbles: false
    });
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Esc")) {
      event.preventDefault();
      event.stopPropagation();
      this.trigger("click");
    } else {
      _Button.prototype.handleKeyDown.call(this, event);
    }
  };
  return CloseButton2;
}(Button);
Component$1.registerComponent("CloseButton", CloseButton);
var PlayToggle = function(_Button) {
  _inheritsLoose(PlayToggle2, _Button);
  function PlayToggle2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Button.call(this, player, options) || this;
    options.replay = options.replay === void 0 || options.replay;
    _this.on(player, "play", function(e) {
      return _this.handlePlay(e);
    });
    _this.on(player, "pause", function(e) {
      return _this.handlePause(e);
    });
    if (options.replay) {
      _this.on(player, "ended", function(e) {
        return _this.handleEnded(e);
      });
    }
    return _this;
  }
  var _proto = PlayToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-play-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  };
  _proto.handleSeeked = function handleSeeked(event) {
    this.removeClass("vjs-ended");
    if (this.player_.paused()) {
      this.handlePause(event);
    } else {
      this.handlePlay(event);
    }
  };
  _proto.handlePlay = function handlePlay(event) {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-paused");
    this.addClass("vjs-playing");
    this.controlText("Pause");
  };
  _proto.handlePause = function handlePause(event) {
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.controlText("Play");
  };
  _proto.handleEnded = function handleEnded(event) {
    var _this2 = this;
    this.removeClass("vjs-playing");
    this.addClass("vjs-ended");
    this.controlText("Replay");
    this.one(this.player_, "seeked", function(e) {
      return _this2.handleSeeked(e);
    });
  };
  return PlayToggle2;
}(Button);
PlayToggle.prototype.controlText_ = "Play";
Component$1.registerComponent("PlayToggle", PlayToggle);
var defaultImplementation = function defaultImplementation2(seconds, guide) {
  seconds = seconds < 0 ? 0 : seconds;
  var s = Math.floor(seconds % 60);
  var m2 = Math.floor(seconds / 60 % 60);
  var h3 = Math.floor(seconds / 3600);
  var gm = Math.floor(guide / 60 % 60);
  var gh = Math.floor(guide / 3600);
  if (isNaN(seconds) || seconds === Infinity) {
    h3 = m2 = s = "-";
  }
  h3 = h3 > 0 || gh > 0 ? h3 + ":" : "";
  m2 = ((h3 || gm >= 10) && m2 < 10 ? "0" + m2 : m2) + ":";
  s = s < 10 ? "0" + s : s;
  return h3 + m2 + s;
};
var implementation = defaultImplementation;
function setFormatTime(customImplementation) {
  implementation = customImplementation;
}
function resetFormatTime() {
  implementation = defaultImplementation;
}
function formatTime(seconds, guide) {
  if (guide === void 0) {
    guide = seconds;
  }
  return implementation(seconds, guide);
}
var TimeDisplay = function(_Component) {
  _inheritsLoose(TimeDisplay2, _Component);
  function TimeDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.on(player, ["timeupdate", "ended"], function(e) {
      return _this.updateContent(e);
    });
    _this.updateTextNode_();
    return _this;
  }
  var _proto = TimeDisplay2.prototype;
  _proto.createEl = function createEl$1() {
    var className = this.buildCSSClass();
    var el = _Component.prototype.createEl.call(this, "div", {
      className: className + " vjs-time-control vjs-control"
    });
    var span = createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize(this.labelText_) + " "
    }, {
      role: "presentation"
    });
    el.appendChild(span);
    this.contentEl_ = createEl("span", {
      className: className + "-display"
    }, {
      // tell screen readers not to automatically read the time as it changes
      "aria-live": "off",
      // span elements have no implicit role, but some screen readers (notably VoiceOver)
      // treat them as a break between items in the DOM when using arrow keys
      // (or left-to-right swipes on iOS) to read contents of a page. Using
      // role='presentation' causes VoiceOver to NOT treat this span as a break.
      "role": "presentation"
    });
    el.appendChild(this.contentEl_);
    return el;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.textNode_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.updateTextNode_ = function updateTextNode_(time) {
    var _this2 = this;
    if (time === void 0) {
      time = 0;
    }
    time = formatTime(time);
    if (this.formattedTime_ === time) {
      return;
    }
    this.formattedTime_ = time;
    this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", function() {
      if (!_this2.contentEl_) {
        return;
      }
      var oldNode = _this2.textNode_;
      if (oldNode && _this2.contentEl_.firstChild !== oldNode) {
        oldNode = null;
        log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.");
      }
      _this2.textNode_ = import_document.default.createTextNode(_this2.formattedTime_);
      if (!_this2.textNode_) {
        return;
      }
      if (oldNode) {
        _this2.contentEl_.replaceChild(_this2.textNode_, oldNode);
      } else {
        _this2.contentEl_.appendChild(_this2.textNode_);
      }
    });
  };
  _proto.updateContent = function updateContent(event) {
  };
  return TimeDisplay2;
}(Component$1);
TimeDisplay.prototype.labelText_ = "Time";
TimeDisplay.prototype.controlText_ = "Time";
Component$1.registerComponent("TimeDisplay", TimeDisplay);
var CurrentTimeDisplay = function(_TimeDisplay) {
  _inheritsLoose(CurrentTimeDisplay2, _TimeDisplay);
  function CurrentTimeDisplay2() {
    return _TimeDisplay.apply(this, arguments) || this;
  }
  var _proto = CurrentTimeDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-current-time";
  };
  _proto.updateContent = function updateContent(event) {
    var time;
    if (this.player_.ended()) {
      time = this.player_.duration();
    } else {
      time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    }
    this.updateTextNode_(time);
  };
  return CurrentTimeDisplay2;
}(TimeDisplay);
CurrentTimeDisplay.prototype.labelText_ = "Current Time";
CurrentTimeDisplay.prototype.controlText_ = "Current Time";
Component$1.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
var DurationDisplay = function(_TimeDisplay) {
  _inheritsLoose(DurationDisplay2, _TimeDisplay);
  function DurationDisplay2(player, options) {
    var _this;
    _this = _TimeDisplay.call(this, player, options) || this;
    var updateContent = function updateContent2(e) {
      return _this.updateContent(e);
    };
    _this.on(player, "durationchange", updateContent);
    _this.on(player, "loadstart", updateContent);
    _this.on(player, "loadedmetadata", updateContent);
    return _this;
  }
  var _proto = DurationDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-duration";
  };
  _proto.updateContent = function updateContent(event) {
    var duration5 = this.player_.duration();
    this.updateTextNode_(duration5);
  };
  return DurationDisplay2;
}(TimeDisplay);
DurationDisplay.prototype.labelText_ = "Duration";
DurationDisplay.prototype.controlText_ = "Duration";
Component$1.registerComponent("DurationDisplay", DurationDisplay);
var TimeDivider = function(_Component) {
  _inheritsLoose(TimeDivider2, _Component);
  function TimeDivider2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = TimeDivider2.prototype;
  _proto.createEl = function createEl2() {
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-time-control vjs-time-divider"
    }, {
      // this element and its contents can be hidden from assistive techs since
      // it is made extraneous by the announcement of the control text
      // for the current time and duration displays
      "aria-hidden": true
    });
    var div = _Component.prototype.createEl.call(this, "div");
    var span = _Component.prototype.createEl.call(this, "span", {
      textContent: "/"
    });
    div.appendChild(span);
    el.appendChild(div);
    return el;
  };
  return TimeDivider2;
}(Component$1);
Component$1.registerComponent("TimeDivider", TimeDivider);
var RemainingTimeDisplay = function(_TimeDisplay) {
  _inheritsLoose(RemainingTimeDisplay2, _TimeDisplay);
  function RemainingTimeDisplay2(player, options) {
    var _this;
    _this = _TimeDisplay.call(this, player, options) || this;
    _this.on(player, "durationchange", function(e) {
      return _this.updateContent(e);
    });
    return _this;
  }
  var _proto = RemainingTimeDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-remaining-time";
  };
  _proto.createEl = function createEl$1() {
    var el = _TimeDisplay.prototype.createEl.call(this);
    if (this.options_.displayNegative !== false) {
      el.insertBefore(createEl("span", {}, {
        "aria-hidden": true
      }, "-"), this.contentEl_);
    }
    return el;
  };
  _proto.updateContent = function updateContent(event) {
    if (typeof this.player_.duration() !== "number") {
      return;
    }
    var time;
    if (this.player_.ended()) {
      time = 0;
    } else if (this.player_.remainingTimeDisplay) {
      time = this.player_.remainingTimeDisplay();
    } else {
      time = this.player_.remainingTime();
    }
    this.updateTextNode_(time);
  };
  return RemainingTimeDisplay2;
}(TimeDisplay);
RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
Component$1.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
var LiveDisplay = function(_Component) {
  _inheritsLoose(LiveDisplay2, _Component);
  function LiveDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.updateShowing();
    _this.on(_this.player(), "durationchange", function(e) {
      return _this.updateShowing(e);
    });
    return _this;
  }
  var _proto = LiveDisplay2.prototype;
  _proto.createEl = function createEl$1() {
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-live-control vjs-control"
    });
    this.contentEl_ = createEl("div", {
      className: "vjs-live-display"
    }, {
      "aria-live": "off"
    });
    this.contentEl_.appendChild(createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize("Stream Type") + " "
    }));
    this.contentEl_.appendChild(import_document.default.createTextNode(this.localize("LIVE")));
    el.appendChild(this.contentEl_);
    return el;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.updateShowing = function updateShowing(event) {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };
  return LiveDisplay2;
}(Component$1);
Component$1.registerComponent("LiveDisplay", LiveDisplay);
var SeekToLive = function(_Button) {
  _inheritsLoose(SeekToLive2, _Button);
  function SeekToLive2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.updateLiveEdgeStatus();
    if (_this.player_.liveTracker) {
      _this.updateLiveEdgeStatusHandler_ = function(e) {
        return _this.updateLiveEdgeStatus(e);
      };
      _this.on(_this.player_.liveTracker, "liveedgechange", _this.updateLiveEdgeStatusHandler_);
    }
    return _this;
  }
  var _proto = SeekToLive2.prototype;
  _proto.createEl = function createEl$1() {
    var el = _Button.prototype.createEl.call(this, "button", {
      className: "vjs-seek-to-live-control vjs-control"
    });
    this.textEl_ = createEl("span", {
      className: "vjs-seek-to-live-text",
      textContent: this.localize("LIVE")
    }, {
      "aria-hidden": "true"
    });
    el.appendChild(this.textEl_);
    return el;
  };
  _proto.updateLiveEdgeStatus = function updateLiveEdgeStatus() {
    if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
      this.setAttribute("aria-disabled", true);
      this.addClass("vjs-at-live-edge");
      this.controlText("Seek to live, currently playing live");
    } else {
      this.setAttribute("aria-disabled", false);
      this.removeClass("vjs-at-live-edge");
      this.controlText("Seek to live, currently behind live");
    }
  };
  _proto.handleClick = function handleClick() {
    this.player_.liveTracker.seekToLiveEdge();
  };
  _proto.dispose = function dispose() {
    if (this.player_.liveTracker) {
      this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
    }
    this.textEl_ = null;
    _Button.prototype.dispose.call(this);
  };
  return SeekToLive2;
}(Button);
SeekToLive.prototype.controlText_ = "Seek to live, currently playing live";
Component$1.registerComponent("SeekToLive", SeekToLive);
var clamp = function clamp2(number, min, max) {
  number = Number(number);
  return Math.min(max, Math.max(min, isNaN(number) ? min : number));
};
var Slider = function(_Component) {
  _inheritsLoose(Slider2, _Component);
  function Slider2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleMouseDown_ = function(e) {
      return _this.handleMouseDown(e);
    };
    _this.handleMouseUp_ = function(e) {
      return _this.handleMouseUp(e);
    };
    _this.handleKeyDown_ = function(e) {
      return _this.handleKeyDown(e);
    };
    _this.handleClick_ = function(e) {
      return _this.handleClick(e);
    };
    _this.handleMouseMove_ = function(e) {
      return _this.handleMouseMove(e);
    };
    _this.update_ = function(e) {
      return _this.update(e);
    };
    _this.bar = _this.getChild(_this.options_.barName);
    _this.vertical(!!_this.options_.vertical);
    _this.enable();
    return _this;
  }
  var _proto = Slider2.prototype;
  _proto.enabled = function enabled() {
    return this.enabled_;
  };
  _proto.enable = function enable() {
    if (this.enabled()) {
      return;
    }
    this.on("mousedown", this.handleMouseDown_);
    this.on("touchstart", this.handleMouseDown_);
    this.on("keydown", this.handleKeyDown_);
    this.on("click", this.handleClick_);
    this.on(this.player_, "controlsvisible", this.update);
    if (this.playerEvent) {
      this.on(this.player_, this.playerEvent, this.update);
    }
    this.removeClass("disabled");
    this.setAttribute("tabindex", 0);
    this.enabled_ = true;
  };
  _proto.disable = function disable() {
    if (!this.enabled()) {
      return;
    }
    var doc = this.bar.el_.ownerDocument;
    this.off("mousedown", this.handleMouseDown_);
    this.off("touchstart", this.handleMouseDown_);
    this.off("keydown", this.handleKeyDown_);
    this.off("click", this.handleClick_);
    this.off(this.player_, "controlsvisible", this.update_);
    this.off(doc, "mousemove", this.handleMouseMove_);
    this.off(doc, "mouseup", this.handleMouseUp_);
    this.off(doc, "touchmove", this.handleMouseMove_);
    this.off(doc, "touchend", this.handleMouseUp_);
    this.removeAttribute("tabindex");
    this.addClass("disabled");
    if (this.playerEvent) {
      this.off(this.player_, this.playerEvent, this.update);
    }
    this.enabled_ = false;
  };
  _proto.createEl = function createEl2(type2, props, attributes) {
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    props.className = props.className + " vjs-slider";
    props = assign({
      tabIndex: 0
    }, props);
    attributes = assign({
      "role": "slider",
      "aria-valuenow": 0,
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "tabIndex": 0
    }, attributes);
    return _Component.prototype.createEl.call(this, type2, props, attributes);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;
    if (event.type === "mousedown") {
      event.preventDefault();
    }
    if (event.type === "touchstart" && !IS_CHROME) {
      event.preventDefault();
    }
    blockTextSelection();
    this.addClass("vjs-sliding");
    this.trigger("slideractive");
    this.on(doc, "mousemove", this.handleMouseMove_);
    this.on(doc, "mouseup", this.handleMouseUp_);
    this.on(doc, "touchmove", this.handleMouseMove_);
    this.on(doc, "touchend", this.handleMouseUp_);
    this.handleMouseMove(event, true);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
  };
  _proto.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;
    unblockTextSelection();
    this.removeClass("vjs-sliding");
    this.trigger("sliderinactive");
    this.off(doc, "mousemove", this.handleMouseMove_);
    this.off(doc, "mouseup", this.handleMouseUp_);
    this.off(doc, "touchmove", this.handleMouseMove_);
    this.off(doc, "touchend", this.handleMouseUp_);
    this.update();
  };
  _proto.update = function update() {
    var _this2 = this;
    if (!this.el_ || !this.bar) {
      return;
    }
    var progress = this.getProgress();
    if (progress === this.progress_) {
      return progress;
    }
    this.progress_ = progress;
    this.requestNamedAnimationFrame("Slider#update", function() {
      var sizeKey = _this2.vertical() ? "height" : "width";
      _this2.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + "%";
    });
    return progress;
  };
  _proto.getProgress = function getProgress() {
    return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
  };
  _proto.calculateDistance = function calculateDistance(event) {
    var position = getPointerPosition(this.el_, event);
    if (this.vertical()) {
      return position.y;
    }
    return position.x;
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Left") || import_keycode.default.isEventKey(event, "Down")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepBack();
    } else if (import_keycode.default.isEventKey(event, "Right") || import_keycode.default.isEventKey(event, "Up")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepForward();
    } else {
      _Component.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.handleClick = function handleClick(event) {
    event.stopPropagation();
    event.preventDefault();
  };
  _proto.vertical = function vertical(bool) {
    if (bool === void 0) {
      return this.vertical_ || false;
    }
    this.vertical_ = !!bool;
    if (this.vertical_) {
      this.addClass("vjs-slider-vertical");
    } else {
      this.addClass("vjs-slider-horizontal");
    }
  };
  return Slider2;
}(Component$1);
Component$1.registerComponent("Slider", Slider);
var percentify = function percentify2(time, end) {
  return clamp(time / end * 100, 0, 100).toFixed(2) + "%";
};
var LoadProgressBar = function(_Component) {
  _inheritsLoose(LoadProgressBar2, _Component);
  function LoadProgressBar2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.partEls_ = [];
    _this.on(player, "progress", function(e) {
      return _this.update(e);
    });
    return _this;
  }
  var _proto = LoadProgressBar2.prototype;
  _proto.createEl = function createEl$1() {
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-load-progress"
    });
    var wrapper = createEl("span", {
      className: "vjs-control-text"
    });
    var loadedText = createEl("span", {
      textContent: this.localize("Loaded")
    });
    var separator = import_document.default.createTextNode(": ");
    this.percentageEl_ = createEl("span", {
      className: "vjs-control-text-loaded-percentage",
      textContent: "0%"
    });
    el.appendChild(wrapper);
    wrapper.appendChild(loadedText);
    wrapper.appendChild(separator);
    wrapper.appendChild(this.percentageEl_);
    return el;
  };
  _proto.dispose = function dispose() {
    this.partEls_ = null;
    this.percentageEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.update = function update(event) {
    var _this2 = this;
    this.requestNamedAnimationFrame("LoadProgressBar#update", function() {
      var liveTracker = _this2.player_.liveTracker;
      var buffered = _this2.player_.buffered();
      var duration5 = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : _this2.player_.duration();
      var bufferedEnd = _this2.player_.bufferedEnd();
      var children = _this2.partEls_;
      var percent = percentify(bufferedEnd, duration5);
      if (_this2.percent_ !== percent) {
        _this2.el_.style.width = percent;
        textContent(_this2.percentageEl_, percent);
        _this2.percent_ = percent;
      }
      for (var i = 0; i < buffered.length; i++) {
        var start2 = buffered.start(i);
        var end = buffered.end(i);
        var part = children[i];
        if (!part) {
          part = _this2.el_.appendChild(createEl());
          children[i] = part;
        }
        if (part.dataset.start === start2 && part.dataset.end === end) {
          continue;
        }
        part.dataset.start = start2;
        part.dataset.end = end;
        part.style.left = percentify(start2, bufferedEnd);
        part.style.width = percentify(end - start2, bufferedEnd);
      }
      for (var _i = children.length; _i > buffered.length; _i--) {
        _this2.el_.removeChild(children[_i - 1]);
      }
      children.length = buffered.length;
    });
  };
  return LoadProgressBar2;
}(Component$1);
Component$1.registerComponent("LoadProgressBar", LoadProgressBar);
var TimeTooltip = function(_Component) {
  _inheritsLoose(TimeTooltip2, _Component);
  function TimeTooltip2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = TimeTooltip2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-time-tooltip"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update(seekBarRect, seekBarPoint, content) {
    var tooltipRect = findPosition(this.el_);
    var playerRect = getBoundingClientRect(this.player_.el());
    var seekBarPointPx = seekBarRect.width * seekBarPoint;
    if (!playerRect || !tooltipRect) {
      return;
    }
    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
    var pullTooltipBy = tooltipRect.width / 2;
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }
    pullTooltipBy = Math.round(pullTooltipBy);
    this.el_.style.right = "-" + pullTooltipBy + "px";
    this.write(content);
  };
  _proto.write = function write(content) {
    textContent(this.el_, content);
  };
  _proto.updateTime = function updateTime(seekBarRect, seekBarPoint, time, cb) {
    var _this2 = this;
    this.requestNamedAnimationFrame("TimeTooltip#updateTime", function() {
      var content;
      var duration5 = _this2.player_.duration();
      if (_this2.player_.liveTracker && _this2.player_.liveTracker.isLive()) {
        var liveWindow = _this2.player_.liveTracker.liveWindow();
        var secondsBehind = liveWindow - seekBarPoint * liveWindow;
        content = (secondsBehind < 1 ? "" : "-") + formatTime(secondsBehind, liveWindow);
      } else {
        content = formatTime(time, duration5);
      }
      _this2.update(seekBarRect, seekBarPoint, content);
      if (cb) {
        cb();
      }
    });
  };
  return TimeTooltip2;
}(Component$1);
Component$1.registerComponent("TimeTooltip", TimeTooltip);
var PlayProgressBar = function(_Component) {
  _inheritsLoose(PlayProgressBar2, _Component);
  function PlayProgressBar2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = PlayProgressBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-play-progress vjs-slider-bar"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update(seekBarRect, seekBarPoint) {
    var timeTooltip = this.getChild("timeTooltip");
    if (!timeTooltip) {
      return;
    }
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
  };
  return PlayProgressBar2;
}(Component$1);
PlayProgressBar.prototype.options_ = {
  children: []
};
if (!IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push("timeTooltip");
}
Component$1.registerComponent("PlayProgressBar", PlayProgressBar);
var MouseTimeDisplay = function(_Component) {
  _inheritsLoose(MouseTimeDisplay2, _Component);
  function MouseTimeDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = MouseTimeDisplay2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  };
  _proto.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;
    var time = seekBarPoint * this.player_.duration();
    this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time, function() {
      _this2.el_.style.left = seekBarRect.width * seekBarPoint + "px";
    });
  };
  return MouseTimeDisplay2;
}(Component$1);
MouseTimeDisplay.prototype.options_ = {
  children: ["timeTooltip"]
};
Component$1.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
var STEP_SECONDS = 5;
var PAGE_KEY_MULTIPLIER = 12;
var SeekBar = function(_Slider) {
  _inheritsLoose(SeekBar2, _Slider);
  function SeekBar2(player, options) {
    var _this;
    _this = _Slider.call(this, player, options) || this;
    _this.setEventHandlers_();
    return _this;
  }
  var _proto = SeekBar2.prototype;
  _proto.setEventHandlers_ = function setEventHandlers_() {
    var _this2 = this;
    this.update_ = bind(this, this.update);
    this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);
    this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
    if (this.player_.liveTracker) {
      this.on(this.player_.liveTracker, "liveedgechange", this.update);
    }
    this.updateInterval = null;
    this.enableIntervalHandler_ = function(e) {
      return _this2.enableInterval_(e);
    };
    this.disableIntervalHandler_ = function(e) {
      return _this2.disableInterval_(e);
    };
    this.on(this.player_, ["playing"], this.enableIntervalHandler_);
    this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
    if ("hidden" in import_document.default && "visibilityState" in import_document.default) {
      this.on(import_document.default, "visibilitychange", this.toggleVisibility_);
    }
  };
  _proto.toggleVisibility_ = function toggleVisibility_(e) {
    if (import_document.default.visibilityState === "hidden") {
      this.cancelNamedAnimationFrame("SeekBar#update");
      this.cancelNamedAnimationFrame("Slider#update");
      this.disableInterval_(e);
    } else {
      if (!this.player_.ended() && !this.player_.paused()) {
        this.enableInterval_();
      }
      this.update();
    }
  };
  _proto.enableInterval_ = function enableInterval_() {
    if (this.updateInterval) {
      return;
    }
    this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
  };
  _proto.disableInterval_ = function disableInterval_(e) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended") {
      return;
    }
    if (!this.updateInterval) {
      return;
    }
    this.clearInterval(this.updateInterval);
    this.updateInterval = null;
  };
  _proto.createEl = function createEl2() {
    return _Slider.prototype.createEl.call(this, "div", {
      className: "vjs-progress-holder"
    }, {
      "aria-label": this.localize("Progress Bar")
    });
  };
  _proto.update = function update(event) {
    var _this3 = this;
    if (import_document.default.visibilityState === "hidden") {
      return;
    }
    var percent = _Slider.prototype.update.call(this);
    this.requestNamedAnimationFrame("SeekBar#update", function() {
      var currentTime = _this3.player_.ended() ? _this3.player_.duration() : _this3.getCurrentTime_();
      var liveTracker = _this3.player_.liveTracker;
      var duration5 = _this3.player_.duration();
      if (liveTracker && liveTracker.isLive()) {
        duration5 = _this3.player_.liveTracker.liveCurrentTime();
      }
      if (_this3.percent_ !== percent) {
        _this3.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
        _this3.percent_ = percent;
      }
      if (_this3.currentTime_ !== currentTime || _this3.duration_ !== duration5) {
        _this3.el_.setAttribute("aria-valuetext", _this3.localize("progress bar timing: currentTime={1} duration={2}", [formatTime(currentTime, duration5), formatTime(duration5, duration5)], "{1} of {2}"));
        _this3.currentTime_ = currentTime;
        _this3.duration_ = duration5;
      }
      if (_this3.bar) {
        _this3.bar.update(getBoundingClientRect(_this3.el()), _this3.getProgress());
      }
    });
    return percent;
  };
  _proto.userSeek_ = function userSeek_(ct) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
      this.player_.liveTracker.nextSeekedFromUser();
    }
    this.player_.currentTime(ct);
  };
  _proto.getCurrentTime_ = function getCurrentTime_() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  };
  _proto.getPercent = function getPercent() {
    var currentTime = this.getCurrentTime_();
    var percent;
    var liveTracker = this.player_.liveTracker;
    if (liveTracker && liveTracker.isLive()) {
      percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
      if (liveTracker.atLiveEdge()) {
        percent = 1;
      }
    } else {
      percent = currentTime / this.player_.duration();
    }
    return percent;
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }
    event.stopPropagation();
    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();
    _Slider.prototype.handleMouseDown.call(this, event);
  };
  _proto.handleMouseMove = function handleMouseMove(event, mouseDown) {
    if (mouseDown === void 0) {
      mouseDown = false;
    }
    if (!isSingleLeftClick(event)) {
      return;
    }
    if (!mouseDown && !this.player_.scrubbing()) {
      this.player_.scrubbing(true);
    }
    var newTime;
    var distance = this.calculateDistance(event);
    var liveTracker = this.player_.liveTracker;
    if (!liveTracker || !liveTracker.isLive()) {
      newTime = distance * this.player_.duration();
      if (newTime === this.player_.duration()) {
        newTime = newTime - 0.1;
      }
    } else {
      if (distance >= 0.99) {
        liveTracker.seekToLiveEdge();
        return;
      }
      var seekableStart = liveTracker.seekableStart();
      var seekableEnd = liveTracker.liveCurrentTime();
      newTime = seekableStart + distance * liveTracker.liveWindow();
      if (newTime >= seekableEnd) {
        newTime = seekableEnd;
      }
      if (newTime <= seekableStart) {
        newTime = seekableStart + 0.1;
      }
      if (newTime === Infinity) {
        return;
      }
    }
    this.userSeek_(newTime);
  };
  _proto.enable = function enable() {
    _Slider.prototype.enable.call(this);
    var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
    if (!mouseTimeDisplay) {
      return;
    }
    mouseTimeDisplay.show();
  };
  _proto.disable = function disable() {
    _Slider.prototype.disable.call(this);
    var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
    if (!mouseTimeDisplay) {
      return;
    }
    mouseTimeDisplay.hide();
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);
    if (event) {
      event.stopPropagation();
    }
    this.player_.scrubbing(false);
    this.player_.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: true
    });
    if (this.videoWasPlaying) {
      silencePromise(this.player_.play());
    } else {
      this.update_();
    }
  };
  _proto.stepForward = function stepForward() {
    this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
  };
  _proto.stepBack = function stepBack() {
    this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
  };
  _proto.handleAction = function handleAction(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    var liveTracker = this.player_.liveTracker;
    if (import_keycode.default.isEventKey(event, "Space") || import_keycode.default.isEventKey(event, "Enter")) {
      event.preventDefault();
      event.stopPropagation();
      this.handleAction(event);
    } else if (import_keycode.default.isEventKey(event, "Home")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(0);
    } else if (import_keycode.default.isEventKey(event, "End")) {
      event.preventDefault();
      event.stopPropagation();
      if (liveTracker && liveTracker.isLive()) {
        this.userSeek_(liveTracker.liveCurrentTime());
      } else {
        this.userSeek_(this.player_.duration());
      }
    } else if (/^[0-9]$/.test((0, import_keycode.default)(event))) {
      event.preventDefault();
      event.stopPropagation();
      var gotoFraction = (import_keycode.default.codes[(0, import_keycode.default)(event)] - import_keycode.default.codes["0"]) * 10 / 100;
      if (liveTracker && liveTracker.isLive()) {
        this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);
      } else {
        this.userSeek_(this.player_.duration() * gotoFraction);
      }
    } else if (import_keycode.default.isEventKey(event, "PgDn")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
    } else if (import_keycode.default.isEventKey(event, "PgUp")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
    } else {
      _Slider.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.dispose = function dispose() {
    this.disableInterval_();
    this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
    if (this.player_.liveTracker) {
      this.off(this.player_.liveTracker, "liveedgechange", this.update);
    }
    this.off(this.player_, ["playing"], this.enableIntervalHandler_);
    this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
    if ("hidden" in import_document.default && "visibilityState" in import_document.default) {
      this.off(import_document.default, "visibilitychange", this.toggleVisibility_);
    }
    _Slider.prototype.dispose.call(this);
  };
  return SeekBar2;
}(Slider);
SeekBar.prototype.options_ = {
  children: ["loadProgressBar", "playProgressBar"],
  barName: "playProgressBar"
};
if (!IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
}
Component$1.registerComponent("SeekBar", SeekBar);
var ProgressControl = function(_Component) {
  _inheritsLoose(ProgressControl2, _Component);
  function ProgressControl2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleMouseMove = throttle(bind(_assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
    _this.throttledHandleMouseSeek = throttle(bind(_assertThisInitialized(_this), _this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
    _this.handleMouseUpHandler_ = function(e) {
      return _this.handleMouseUp(e);
    };
    _this.handleMouseDownHandler_ = function(e) {
      return _this.handleMouseDown(e);
    };
    _this.enable();
    return _this;
  }
  var _proto = ProgressControl2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-progress-control vjs-control"
    });
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    var seekBar = this.getChild("seekBar");
    if (!seekBar) {
      return;
    }
    var playProgressBar = seekBar.getChild("playProgressBar");
    var mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
    if (!playProgressBar && !mouseTimeDisplay) {
      return;
    }
    var seekBarEl = seekBar.el();
    var seekBarRect = findPosition(seekBarEl);
    var seekBarPoint = getPointerPosition(seekBarEl, event).x;
    seekBarPoint = clamp(seekBarPoint, 0, 1);
    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(seekBarRect, seekBarPoint);
    }
    if (playProgressBar) {
      playProgressBar.update(seekBarRect, seekBar.getProgress());
    }
  };
  _proto.handleMouseSeek = function handleMouseSeek(event) {
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseMove(event);
    }
  };
  _proto.enabled = function enabled() {
    return this.enabled_;
  };
  _proto.disable = function disable() {
    this.children().forEach(function(child) {
      return child.disable && child.disable();
    });
    if (!this.enabled()) {
      return;
    }
    this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_);
    this.off(this.el_, "mousemove", this.handleMouseMove);
    this.removeListenersAddedOnMousedownAndTouchstart();
    this.addClass("disabled");
    this.enabled_ = false;
    if (this.player_.scrubbing()) {
      var seekBar = this.getChild("seekBar");
      this.player_.scrubbing(false);
      if (seekBar.videoWasPlaying) {
        silencePromise(this.player_.play());
      }
    }
  };
  _proto.enable = function enable() {
    this.children().forEach(function(child) {
      return child.enable && child.enable();
    });
    if (this.enabled()) {
      return;
    }
    this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_);
    this.on(this.el_, "mousemove", this.handleMouseMove);
    this.removeClass("disabled");
    this.enabled_ = true;
  };
  _proto.removeListenersAddedOnMousedownAndTouchstart = function removeListenersAddedOnMousedownAndTouchstart() {
    var doc = this.el_.ownerDocument;
    this.off(doc, "mousemove", this.throttledHandleMouseSeek);
    this.off(doc, "touchmove", this.throttledHandleMouseSeek);
    this.off(doc, "mouseup", this.handleMouseUpHandler_);
    this.off(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseDown(event);
    }
    this.on(doc, "mousemove", this.throttledHandleMouseSeek);
    this.on(doc, "touchmove", this.throttledHandleMouseSeek);
    this.on(doc, "mouseup", this.handleMouseUpHandler_);
    this.on(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseUp(event);
    }
    this.removeListenersAddedOnMousedownAndTouchstart();
  };
  return ProgressControl2;
}(Component$1);
ProgressControl.prototype.options_ = {
  children: ["seekBar"]
};
Component$1.registerComponent("ProgressControl", ProgressControl);
var PictureInPictureToggle = function(_Button) {
  _inheritsLoose(PictureInPictureToggle2, _Button);
  function PictureInPictureToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.on(player, ["enterpictureinpicture", "leavepictureinpicture"], function(e) {
      return _this.handlePictureInPictureChange(e);
    });
    _this.on(player, ["disablepictureinpicturechanged", "loadedmetadata"], function(e) {
      return _this.handlePictureInPictureEnabledChange(e);
    });
    _this.on(player, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], function() {
      var isSourceAudio = player.currentType().substring(0, 5) === "audio";
      if (isSourceAudio || player.audioPosterMode() || player.audioOnlyMode()) {
        if (player.isInPictureInPicture()) {
          player.exitPictureInPicture();
        }
        _this.hide();
      } else {
        _this.show();
      }
    });
    _this.disable();
    return _this;
  }
  var _proto = PictureInPictureToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-picture-in-picture-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handlePictureInPictureEnabledChange = function handlePictureInPictureEnabledChange() {
    if (import_document.default.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {
      this.enable();
    } else {
      this.disable();
    }
  };
  _proto.handlePictureInPictureChange = function handlePictureInPictureChange(event) {
    if (this.player_.isInPictureInPicture()) {
      this.controlText("Exit Picture-in-Picture");
    } else {
      this.controlText("Picture-in-Picture");
    }
    this.handlePictureInPictureEnabledChange();
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.isInPictureInPicture()) {
      this.player_.requestPictureInPicture();
    } else {
      this.player_.exitPictureInPicture();
    }
  };
  return PictureInPictureToggle2;
}(Button);
PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture";
Component$1.registerComponent("PictureInPictureToggle", PictureInPictureToggle);
var FullscreenToggle = function(_Button) {
  _inheritsLoose(FullscreenToggle2, _Button);
  function FullscreenToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.on(player, "fullscreenchange", function(e) {
      return _this.handleFullscreenChange(e);
    });
    if (import_document.default[player.fsApi_.fullscreenEnabled] === false) {
      _this.disable();
    }
    return _this;
  }
  var _proto = FullscreenToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-fullscreen-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleFullscreenChange = function handleFullscreenChange(event) {
    if (this.player_.isFullscreen()) {
      this.controlText("Non-Fullscreen");
    } else {
      this.controlText("Fullscreen");
    }
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };
  return FullscreenToggle2;
}(Button);
FullscreenToggle.prototype.controlText_ = "Fullscreen";
Component$1.registerComponent("FullscreenToggle", FullscreenToggle);
var checkVolumeSupport = function checkVolumeSupport2(self2, player) {
  if (player.tech_ && !player.tech_.featuresVolumeControl) {
    self2.addClass("vjs-hidden");
  }
  self2.on(player, "loadstart", function() {
    if (!player.tech_.featuresVolumeControl) {
      self2.addClass("vjs-hidden");
    } else {
      self2.removeClass("vjs-hidden");
    }
  });
};
var VolumeLevel = function(_Component) {
  _inheritsLoose(VolumeLevel2, _Component);
  function VolumeLevel2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = VolumeLevel2.prototype;
  _proto.createEl = function createEl2() {
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-level"
    });
    el.appendChild(_Component.prototype.createEl.call(this, "span", {
      className: "vjs-control-text"
    }));
    return el;
  };
  return VolumeLevel2;
}(Component$1);
Component$1.registerComponent("VolumeLevel", VolumeLevel);
var VolumeLevelTooltip = function(_Component) {
  _inheritsLoose(VolumeLevelTooltip2, _Component);
  function VolumeLevelTooltip2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = VolumeLevelTooltip2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-tooltip"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update(rangeBarRect, rangeBarPoint, vertical, content) {
    if (!vertical) {
      var tooltipRect = getBoundingClientRect(this.el_);
      var playerRect = getBoundingClientRect(this.player_.el());
      var volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
      if (!playerRect || !tooltipRect) {
        return;
      }
      var spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
      var spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
      var pullTooltipBy = tooltipRect.width / 2;
      if (spaceLeftOfPoint < pullTooltipBy) {
        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
      } else if (spaceRightOfPoint < pullTooltipBy) {
        pullTooltipBy = spaceRightOfPoint;
      }
      if (pullTooltipBy < 0) {
        pullTooltipBy = 0;
      } else if (pullTooltipBy > tooltipRect.width) {
        pullTooltipBy = tooltipRect.width;
      }
      this.el_.style.right = "-" + pullTooltipBy + "px";
    }
    this.write(content + "%");
  };
  _proto.write = function write(content) {
    textContent(this.el_, content);
  };
  _proto.updateVolume = function updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
    var _this2 = this;
    this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", function() {
      _this2.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
      if (cb) {
        cb();
      }
    });
  };
  return VolumeLevelTooltip2;
}(Component$1);
Component$1.registerComponent("VolumeLevelTooltip", VolumeLevelTooltip);
var MouseVolumeLevelDisplay = function(_Component) {
  _inheritsLoose(MouseVolumeLevelDisplay2, _Component);
  function MouseVolumeLevelDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = MouseVolumeLevelDisplay2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  };
  _proto.update = function update(rangeBarRect, rangeBarPoint, vertical) {
    var _this2 = this;
    var volume = 100 * rangeBarPoint;
    this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, function() {
      if (vertical) {
        _this2.el_.style.bottom = rangeBarRect.height * rangeBarPoint + "px";
      } else {
        _this2.el_.style.left = rangeBarRect.width * rangeBarPoint + "px";
      }
    });
  };
  return MouseVolumeLevelDisplay2;
}(Component$1);
MouseVolumeLevelDisplay.prototype.options_ = {
  children: ["volumeLevelTooltip"]
};
Component$1.registerComponent("MouseVolumeLevelDisplay", MouseVolumeLevelDisplay);
var VolumeBar = function(_Slider) {
  _inheritsLoose(VolumeBar2, _Slider);
  function VolumeBar2(player, options) {
    var _this;
    _this = _Slider.call(this, player, options) || this;
    _this.on("slideractive", function(e) {
      return _this.updateLastVolume_(e);
    });
    _this.on(player, "volumechange", function(e) {
      return _this.updateARIAAttributes(e);
    });
    player.ready(function() {
      return _this.updateARIAAttributes();
    });
    return _this;
  }
  var _proto = VolumeBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Slider.prototype.createEl.call(this, "div", {
      className: "vjs-volume-bar vjs-slider-bar"
    }, {
      "aria-label": this.localize("Volume Level"),
      "aria-live": "polite"
    });
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }
    _Slider.prototype.handleMouseDown.call(this, event);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    var mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
    if (mouseVolumeLevelDisplay) {
      var volumeBarEl = this.el();
      var volumeBarRect = getBoundingClientRect(volumeBarEl);
      var vertical = this.vertical();
      var volumeBarPoint = getPointerPosition(volumeBarEl, event);
      volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
      volumeBarPoint = clamp(volumeBarPoint, 0, 1);
      mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
    }
    if (!isSingleLeftClick(event)) {
      return;
    }
    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };
  _proto.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };
  _proto.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  };
  _proto.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };
  _proto.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };
  _proto.updateARIAAttributes = function updateARIAAttributes(event) {
    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
    this.el_.setAttribute("aria-valuenow", ariaValue);
    this.el_.setAttribute("aria-valuetext", ariaValue + "%");
  };
  _proto.volumeAsPercentage_ = function volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  };
  _proto.updateLastVolume_ = function updateLastVolume_() {
    var _this2 = this;
    var volumeBeforeDrag = this.player_.volume();
    this.one("sliderinactive", function() {
      if (_this2.player_.volume() === 0) {
        _this2.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  };
  return VolumeBar2;
}(Slider);
VolumeBar.prototype.options_ = {
  children: ["volumeLevel"],
  barName: "volumeLevel"
};
if (!IS_IOS && !IS_ANDROID) {
  VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
}
VolumeBar.prototype.playerEvent = "volumechange";
Component$1.registerComponent("VolumeBar", VolumeBar);
var VolumeControl = function(_Component) {
  _inheritsLoose(VolumeControl2, _Component);
  function VolumeControl2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    options.vertical = options.vertical || false;
    if (typeof options.volumeBar === "undefined" || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }
    _this = _Component.call(this, player, options) || this;
    checkVolumeSupport(_assertThisInitialized(_this), player);
    _this.throttledHandleMouseMove = throttle(bind(_assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
    _this.handleMouseUpHandler_ = function(e) {
      return _this.handleMouseUp(e);
    };
    _this.on("mousedown", function(e) {
      return _this.handleMouseDown(e);
    });
    _this.on("touchstart", function(e) {
      return _this.handleMouseDown(e);
    });
    _this.on("mousemove", function(e) {
      return _this.handleMouseMove(e);
    });
    _this.on(_this.volumeBar, ["focus", "slideractive"], function() {
      _this.volumeBar.addClass("vjs-slider-active");
      _this.addClass("vjs-slider-active");
      _this.trigger("slideractive");
    });
    _this.on(_this.volumeBar, ["blur", "sliderinactive"], function() {
      _this.volumeBar.removeClass("vjs-slider-active");
      _this.removeClass("vjs-slider-active");
      _this.trigger("sliderinactive");
    });
    return _this;
  }
  var _proto = VolumeControl2.prototype;
  _proto.createEl = function createEl2() {
    var orientationClass = "vjs-volume-horizontal";
    if (this.options_.vertical) {
      orientationClass = "vjs-volume-vertical";
    }
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-control vjs-control " + orientationClass
    });
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;
    this.on(doc, "mousemove", this.throttledHandleMouseMove);
    this.on(doc, "touchmove", this.throttledHandleMouseMove);
    this.on(doc, "mouseup", this.handleMouseUpHandler_);
    this.on(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;
    this.off(doc, "mousemove", this.throttledHandleMouseMove);
    this.off(doc, "touchmove", this.throttledHandleMouseMove);
    this.off(doc, "mouseup", this.handleMouseUpHandler_);
    this.off(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    this.volumeBar.handleMouseMove(event);
  };
  return VolumeControl2;
}(Component$1);
VolumeControl.prototype.options_ = {
  children: ["volumeBar"]
};
Component$1.registerComponent("VolumeControl", VolumeControl);
var checkMuteSupport = function checkMuteSupport2(self2, player) {
  if (player.tech_ && !player.tech_.featuresMuteControl) {
    self2.addClass("vjs-hidden");
  }
  self2.on(player, "loadstart", function() {
    if (!player.tech_.featuresMuteControl) {
      self2.addClass("vjs-hidden");
    } else {
      self2.removeClass("vjs-hidden");
    }
  });
};
var MuteToggle = function(_Button) {
  _inheritsLoose(MuteToggle2, _Button);
  function MuteToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    checkMuteSupport(_assertThisInitialized(_this), player);
    _this.on(player, ["loadstart", "volumechange"], function(e) {
      return _this.update(e);
    });
    return _this;
  }
  var _proto = MuteToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-mute-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    var vol = this.player_.volume();
    var lastVolume = this.player_.lastVolume_();
    if (vol === 0) {
      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  };
  _proto.update = function update(event) {
    this.updateIcon_();
    this.updateControlText_();
  };
  _proto.updateIcon_ = function updateIcon_() {
    var vol = this.player_.volume();
    var level = 3;
    if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
      this.player_.muted(this.player_.tech_.el_.muted);
    }
    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }
    for (var i = 0; i < 4; i++) {
      removeClass(this.el_, "vjs-vol-" + i);
    }
    addClass(this.el_, "vjs-vol-" + level);
  };
  _proto.updateControlText_ = function updateControlText_() {
    var soundOff = this.player_.muted() || this.player_.volume() === 0;
    var text = soundOff ? "Unmute" : "Mute";
    if (this.controlText() !== text) {
      this.controlText(text);
    }
  };
  return MuteToggle2;
}(Button);
MuteToggle.prototype.controlText_ = "Mute";
Component$1.registerComponent("MuteToggle", MuteToggle);
var VolumePanel = function(_Component) {
  _inheritsLoose(VolumePanel2, _Component);
  function VolumePanel2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (typeof options.inline !== "undefined") {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }
    if (typeof options.volumeControl === "undefined" || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }
    _this = _Component.call(this, player, options) || this;
    _this.handleKeyPressHandler_ = function(e) {
      return _this.handleKeyPress(e);
    };
    _this.on(player, ["loadstart"], function(e) {
      return _this.volumePanelState_(e);
    });
    _this.on(_this.muteToggle, "keyup", function(e) {
      return _this.handleKeyPress(e);
    });
    _this.on(_this.volumeControl, "keyup", function(e) {
      return _this.handleVolumeControlKeyUp(e);
    });
    _this.on("keydown", function(e) {
      return _this.handleKeyPress(e);
    });
    _this.on("mouseover", function(e) {
      return _this.handleMouseOver(e);
    });
    _this.on("mouseout", function(e) {
      return _this.handleMouseOut(e);
    });
    _this.on(_this.volumeControl, ["slideractive"], _this.sliderActive_);
    _this.on(_this.volumeControl, ["sliderinactive"], _this.sliderInactive_);
    return _this;
  }
  var _proto = VolumePanel2.prototype;
  _proto.sliderActive_ = function sliderActive_() {
    this.addClass("vjs-slider-active");
  };
  _proto.sliderInactive_ = function sliderInactive_() {
    this.removeClass("vjs-slider-active");
  };
  _proto.volumePanelState_ = function volumePanelState_() {
    if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) {
      this.addClass("vjs-hidden");
    }
    if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) {
      this.addClass("vjs-mute-toggle-only");
    }
  };
  _proto.createEl = function createEl2() {
    var orientationClass = "vjs-volume-panel-horizontal";
    if (!this.options_.inline) {
      orientationClass = "vjs-volume-panel-vertical";
    }
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-panel vjs-control " + orientationClass
    });
  };
  _proto.dispose = function dispose() {
    this.handleMouseOut();
    _Component.prototype.dispose.call(this);
  };
  _proto.handleVolumeControlKeyUp = function handleVolumeControlKeyUp(event) {
    if (import_keycode.default.isEventKey(event, "Esc")) {
      this.muteToggle.focus();
    }
  };
  _proto.handleMouseOver = function handleMouseOver(event) {
    this.addClass("vjs-hover");
    on(import_document.default, "keyup", this.handleKeyPressHandler_);
  };
  _proto.handleMouseOut = function handleMouseOut(event) {
    this.removeClass("vjs-hover");
    off(import_document.default, "keyup", this.handleKeyPressHandler_);
  };
  _proto.handleKeyPress = function handleKeyPress(event) {
    if (import_keycode.default.isEventKey(event, "Esc")) {
      this.handleMouseOut();
    }
  };
  return VolumePanel2;
}(Component$1);
VolumePanel.prototype.options_ = {
  children: ["muteToggle", "volumeControl"]
};
Component$1.registerComponent("VolumePanel", VolumePanel);
var Menu = function(_Component) {
  _inheritsLoose(Menu2, _Component);
  function Menu2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    if (options) {
      _this.menuButton_ = options.menuButton;
    }
    _this.focusedChild_ = -1;
    _this.on("keydown", function(e) {
      return _this.handleKeyDown(e);
    });
    _this.boundHandleBlur_ = function(e) {
      return _this.handleBlur(e);
    };
    _this.boundHandleTapClick_ = function(e) {
      return _this.handleTapClick(e);
    };
    return _this;
  }
  var _proto = Menu2.prototype;
  _proto.addEventListenerForItem = function addEventListenerForItem(component) {
    if (!(component instanceof Component$1)) {
      return;
    }
    this.on(component, "blur", this.boundHandleBlur_);
    this.on(component, ["tap", "click"], this.boundHandleTapClick_);
  };
  _proto.removeEventListenerForItem = function removeEventListenerForItem(component) {
    if (!(component instanceof Component$1)) {
      return;
    }
    this.off(component, "blur", this.boundHandleBlur_);
    this.off(component, ["tap", "click"], this.boundHandleTapClick_);
  };
  _proto.removeChild = function removeChild(component) {
    if (typeof component === "string") {
      component = this.getChild(component);
    }
    this.removeEventListenerForItem(component);
    _Component.prototype.removeChild.call(this, component);
  };
  _proto.addItem = function addItem(component) {
    var childComponent = this.addChild(component);
    if (childComponent) {
      this.addEventListenerForItem(childComponent);
    }
  };
  _proto.createEl = function createEl$1() {
    var contentElType = this.options_.contentElType || "ul";
    this.contentEl_ = createEl(contentElType, {
      className: "vjs-menu-content"
    });
    this.contentEl_.setAttribute("role", "menu");
    var el = _Component.prototype.createEl.call(this, "div", {
      append: this.contentEl_,
      className: "vjs-menu"
    });
    el.appendChild(this.contentEl_);
    on(el, "click", function(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    return el;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.boundHandleBlur_ = null;
    this.boundHandleTapClick_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.handleBlur = function handleBlur(event) {
    var relatedTarget = event.relatedTarget || import_document.default.activeElement;
    if (!this.children().some(function(element) {
      return element.el() === relatedTarget;
    })) {
      var btn = this.menuButton_;
      if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
        btn.unpressButton();
      }
    }
  };
  _proto.handleTapClick = function handleTapClick(event) {
    if (this.menuButton_) {
      this.menuButton_.unpressButton();
      var childComponents = this.children();
      if (!Array.isArray(childComponents)) {
        return;
      }
      var foundComponent = childComponents.filter(function(component) {
        return component.el() === event.target;
      })[0];
      if (!foundComponent) {
        return;
      }
      if (foundComponent.name() !== "CaptionSettingsMenuItem") {
        this.menuButton_.focus();
      }
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Left") || import_keycode.default.isEventKey(event, "Down")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepForward();
    } else if (import_keycode.default.isEventKey(event, "Right") || import_keycode.default.isEventKey(event, "Up")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepBack();
    }
  };
  _proto.stepForward = function stepForward() {
    var stepChild = 0;
    if (this.focusedChild_ !== void 0) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };
  _proto.stepBack = function stepBack() {
    var stepChild = 0;
    if (this.focusedChild_ !== void 0) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };
  _proto.focus = function focus(item) {
    if (item === void 0) {
      item = 0;
    }
    var children = this.children().slice();
    var haveTitle = children.length && children[0].hasClass("vjs-menu-title");
    if (haveTitle) {
      children.shift();
    }
    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }
      this.focusedChild_ = item;
      children[item].el_.focus();
    }
  };
  return Menu2;
}(Component$1);
Component$1.registerComponent("Menu", Menu);
var MenuButton = function(_Component) {
  _inheritsLoose(MenuButton2, _Component);
  function MenuButton2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Component.call(this, player, options) || this;
    _this.menuButton_ = new Button(player, options);
    _this.menuButton_.controlText(_this.controlText_);
    _this.menuButton_.el_.setAttribute("aria-haspopup", "true");
    var buttonClass = Button.prototype.buildCSSClass();
    _this.menuButton_.el_.className = _this.buildCSSClass() + " " + buttonClass;
    _this.menuButton_.removeClass("vjs-control");
    _this.addChild(_this.menuButton_);
    _this.update();
    _this.enabled_ = true;
    var handleClick = function handleClick2(e) {
      return _this.handleClick(e);
    };
    _this.handleMenuKeyUp_ = function(e) {
      return _this.handleMenuKeyUp(e);
    };
    _this.on(_this.menuButton_, "tap", handleClick);
    _this.on(_this.menuButton_, "click", handleClick);
    _this.on(_this.menuButton_, "keydown", function(e) {
      return _this.handleKeyDown(e);
    });
    _this.on(_this.menuButton_, "mouseenter", function() {
      _this.addClass("vjs-hover");
      _this.menu.show();
      on(import_document.default, "keyup", _this.handleMenuKeyUp_);
    });
    _this.on("mouseleave", function(e) {
      return _this.handleMouseLeave(e);
    });
    _this.on("keydown", function(e) {
      return _this.handleSubmenuKeyDown(e);
    });
    return _this;
  }
  var _proto = MenuButton2.prototype;
  _proto.update = function update() {
    var menu = this.createMenu();
    if (this.menu) {
      this.menu.dispose();
      this.removeChild(this.menu);
    }
    this.menu = menu;
    this.addChild(menu);
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute("aria-expanded", "false");
    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
      this.menu.contentEl_.removeAttribute("role");
    } else {
      this.show();
      this.menu.contentEl_.setAttribute("role", "menu");
    }
  };
  _proto.createMenu = function createMenu() {
    var menu = new Menu(this.player_, {
      menuButton: this
    });
    this.hideThreshold_ = 0;
    if (this.options_.title) {
      var titleEl = createEl("li", {
        className: "vjs-menu-title",
        textContent: toTitleCase$1(this.options_.title),
        tabIndex: -1
      });
      var titleComponent = new Component$1(this.player_, {
        el: titleEl
      });
      menu.addItem(titleComponent);
    }
    this.items = this.createItems();
    if (this.items) {
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }
    return menu;
  };
  _proto.createItems = function createItems() {
  };
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: this.buildWrapperCSSClass()
    }, {});
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    var menuButtonClass = "vjs-menu-button";
    if (this.options_.inline === true) {
      menuButtonClass += "-inline";
    } else {
      menuButtonClass += "-popup";
    }
    var buttonClass = Button.prototype.buildCSSClass();
    return "vjs-menu-button " + menuButtonClass + " " + buttonClass + " " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = "vjs-menu-button";
    if (this.options_.inline === true) {
      menuButtonClass += "-inline";
    } else {
      menuButtonClass += "-popup";
    }
    return "vjs-menu-button " + menuButtonClass + " " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.controlText = function controlText(text, el) {
    if (el === void 0) {
      el = this.menuButton_.el();
    }
    return this.menuButton_.controlText(text, el);
  };
  _proto.dispose = function dispose() {
    this.handleMouseLeave();
    _Component.prototype.dispose.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };
  _proto.handleMouseLeave = function handleMouseLeave(event) {
    this.removeClass("vjs-hover");
    off(import_document.default, "keyup", this.handleMenuKeyUp_);
  };
  _proto.focus = function focus() {
    this.menuButton_.focus();
  };
  _proto.blur = function blur() {
    this.menuButton_.blur();
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Esc") || import_keycode.default.isEventKey(event, "Tab")) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      if (!import_keycode.default.isEventKey(event, "Tab")) {
        event.preventDefault();
        this.menuButton_.focus();
      }
    } else if (import_keycode.default.isEventKey(event, "Up") || import_keycode.default.isEventKey(event, "Down")) {
      if (!this.buttonPressed_) {
        event.preventDefault();
        this.pressButton();
      }
    }
  };
  _proto.handleMenuKeyUp = function handleMenuKeyUp(event) {
    if (import_keycode.default.isEventKey(event, "Esc") || import_keycode.default.isEventKey(event, "Tab")) {
      this.removeClass("vjs-hover");
    }
  };
  _proto.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {
    this.handleSubmenuKeyDown(event);
  };
  _proto.handleSubmenuKeyDown = function handleSubmenuKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Esc") || import_keycode.default.isEventKey(event, "Tab")) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      if (!import_keycode.default.isEventKey(event, "Tab")) {
        event.preventDefault();
        this.menuButton_.focus();
      }
    }
  };
  _proto.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.show();
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute("aria-expanded", "true");
      if (IS_IOS && isInFrame()) {
        return;
      }
      this.menu.focus();
    }
  };
  _proto.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menu.hide();
      this.menuButton_.el_.setAttribute("aria-expanded", "false");
    }
  };
  _proto.disable = function disable() {
    this.unpressButton();
    this.enabled_ = false;
    this.addClass("vjs-disabled");
    this.menuButton_.disable();
  };
  _proto.enable = function enable() {
    this.enabled_ = true;
    this.removeClass("vjs-disabled");
    this.menuButton_.enable();
  };
  return MenuButton2;
}(Component$1);
Component$1.registerComponent("MenuButton", MenuButton);
var TrackButton = function(_MenuButton) {
  _inheritsLoose(TrackButton2, _MenuButton);
  function TrackButton2(player, options) {
    var _this;
    var tracks = options.tracks;
    _this = _MenuButton.call(this, player, options) || this;
    if (_this.items.length <= 1) {
      _this.hide();
    }
    if (!tracks) {
      return _assertThisInitialized(_this);
    }
    var updateHandler = bind(_assertThisInitialized(_this), _this.update);
    tracks.addEventListener("removetrack", updateHandler);
    tracks.addEventListener("addtrack", updateHandler);
    tracks.addEventListener("labelchange", updateHandler);
    _this.player_.on("ready", updateHandler);
    _this.player_.on("dispose", function() {
      tracks.removeEventListener("removetrack", updateHandler);
      tracks.removeEventListener("addtrack", updateHandler);
      tracks.removeEventListener("labelchange", updateHandler);
    });
    return _this;
  }
  return TrackButton2;
}(MenuButton);
Component$1.registerComponent("TrackButton", TrackButton);
var MenuKeys = ["Tab", "Esc", "Up", "Down", "Right", "Left"];
var MenuItem = function(_ClickableComponent) {
  _inheritsLoose(MenuItem2, _ClickableComponent);
  function MenuItem2(player, options) {
    var _this;
    _this = _ClickableComponent.call(this, player, options) || this;
    _this.selectable = options.selectable;
    _this.isSelected_ = options.selected || false;
    _this.multiSelectable = options.multiSelectable;
    _this.selected(_this.isSelected_);
    if (_this.selectable) {
      if (_this.multiSelectable) {
        _this.el_.setAttribute("role", "menuitemcheckbox");
      } else {
        _this.el_.setAttribute("role", "menuitemradio");
      }
    } else {
      _this.el_.setAttribute("role", "menuitem");
    }
    return _this;
  }
  var _proto = MenuItem2.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    this.nonIconControl = true;
    var el = _ClickableComponent.prototype.createEl.call(this, "li", assign({
      className: "vjs-menu-item",
      tabIndex: -1
    }, props), attrs);
    el.replaceChild(createEl("span", {
      className: "vjs-menu-item-text",
      textContent: this.localize(this.options_.label)
    }), el.querySelector(".vjs-icon-placeholder"));
    return el;
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (!MenuKeys.some(function(key) {
      return import_keycode.default.isEventKey(event, key);
    })) {
      _ClickableComponent.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.handleClick = function handleClick(event) {
    this.selected(true);
  };
  _proto.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass("vjs-selected");
        this.el_.setAttribute("aria-checked", "true");
        this.controlText(", selected");
        this.isSelected_ = true;
      } else {
        this.removeClass("vjs-selected");
        this.el_.setAttribute("aria-checked", "false");
        this.controlText("");
        this.isSelected_ = false;
      }
    }
  };
  return MenuItem2;
}(ClickableComponent);
Component$1.registerComponent("MenuItem", MenuItem);
var TextTrackMenuItem = function(_MenuItem) {
  _inheritsLoose(TextTrackMenuItem2, _MenuItem);
  function TextTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var tracks = player.textTracks();
    options.label = track.label || track.language || "Unknown";
    options.selected = track.mode === "showing";
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.kinds = (options.kinds || [options.kind || _this.track.kind]).filter(Boolean);
    var changeHandler = function changeHandler2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this.handleTracksChange.apply(_assertThisInitialized(_this), args);
    };
    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this.handleSelectedLanguageChange.apply(_assertThisInitialized(_this), args);
    };
    player.on(["loadstart", "texttrackchange"], changeHandler);
    tracks.addEventListener("change", changeHandler);
    tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
    _this.on("dispose", function() {
      player.off(["loadstart", "texttrackchange"], changeHandler);
      tracks.removeEventListener("change", changeHandler);
      tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
    });
    if (tracks.onchange === void 0) {
      var event;
      _this.on(["tap", "click"], function() {
        if (typeof import_window6.default.Event !== "object") {
          try {
            event = new import_window6.default.Event("change");
          } catch (err) {
          }
        }
        if (!event) {
          event = import_document.default.createEvent("Event");
          event.initEvent("change", true, true);
        }
        tracks.dispatchEvent(event);
      });
    }
    _this.handleTracksChange();
    return _this;
  }
  var _proto = TextTrackMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    var referenceTrack = this.track;
    var tracks = this.player_.textTracks();
    _MenuItem.prototype.handleClick.call(this, event);
    if (!tracks) {
      return;
    }
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      if (this.kinds.indexOf(track.kind) === -1) {
        continue;
      }
      if (track === referenceTrack) {
        if (track.mode !== "showing") {
          track.mode = "showing";
        }
      } else if (track.mode !== "disabled") {
        track.mode = "disabled";
      }
    }
  };
  _proto.handleTracksChange = function handleTracksChange(event) {
    var shouldBeSelected = this.track.mode === "showing";
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  };
  _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    if (this.track.mode === "showing") {
      var selectedLanguage = this.player_.cache_.selectedLanguage;
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }
      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  };
  _proto.dispose = function dispose() {
    this.track = null;
    _MenuItem.prototype.dispose.call(this);
  };
  return TextTrackMenuItem2;
}(MenuItem);
Component$1.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
var OffTextTrackMenuItem = function(_TextTrackMenuItem) {
  _inheritsLoose(OffTextTrackMenuItem2, _TextTrackMenuItem);
  function OffTextTrackMenuItem2(player, options) {
    options.track = {
      player,
      // it is no longer necessary to store `kind` or `kinds` on the track itself
      // since they are now stored in the `kinds` property of all instances of
      // TextTrackMenuItem, but this will remain for backwards compatibility
      kind: options.kind,
      kinds: options.kinds,
      "default": false,
      mode: "disabled"
    };
    if (!options.kinds) {
      options.kinds = [options.kind];
    }
    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(" and ") + " off";
    }
    options.selectable = true;
    options.multiSelectable = false;
    return _TextTrackMenuItem.call(this, player, options) || this;
  }
  var _proto = OffTextTrackMenuItem2.prototype;
  _proto.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var shouldBeSelected = true;
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];
      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === "showing") {
        shouldBeSelected = false;
        break;
      }
    }
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  };
  _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    var tracks = this.player().textTracks();
    var allHidden = true;
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];
      if (["captions", "descriptions", "subtitles"].indexOf(track.kind) > -1 && track.mode === "showing") {
        allHidden = false;
        break;
      }
    }
    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  };
  return OffTextTrackMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
var TextTrackButton = function(_TrackButton) {
  _inheritsLoose(TextTrackButton2, _TrackButton);
  function TextTrackButton2(player, options) {
    if (options === void 0) {
      options = {};
    }
    options.tracks = player.textTracks();
    return _TrackButton.call(this, player, options) || this;
  }
  var _proto = TextTrackButton2.prototype;
  _proto.createItems = function createItems(items, TrackMenuItem) {
    if (items === void 0) {
      items = [];
    }
    if (TrackMenuItem === void 0) {
      TrackMenuItem = TextTrackMenuItem;
    }
    var label;
    if (this.label_) {
      label = this.label_ + " off";
    }
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label
    }));
    this.hideThreshold_ += 1;
    var tracks = this.player_.textTracks();
    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      if (this.kinds_.indexOf(track.kind) > -1) {
        var item = new TrackMenuItem(this.player_, {
          track,
          kinds: this.kinds_,
          kind: this.kind_,
          // MenuItem is selectable
          selectable: true,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: false
        });
        item.addClass("vjs-" + track.kind + "-menu-item");
        items.push(item);
      }
    }
    return items;
  };
  return TextTrackButton2;
}(TrackButton);
Component$1.registerComponent("TextTrackButton", TextTrackButton);
var ChaptersTrackMenuItem = function(_MenuItem) {
  _inheritsLoose(ChaptersTrackMenuItem2, _MenuItem);
  function ChaptersTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();
    options.selectable = true;
    options.multiSelectable = false;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.cue = cue;
    return _this;
  }
  var _proto = ChaptersTrackMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
  };
  return ChaptersTrackMenuItem2;
}(MenuItem);
Component$1.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
var ChaptersButton = function(_TextTrackButton) {
  _inheritsLoose(ChaptersButton2, _TextTrackButton);
  function ChaptersButton2(player, options, ready) {
    var _this;
    _this = _TextTrackButton.call(this, player, options, ready) || this;
    _this.selectCurrentItem_ = function() {
      _this.items.forEach(function(item) {
        item.selected(_this.track_.activeCues[0] === item.cue);
      });
    };
    return _this;
  }
  var _proto = ChaptersButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-chapters-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-chapters-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.update = function update(event) {
    if (event && event.track && event.track.kind !== "chapters") {
      return;
    }
    var track = this.findChaptersTrack();
    if (track !== this.track_) {
      this.setTrack(track);
      _TextTrackButton.prototype.update.call(this);
    } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {
      _TextTrackButton.prototype.update.call(this);
    }
  };
  _proto.setTrack = function setTrack(track) {
    if (this.track_ === track) {
      return;
    }
    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }
    if (this.track_) {
      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
      }
      this.track_.removeEventListener("cuechange", this.selectCurrentItem_);
      this.track_ = null;
    }
    this.track_ = track;
    if (this.track_) {
      this.track_.mode = "hidden";
      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
      if (_remoteTextTrackEl) {
        _remoteTextTrackEl.addEventListener("load", this.updateHandler_);
      }
      this.track_.addEventListener("cuechange", this.selectCurrentItem_);
    }
  };
  _proto.findChaptersTrack = function findChaptersTrack() {
    var tracks = this.player_.textTracks() || [];
    for (var i = tracks.length - 1; i >= 0; i--) {
      var track = tracks[i];
      if (track.kind === this.kind_) {
        return track;
      }
    }
  };
  _proto.getMenuCaption = function getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase$1(this.kind_));
  };
  _proto.createMenu = function createMenu() {
    this.options_.title = this.getMenuCaption();
    return _TextTrackButton.prototype.createMenu.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!this.track_) {
      return items;
    }
    var cues = this.track_.cues;
    if (!cues) {
      return items;
    }
    for (var i = 0, l = cues.length; i < l; i++) {
      var cue = cues[i];
      var mi = new ChaptersTrackMenuItem(this.player_, {
        track: this.track_,
        cue
      });
      items.push(mi);
    }
    return items;
  };
  return ChaptersButton2;
}(TextTrackButton);
ChaptersButton.prototype.kind_ = "chapters";
ChaptersButton.prototype.controlText_ = "Chapters";
Component$1.registerComponent("ChaptersButton", ChaptersButton);
var DescriptionsButton = function(_TextTrackButton) {
  _inheritsLoose(DescriptionsButton2, _TextTrackButton);
  function DescriptionsButton2(player, options, ready) {
    var _this;
    _this = _TextTrackButton.call(this, player, options, ready) || this;
    var tracks = player.textTracks();
    var changeHandler = bind(_assertThisInitialized(_this), _this.handleTracksChange);
    tracks.addEventListener("change", changeHandler);
    _this.on("dispose", function() {
      tracks.removeEventListener("change", changeHandler);
    });
    return _this;
  }
  var _proto = DescriptionsButton2.prototype;
  _proto.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];
      if (track.kind !== this.kind_ && track.mode === "showing") {
        disabled = true;
        break;
      }
    }
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-descriptions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-descriptions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  return DescriptionsButton2;
}(TextTrackButton);
DescriptionsButton.prototype.kind_ = "descriptions";
DescriptionsButton.prototype.controlText_ = "Descriptions";
Component$1.registerComponent("DescriptionsButton", DescriptionsButton);
var SubtitlesButton = function(_TextTrackButton) {
  _inheritsLoose(SubtitlesButton2, _TextTrackButton);
  function SubtitlesButton2(player, options, ready) {
    return _TextTrackButton.call(this, player, options, ready) || this;
  }
  var _proto = SubtitlesButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-subtitles-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-subtitles-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  return SubtitlesButton2;
}(TextTrackButton);
SubtitlesButton.prototype.kind_ = "subtitles";
SubtitlesButton.prototype.controlText_ = "Subtitles";
Component$1.registerComponent("SubtitlesButton", SubtitlesButton);
var CaptionSettingsMenuItem = function(_TextTrackMenuItem) {
  _inheritsLoose(CaptionSettingsMenuItem2, _TextTrackMenuItem);
  function CaptionSettingsMenuItem2(player, options) {
    var _this;
    options.track = {
      player,
      kind: options.kind,
      label: options.kind + " settings",
      selectable: false,
      "default": false,
      mode: "disabled"
    };
    options.selectable = false;
    options.name = "CaptionSettingsMenuItem";
    _this = _TextTrackMenuItem.call(this, player, options) || this;
    _this.addClass("vjs-texttrack-settings");
    _this.controlText(", opens " + options.kind + " settings dialog");
    return _this;
  }
  var _proto = CaptionSettingsMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    this.player().getChild("textTrackSettings").open();
  };
  return CaptionSettingsMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
var CaptionsButton = function(_TextTrackButton) {
  _inheritsLoose(CaptionsButton2, _TextTrackButton);
  function CaptionsButton2(player, options, ready) {
    return _TextTrackButton.call(this, player, options, ready) || this;
  }
  var _proto = CaptionsButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-captions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-captions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
      items.push(new CaptionSettingsMenuItem(this.player_, {
        kind: this.kind_
      }));
      this.hideThreshold_ += 1;
    }
    return _TextTrackButton.prototype.createItems.call(this, items);
  };
  return CaptionsButton2;
}(TextTrackButton);
CaptionsButton.prototype.kind_ = "captions";
CaptionsButton.prototype.controlText_ = "Captions";
Component$1.registerComponent("CaptionsButton", CaptionsButton);
var SubsCapsMenuItem = function(_TextTrackMenuItem) {
  _inheritsLoose(SubsCapsMenuItem2, _TextTrackMenuItem);
  function SubsCapsMenuItem2() {
    return _TextTrackMenuItem.apply(this, arguments) || this;
  }
  var _proto = SubsCapsMenuItem2.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    var el = _TextTrackMenuItem.prototype.createEl.call(this, type2, props, attrs);
    var parentSpan = el.querySelector(".vjs-menu-item-text");
    if (this.options_.track.kind === "captions") {
      parentSpan.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
      parentSpan.appendChild(createEl("span", {
        className: "vjs-control-text",
        // space added as the text will visually flow with the
        // label
        textContent: " " + this.localize("Captions")
      }));
    }
    return el;
  };
  return SubsCapsMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
var SubsCapsButton = function(_TextTrackButton) {
  _inheritsLoose(SubsCapsButton2, _TextTrackButton);
  function SubsCapsButton2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _TextTrackButton.call(this, player, options) || this;
    _this.label_ = "subtitles";
    if (["en", "en-us", "en-ca", "fr-ca"].indexOf(_this.player_.language_) > -1) {
      _this.label_ = "captions";
    }
    _this.menuButton_.controlText(toTitleCase$1(_this.label_));
    return _this;
  }
  var _proto = SubsCapsButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
      items.push(new CaptionSettingsMenuItem(this.player_, {
        kind: this.label_
      }));
      this.hideThreshold_ += 1;
    }
    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
    return items;
  };
  return SubsCapsButton2;
}(TextTrackButton);
SubsCapsButton.prototype.kinds_ = ["captions", "subtitles"];
SubsCapsButton.prototype.controlText_ = "Subtitles";
Component$1.registerComponent("SubsCapsButton", SubsCapsButton);
var AudioTrackMenuItem = function(_MenuItem) {
  _inheritsLoose(AudioTrackMenuItem2, _MenuItem);
  function AudioTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var tracks = player.audioTracks();
    options.label = track.label || track.language || "Unknown";
    options.selected = track.enabled;
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.addClass("vjs-" + track.kind + "-menu-item");
    var changeHandler = function changeHandler2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this.handleTracksChange.apply(_assertThisInitialized(_this), args);
    };
    tracks.addEventListener("change", changeHandler);
    _this.on("dispose", function() {
      tracks.removeEventListener("change", changeHandler);
    });
    return _this;
  }
  var _proto = AudioTrackMenuItem2.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    var el = _MenuItem.prototype.createEl.call(this, type2, props, attrs);
    var parentSpan = el.querySelector(".vjs-menu-item-text");
    if (this.options_.track.kind === "main-desc") {
      parentSpan.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
      parentSpan.appendChild(createEl("span", {
        className: "vjs-control-text",
        textContent: " " + this.localize("Descriptions")
      }));
    }
    return el;
  };
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this, event);
    this.track.enabled = true;
    if (this.player_.tech_.featuresNativeAudioTracks) {
      var tracks = this.player_.audioTracks();
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track === this.track) {
          continue;
        }
        track.enabled = track === this.track;
      }
    }
  };
  _proto.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };
  return AudioTrackMenuItem2;
}(MenuItem);
Component$1.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
var AudioTrackButton = function(_TrackButton) {
  _inheritsLoose(AudioTrackButton2, _TrackButton);
  function AudioTrackButton2(player, options) {
    if (options === void 0) {
      options = {};
    }
    options.tracks = player.audioTracks();
    return _TrackButton.call(this, player, options) || this;
  }
  var _proto = AudioTrackButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-audio-button " + _TrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-audio-button " + _TrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems(items) {
    if (items === void 0) {
      items = [];
    }
    this.hideThreshold_ = 1;
    var tracks = this.player_.audioTracks();
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      items.push(new AudioTrackMenuItem(this.player_, {
        track,
        // MenuItem is selectable
        selectable: true,
        // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
        multiSelectable: false
      }));
    }
    return items;
  };
  return AudioTrackButton2;
}(TrackButton);
AudioTrackButton.prototype.controlText_ = "Audio Track";
Component$1.registerComponent("AudioTrackButton", AudioTrackButton);
var PlaybackRateMenuItem = function(_MenuItem) {
  _inheritsLoose(PlaybackRateMenuItem2, _MenuItem);
  function PlaybackRateMenuItem2(player, options) {
    var _this;
    var label = options.rate;
    var rate = parseFloat(label, 10);
    options.label = label;
    options.selected = rate === player.playbackRate();
    options.selectable = true;
    options.multiSelectable = false;
    _this = _MenuItem.call(this, player, options) || this;
    _this.label = label;
    _this.rate = rate;
    _this.on(player, "ratechange", function(e) {
      return _this.update(e);
    });
    return _this;
  }
  var _proto = PlaybackRateMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };
  _proto.update = function update(event) {
    this.selected(this.player().playbackRate() === this.rate);
  };
  return PlaybackRateMenuItem2;
}(MenuItem);
PlaybackRateMenuItem.prototype.contentElType = "button";
Component$1.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
var PlaybackRateMenuButton = function(_MenuButton) {
  _inheritsLoose(PlaybackRateMenuButton2, _MenuButton);
  function PlaybackRateMenuButton2(player, options) {
    var _this;
    _this = _MenuButton.call(this, player, options) || this;
    _this.menuButton_.el_.setAttribute("aria-describedby", _this.labelElId_);
    _this.updateVisibility();
    _this.updateLabel();
    _this.on(player, "loadstart", function(e) {
      return _this.updateVisibility(e);
    });
    _this.on(player, "ratechange", function(e) {
      return _this.updateLabel(e);
    });
    _this.on(player, "playbackrateschange", function(e) {
      return _this.handlePlaybackRateschange(e);
    });
    return _this;
  }
  var _proto = PlaybackRateMenuButton2.prototype;
  _proto.createEl = function createEl$1() {
    var el = _MenuButton.prototype.createEl.call(this);
    this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_;
    this.labelEl_ = createEl("div", {
      className: "vjs-playback-rate-value",
      id: this.labelElId_,
      textContent: "1x"
    });
    el.appendChild(this.labelEl_);
    return el;
  };
  _proto.dispose = function dispose() {
    this.labelEl_ = null;
    _MenuButton.prototype.dispose.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-playback-rate " + _MenuButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-playback-rate " + _MenuButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var rates = this.playbackRates();
    var items = [];
    for (var i = rates.length - 1; i >= 0; i--) {
      items.push(new PlaybackRateMenuItem(this.player(), {
        rate: rates[i] + "x"
      }));
    }
    return items;
  };
  _proto.updateARIAAttributes = function updateARIAAttributes() {
    this.el().setAttribute("aria-valuenow", this.player().playbackRate());
  };
  _proto.handleClick = function handleClick(event) {
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();
    var currentIndex = rates.indexOf(currentRate);
    var newIndex = (currentIndex + 1) % rates.length;
    this.player().playbackRate(rates[newIndex]);
  };
  _proto.handlePlaybackRateschange = function handlePlaybackRateschange(event) {
    this.update();
  };
  _proto.playbackRates = function playbackRates() {
    var player = this.player();
    return player.playbackRates && player.playbackRates() || [];
  };
  _proto.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  };
  _proto.updateVisibility = function updateVisibility(event) {
    if (this.playbackRateSupported()) {
      this.removeClass("vjs-hidden");
    } else {
      this.addClass("vjs-hidden");
    }
  };
  _proto.updateLabel = function updateLabel(event) {
    if (this.playbackRateSupported()) {
      this.labelEl_.textContent = this.player().playbackRate() + "x";
    }
  };
  return PlaybackRateMenuButton2;
}(MenuButton);
PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
Component$1.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
var Spacer = function(_Component) {
  _inheritsLoose(Spacer2, _Component);
  function Spacer2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = Spacer2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-spacer " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.createEl = function createEl2(tag, props, attributes) {
    if (tag === void 0) {
      tag = "div";
    }
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    if (!props.className) {
      props.className = this.buildCSSClass();
    }
    return _Component.prototype.createEl.call(this, tag, props, attributes);
  };
  return Spacer2;
}(Component$1);
Component$1.registerComponent("Spacer", Spacer);
var CustomControlSpacer = function(_Spacer) {
  _inheritsLoose(CustomControlSpacer2, _Spacer);
  function CustomControlSpacer2() {
    return _Spacer.apply(this, arguments) || this;
  }
  var _proto = CustomControlSpacer2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-custom-control-spacer " + _Spacer.prototype.buildCSSClass.call(this);
  };
  _proto.createEl = function createEl2() {
    return _Spacer.prototype.createEl.call(this, "div", {
      className: this.buildCSSClass(),
      // No-flex/table-cell mode requires there be some content
      // in the cell to fill the remaining space of the table.
      textContent: " "
    });
  };
  return CustomControlSpacer2;
}(Spacer);
Component$1.registerComponent("CustomControlSpacer", CustomControlSpacer);
var ControlBar = function(_Component) {
  _inheritsLoose(ControlBar2, _Component);
  function ControlBar2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = ControlBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-control-bar",
      dir: "ltr"
    });
  };
  return ControlBar2;
}(Component$1);
ControlBar.prototype.options_ = {
  children: ["playToggle", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle"]
};
if ("exitPictureInPicture" in import_document.default) {
  ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, "pictureInPictureToggle");
}
Component$1.registerComponent("ControlBar", ControlBar);
var ErrorDisplay = function(_ModalDialog) {
  _inheritsLoose(ErrorDisplay2, _ModalDialog);
  function ErrorDisplay2(player, options) {
    var _this;
    _this = _ModalDialog.call(this, player, options) || this;
    _this.on(player, "error", function(e) {
      return _this.open(e);
    });
    return _this;
  }
  var _proto = ErrorDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-error-display " + _ModalDialog.prototype.buildCSSClass.call(this);
  };
  _proto.content = function content() {
    var error = this.player().error();
    return error ? this.localize(error.message) : "";
  };
  return ErrorDisplay2;
}(ModalDialog);
ErrorDisplay.prototype.options_ = _extends({}, ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});
Component$1.registerComponent("ErrorDisplay", ErrorDisplay);
var LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings";
var COLOR_BLACK = ["#000", "Black"];
var COLOR_BLUE = ["#00F", "Blue"];
var COLOR_CYAN = ["#0FF", "Cyan"];
var COLOR_GREEN = ["#0F0", "Green"];
var COLOR_MAGENTA = ["#F0F", "Magenta"];
var COLOR_RED = ["#F00", "Red"];
var COLOR_WHITE = ["#FFF", "White"];
var COLOR_YELLOW = ["#FF0", "Yellow"];
var OPACITY_OPAQUE = ["1", "Opaque"];
var OPACITY_SEMI = ["0.5", "Semi-Transparent"];
var OPACITY_TRANS = ["0", "Transparent"];
var selectConfigs = {
  backgroundColor: {
    selector: ".vjs-bg-color > select",
    id: "captions-background-color-%s",
    label: "Color",
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },
  backgroundOpacity: {
    selector: ".vjs-bg-opacity > select",
    id: "captions-background-opacity-%s",
    label: "Transparency",
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
  },
  color: {
    selector: ".vjs-fg-color > select",
    id: "captions-foreground-color-%s",
    label: "Color",
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },
  edgeStyle: {
    selector: ".vjs-edge-style > select",
    id: "%s",
    label: "Text Edge Style",
    options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Dropshadow"]]
  },
  fontFamily: {
    selector: ".vjs-font-family > select",
    id: "captions-font-family-%s",
    label: "Font Family",
    options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
  },
  fontPercent: {
    selector: ".vjs-font-percent > select",
    id: "captions-font-size-%s",
    label: "Font Size",
    options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
    "default": 2,
    parser: function parser5(v2) {
      return v2 === "1.00" ? null : Number(v2);
    }
  },
  textOpacity: {
    selector: ".vjs-text-opacity > select",
    id: "captions-foreground-opacity-%s",
    label: "Transparency",
    options: [OPACITY_OPAQUE, OPACITY_SEMI]
  },
  // Options for this object are defined below.
  windowColor: {
    selector: ".vjs-window-color > select",
    id: "captions-window-color-%s",
    label: "Color"
  },
  // Options for this object are defined below.
  windowOpacity: {
    selector: ".vjs-window-opacity > select",
    id: "captions-window-opacity-%s",
    label: "Transparency",
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
  }
};
selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
function parseOptionValue(value, parser6) {
  if (parser6) {
    value = parser6(value);
  }
  if (value && value !== "none") {
    return value;
  }
}
function getSelectedOptionValue(el, parser6) {
  var value = el.options[el.options.selectedIndex].value;
  return parseOptionValue(value, parser6);
}
function setSelectedOption(el, value, parser6) {
  if (!value) {
    return;
  }
  for (var i = 0; i < el.options.length; i++) {
    if (parseOptionValue(el.options[i].value, parser6) === value) {
      el.selectedIndex = i;
      break;
    }
  }
}
var TextTrackSettings = function(_ModalDialog) {
  _inheritsLoose(TextTrackSettings2, _ModalDialog);
  function TextTrackSettings2(player, options) {
    var _this;
    options.temporary = false;
    _this = _ModalDialog.call(this, player, options) || this;
    _this.updateDisplay = _this.updateDisplay.bind(_assertThisInitialized(_this));
    _this.fill();
    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;
    _this.endDialog = createEl("p", {
      className: "vjs-control-text",
      textContent: _this.localize("End of dialog window.")
    });
    _this.el().appendChild(_this.endDialog);
    _this.setDefaults();
    if (options.persistTextTrackSettings === void 0) {
      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
    }
    _this.on(_this.$(".vjs-done-button"), "click", function() {
      _this.saveSettings();
      _this.close();
    });
    _this.on(_this.$(".vjs-default-button"), "click", function() {
      _this.setDefaults();
      _this.updateDisplay();
    });
    each(selectConfigs, function(config) {
      _this.on(_this.$(config.selector), "change", _this.updateDisplay);
    });
    if (_this.options_.persistTextTrackSettings) {
      _this.restoreSettings();
    }
    return _this;
  }
  var _proto = TextTrackSettings2.prototype;
  _proto.dispose = function dispose() {
    this.endDialog = null;
    _ModalDialog.prototype.dispose.call(this);
  };
  _proto.createElSelect_ = function createElSelect_(key, legendId, type2) {
    var _this2 = this;
    if (legendId === void 0) {
      legendId = "";
    }
    if (type2 === void 0) {
      type2 = "label";
    }
    var config = selectConfigs[key];
    var id = config.id.replace("%s", this.id_);
    var selectLabelledbyIds = [legendId, id].join(" ").trim();
    return ["<" + type2 + ' id="' + id + '" class="' + (type2 === "label" ? "vjs-label" : "") + '">', this.localize(config.label), "</" + type2 + ">", '<select aria-labelledby="' + selectLabelledbyIds + '">'].concat(config.options.map(function(o) {
      var optionId = id + "-" + o[1].replace(/\W+/g, "");
      return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + selectLabelledbyIds + " " + optionId + '">', _this2.localize(o[1]), "</option>"].join("");
    })).concat("</select>").join("");
  };
  _proto.createElFgColor_ = function createElFgColor_() {
    var legendId = "captions-text-legend-" + this.id_;
    return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Text"), "</legend>", this.createElSelect_("color", legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElBgColor_ = function createElBgColor_() {
    var legendId = "captions-background-" + this.id_;
    return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Background"), "</legend>", this.createElSelect_("backgroundColor", legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElWinColor_ = function createElWinColor_() {
    var legendId = "captions-window-" + this.id_;
    return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Window"), "</legend>", this.createElSelect_("windowColor", legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElColors_ = function createElColors_() {
    return createEl("div", {
      className: "vjs-track-settings-colors",
      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("")
    });
  };
  _proto.createElFont_ = function createElFont_() {
    return createEl("div", {
      className: "vjs-track-settings-font",
      innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("")
    });
  };
  _proto.createElControls_ = function createElControls_() {
    var defaultsDescription = this.localize("restore all settings to the default values");
    return createEl("div", {
      className: "vjs-track-settings-controls",
      innerHTML: ['<button type="button" class="vjs-default-button" title="' + defaultsDescription + '">', this.localize("Reset"), '<span class="vjs-control-text"> ' + defaultsDescription + "</span>", "</button>", '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"].join("")
    });
  };
  _proto.content = function content() {
    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
  };
  _proto.label = function label() {
    return this.localize("Caption Settings Dialog");
  };
  _proto.description = function description() {
    return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return _ModalDialog.prototype.buildCSSClass.call(this) + " vjs-text-track-settings";
  };
  _proto.getValues = function getValues() {
    var _this3 = this;
    return reduce(selectConfigs, function(accum, config, key) {
      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);
      if (value !== void 0) {
        accum[key] = value;
      }
      return accum;
    }, {});
  };
  _proto.setValues = function setValues(values3) {
    var _this4 = this;
    each(selectConfigs, function(config, key) {
      setSelectedOption(_this4.$(config.selector), values3[key], config.parser);
    });
  };
  _proto.setDefaults = function setDefaults() {
    var _this5 = this;
    each(selectConfigs, function(config) {
      var index = config.hasOwnProperty("default") ? config["default"] : 0;
      _this5.$(config.selector).selectedIndex = index;
    });
  };
  _proto.restoreSettings = function restoreSettings() {
    var values3;
    try {
      values3 = JSON.parse(import_window6.default.localStorage.getItem(LOCAL_STORAGE_KEY$1));
    } catch (err) {
      log$1.warn(err);
    }
    if (values3) {
      this.setValues(values3);
    }
  };
  _proto.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }
    var values3 = this.getValues();
    try {
      if (Object.keys(values3).length) {
        import_window6.default.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values3));
      } else {
        import_window6.default.localStorage.removeItem(LOCAL_STORAGE_KEY$1);
      }
    } catch (err) {
      log$1.warn(err);
    }
  };
  _proto.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild("textTrackDisplay");
    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };
  _proto.conditionalBlur_ = function conditionalBlur_() {
    this.previouslyActiveEl_ = null;
    var cb = this.player_.controlBar;
    var subsCapsBtn = cb && cb.subsCapsButton;
    var ccBtn = cb && cb.captionsButton;
    if (subsCapsBtn) {
      subsCapsBtn.focus();
    } else if (ccBtn) {
      ccBtn.focus();
    }
  };
  return TextTrackSettings2;
}(ModalDialog);
Component$1.registerComponent("TextTrackSettings", TextTrackSettings);
var ResizeManager = function(_Component) {
  _inheritsLoose(ResizeManager2, _Component);
  function ResizeManager2(player, options) {
    var _this;
    var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || import_window6.default.ResizeObserver;
    if (options.ResizeObserver === null) {
      RESIZE_OBSERVER_AVAILABLE = false;
    }
    var options_ = mergeOptions$3({
      createEl: !RESIZE_OBSERVER_AVAILABLE,
      reportTouchActivity: false
    }, options);
    _this = _Component.call(this, player, options_) || this;
    _this.ResizeObserver = options.ResizeObserver || import_window6.default.ResizeObserver;
    _this.loadListener_ = null;
    _this.resizeObserver_ = null;
    _this.debouncedHandler_ = debounce(function() {
      _this.resizeHandler();
    }, 100, false, _assertThisInitialized(_this));
    if (RESIZE_OBSERVER_AVAILABLE) {
      _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);
      _this.resizeObserver_.observe(player.el());
    } else {
      _this.loadListener_ = function() {
        if (!_this.el_ || !_this.el_.contentWindow) {
          return;
        }
        var debouncedHandler_ = _this.debouncedHandler_;
        var unloadListener_ = _this.unloadListener_ = function() {
          off(this, "resize", debouncedHandler_);
          off(this, "unload", unloadListener_);
          unloadListener_ = null;
        };
        on(_this.el_.contentWindow, "unload", unloadListener_);
        on(_this.el_.contentWindow, "resize", debouncedHandler_);
      };
      _this.one("load", _this.loadListener_);
    }
    return _this;
  }
  var _proto = ResizeManager2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "iframe", {
      className: "vjs-resize-manager",
      tabIndex: -1,
      title: this.localize("No content")
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.resizeHandler = function resizeHandler() {
    if (!this.player_ || !this.player_.trigger) {
      return;
    }
    this.player_.trigger("playerresize");
  };
  _proto.dispose = function dispose() {
    if (this.debouncedHandler_) {
      this.debouncedHandler_.cancel();
    }
    if (this.resizeObserver_) {
      if (this.player_.el()) {
        this.resizeObserver_.unobserve(this.player_.el());
      }
      this.resizeObserver_.disconnect();
    }
    if (this.loadListener_) {
      this.off("load", this.loadListener_);
    }
    if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
      this.unloadListener_.call(this.el_.contentWindow);
    }
    this.ResizeObserver = null;
    this.resizeObserver = null;
    this.debouncedHandler_ = null;
    this.loadListener_ = null;
    _Component.prototype.dispose.call(this);
  };
  return ResizeManager2;
}(Component$1);
Component$1.registerComponent("ResizeManager", ResizeManager);
var defaults = {
  trackingThreshold: 20,
  liveTolerance: 15
};
var LiveTracker = function(_Component) {
  _inheritsLoose(LiveTracker2, _Component);
  function LiveTracker2(player, options) {
    var _this;
    var options_ = mergeOptions$3(defaults, options, {
      createEl: false
    });
    _this = _Component.call(this, player, options_) || this;
    _this.handleVisibilityChange_ = function(e) {
      return _this.handleVisibilityChange(e);
    };
    _this.trackLiveHandler_ = function() {
      return _this.trackLive_();
    };
    _this.handlePlay_ = function(e) {
      return _this.handlePlay(e);
    };
    _this.handleFirstTimeupdate_ = function(e) {
      return _this.handleFirstTimeupdate(e);
    };
    _this.handleSeeked_ = function(e) {
      return _this.handleSeeked(e);
    };
    _this.seekToLiveEdge_ = function(e) {
      return _this.seekToLiveEdge(e);
    };
    _this.reset_();
    _this.on(_this.player_, "durationchange", function(e) {
      return _this.handleDurationchange(e);
    });
    _this.on(_this.player_, "canplay", function() {
      return _this.toggleTracking();
    });
    if (IE_VERSION && "hidden" in import_document.default && "visibilityState" in import_document.default) {
      _this.on(import_document.default, "visibilitychange", _this.handleVisibilityChange_);
    }
    return _this;
  }
  var _proto = LiveTracker2.prototype;
  _proto.handleVisibilityChange = function handleVisibilityChange() {
    if (this.player_.duration() !== Infinity) {
      return;
    }
    if (import_document.default.hidden) {
      this.stopTracking();
    } else {
      this.startTracking();
    }
  };
  _proto.trackLive_ = function trackLive_() {
    var seekable3 = this.player_.seekable();
    if (!seekable3 || !seekable3.length) {
      return;
    }
    var newTime = Number(import_window6.default.performance.now().toFixed(4));
    var deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1e3;
    this.lastTime_ = newTime;
    this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
    var liveCurrentTime = this.liveCurrentTime();
    var currentTime = this.player_.currentTime();
    var isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
    if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
      isBehind = false;
    }
    if (isBehind !== this.behindLiveEdge_) {
      this.behindLiveEdge_ = isBehind;
      this.trigger("liveedgechange");
    }
  };
  _proto.handleDurationchange = function handleDurationchange() {
    this.toggleTracking();
  };
  _proto.toggleTracking = function toggleTracking() {
    if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
      if (this.player_.options_.liveui) {
        this.player_.addClass("vjs-liveui");
      }
      this.startTracking();
    } else {
      this.player_.removeClass("vjs-liveui");
      this.stopTracking();
    }
  };
  _proto.startTracking = function startTracking() {
    if (this.isTracking()) {
      return;
    }
    if (!this.timeupdateSeen_) {
      this.timeupdateSeen_ = this.player_.hasStarted();
    }
    this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
    this.trackLive_();
    this.on(this.player_, ["play", "pause"], this.trackLiveHandler_);
    if (!this.timeupdateSeen_) {
      this.one(this.player_, "play", this.handlePlay_);
      this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_);
    } else {
      this.on(this.player_, "seeked", this.handleSeeked_);
    }
  };
  _proto.handleFirstTimeupdate = function handleFirstTimeupdate() {
    this.timeupdateSeen_ = true;
    this.on(this.player_, "seeked", this.handleSeeked_);
  };
  _proto.handleSeeked = function handleSeeked() {
    var timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
    this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
    this.nextSeekedFromUser_ = false;
    this.trackLive_();
  };
  _proto.handlePlay = function handlePlay() {
    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
  };
  _proto.reset_ = function reset_() {
    this.lastTime_ = -1;
    this.pastSeekEnd_ = 0;
    this.lastSeekEnd_ = -1;
    this.behindLiveEdge_ = true;
    this.timeupdateSeen_ = false;
    this.seekedBehindLive_ = false;
    this.nextSeekedFromUser_ = false;
    this.clearInterval(this.trackingInterval_);
    this.trackingInterval_ = null;
    this.off(this.player_, ["play", "pause"], this.trackLiveHandler_);
    this.off(this.player_, "seeked", this.handleSeeked_);
    this.off(this.player_, "play", this.handlePlay_);
    this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_);
    this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
  };
  _proto.nextSeekedFromUser = function nextSeekedFromUser() {
    this.nextSeekedFromUser_ = true;
  };
  _proto.stopTracking = function stopTracking() {
    if (!this.isTracking()) {
      return;
    }
    this.reset_();
    this.trigger("liveedgechange");
  };
  _proto.seekableEnd = function seekableEnd() {
    var seekable3 = this.player_.seekable();
    var seekableEnds = [];
    var i = seekable3 ? seekable3.length : 0;
    while (i--) {
      seekableEnds.push(seekable3.end(i));
    }
    return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
  };
  _proto.seekableStart = function seekableStart() {
    var seekable3 = this.player_.seekable();
    var seekableStarts = [];
    var i = seekable3 ? seekable3.length : 0;
    while (i--) {
      seekableStarts.push(seekable3.start(i));
    }
    return seekableStarts.length ? seekableStarts.sort()[0] : 0;
  };
  _proto.liveWindow = function liveWindow() {
    var liveCurrentTime = this.liveCurrentTime();
    if (liveCurrentTime === Infinity) {
      return 0;
    }
    return liveCurrentTime - this.seekableStart();
  };
  _proto.isLive = function isLive() {
    return this.isTracking();
  };
  _proto.atLiveEdge = function atLiveEdge() {
    return !this.behindLiveEdge();
  };
  _proto.liveCurrentTime = function liveCurrentTime() {
    return this.pastSeekEnd() + this.seekableEnd();
  };
  _proto.pastSeekEnd = function pastSeekEnd() {
    var seekableEnd = this.seekableEnd();
    if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
      this.pastSeekEnd_ = 0;
    }
    this.lastSeekEnd_ = seekableEnd;
    return this.pastSeekEnd_;
  };
  _proto.behindLiveEdge = function behindLiveEdge() {
    return this.behindLiveEdge_;
  };
  _proto.isTracking = function isTracking() {
    return typeof this.trackingInterval_ === "number";
  };
  _proto.seekToLiveEdge = function seekToLiveEdge() {
    this.seekedBehindLive_ = false;
    if (this.atLiveEdge()) {
      return;
    }
    this.nextSeekedFromUser_ = false;
    this.player_.currentTime(this.liveCurrentTime());
  };
  _proto.dispose = function dispose() {
    this.off(import_document.default, "visibilitychange", this.handleVisibilityChange_);
    this.stopTracking();
    _Component.prototype.dispose.call(this);
  };
  return LiveTracker2;
}(Component$1);
Component$1.registerComponent("LiveTracker", LiveTracker);
var sourcesetLoad = function sourcesetLoad2(tech) {
  var el = tech.el();
  if (el.hasAttribute("src")) {
    tech.triggerSourceset(el.src);
    return true;
  }
  var sources = tech.$$("source");
  var srcUrls = [];
  var src = "";
  if (!sources.length) {
    return false;
  }
  for (var i = 0; i < sources.length; i++) {
    var url = sources[i].src;
    if (url && srcUrls.indexOf(url) === -1) {
      srcUrls.push(url);
    }
  }
  if (!srcUrls.length) {
    return false;
  }
  if (srcUrls.length === 1) {
    src = srcUrls[0];
  }
  tech.triggerSourceset(src);
  return true;
};
var innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
  get: function get2() {
    return this.cloneNode(true).innerHTML;
  },
  set: function set2(v2) {
    var dummy = import_document.default.createElement(this.nodeName.toLowerCase());
    dummy.innerHTML = v2;
    var docFrag = import_document.default.createDocumentFragment();
    while (dummy.childNodes.length) {
      docFrag.appendChild(dummy.childNodes[0]);
    }
    this.innerText = "";
    import_window6.default.Element.prototype.appendChild.call(this, docFrag);
    return this.innerHTML;
  }
});
var getDescriptor = function getDescriptor2(priority, prop) {
  var descriptor = {};
  for (var i = 0; i < priority.length; i++) {
    descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
    if (descriptor && descriptor.set && descriptor.get) {
      break;
    }
  }
  descriptor.enumerable = true;
  descriptor.configurable = true;
  return descriptor;
};
var getInnerHTMLDescriptor = function getInnerHTMLDescriptor2(tech) {
  return getDescriptor([tech.el(), import_window6.default.HTMLMediaElement.prototype, import_window6.default.Element.prototype, innerHTMLDescriptorPolyfill], "innerHTML");
};
var firstSourceWatch = function firstSourceWatch2(tech) {
  var el = tech.el();
  if (el.resetSourceWatch_) {
    return;
  }
  var old = {};
  var innerDescriptor = getInnerHTMLDescriptor(tech);
  var appendWrapper = function appendWrapper2(appendFn) {
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var retval = appendFn.apply(el, args);
      sourcesetLoad(tech);
      return retval;
    };
  };
  ["append", "appendChild", "insertAdjacentHTML"].forEach(function(k2) {
    if (!el[k2]) {
      return;
    }
    old[k2] = el[k2];
    el[k2] = appendWrapper(old[k2]);
  });
  Object.defineProperty(el, "innerHTML", mergeOptions$3(innerDescriptor, {
    set: appendWrapper(innerDescriptor.set)
  }));
  el.resetSourceWatch_ = function() {
    el.resetSourceWatch_ = null;
    Object.keys(old).forEach(function(k2) {
      el[k2] = old[k2];
    });
    Object.defineProperty(el, "innerHTML", innerDescriptor);
  };
  tech.one("sourceset", el.resetSourceWatch_);
};
var srcDescriptorPolyfill = Object.defineProperty({}, "src", {
  get: function get3() {
    if (this.hasAttribute("src")) {
      return getAbsoluteURL(import_window6.default.Element.prototype.getAttribute.call(this, "src"));
    }
    return "";
  },
  set: function set3(v2) {
    import_window6.default.Element.prototype.setAttribute.call(this, "src", v2);
    return v2;
  }
});
var getSrcDescriptor = function getSrcDescriptor2(tech) {
  return getDescriptor([tech.el(), import_window6.default.HTMLMediaElement.prototype, srcDescriptorPolyfill], "src");
};
var setupSourceset = function setupSourceset2(tech) {
  if (!tech.featuresSourceset) {
    return;
  }
  var el = tech.el();
  if (el.resetSourceset_) {
    return;
  }
  var srcDescriptor = getSrcDescriptor(tech);
  var oldSetAttribute = el.setAttribute;
  var oldLoad = el.load;
  Object.defineProperty(el, "src", mergeOptions$3(srcDescriptor, {
    set: function set4(v2) {
      var retval = srcDescriptor.set.call(el, v2);
      tech.triggerSourceset(el.src);
      return retval;
    }
  }));
  el.setAttribute = function(n, v2) {
    var retval = oldSetAttribute.call(el, n, v2);
    if (/src/i.test(n)) {
      tech.triggerSourceset(el.src);
    }
    return retval;
  };
  el.load = function() {
    var retval = oldLoad.call(el);
    if (!sourcesetLoad(tech)) {
      tech.triggerSourceset("");
      firstSourceWatch(tech);
    }
    return retval;
  };
  if (el.currentSrc) {
    tech.triggerSourceset(el.currentSrc);
  } else if (!sourcesetLoad(tech)) {
    firstSourceWatch(tech);
  }
  el.resetSourceset_ = function() {
    el.resetSourceset_ = null;
    el.load = oldLoad;
    el.setAttribute = oldSetAttribute;
    Object.defineProperty(el, "src", srcDescriptor);
    if (el.resetSourceWatch_) {
      el.resetSourceWatch_();
    }
  };
};
var defineLazyProperty = function defineLazyProperty2(obj, key, getValue, setter) {
  if (setter === void 0) {
    setter = true;
  }
  var set4 = function set5(value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      writable: true
    });
  };
  var options = {
    configurable: true,
    enumerable: true,
    get: function get7() {
      var value = getValue();
      set4(value);
      return value;
    }
  };
  if (setter) {
    options.set = set4;
  }
  return Object.defineProperty(obj, key, options);
};
var Html5 = function(_Tech) {
  _inheritsLoose(Html52, _Tech);
  function Html52(options, ready) {
    var _this;
    _this = _Tech.call(this, options, ready) || this;
    var source = options.source;
    var crossoriginTracks = false;
    _this.featuresVideoFrameCallback = _this.featuresVideoFrameCallback && _this.el_.tagName === "VIDEO";
    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      _this.setSource(source);
    } else {
      _this.handleLateInit_(_this.el_);
    }
    if (options.enableSourceset) {
      _this.setupSourcesetHandling_();
    }
    _this.isScrubbing_ = false;
    if (_this.el_.hasChildNodes()) {
      var nodes = _this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];
      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "track") {
          if (!_this.featuresNativeTextTracks) {
            removeNodes.push(node);
          } else {
            _this.remoteTextTrackEls().addTrackElement_(node);
            _this.remoteTextTracks().addTrack(node.track);
            _this.textTracks().addTrack(node.track);
            if (!crossoriginTracks && !_this.el_.hasAttribute("crossorigin") && isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }
      for (var i = 0; i < removeNodes.length; i++) {
        _this.el_.removeChild(removeNodes[i]);
      }
    }
    _this.proxyNativeTracks_();
    if (_this.featuresNativeTextTracks && crossoriginTracks) {
      log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading.");
    }
    _this.restoreMetadataTracksInIOSNativePlayer_();
    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      _this.setControls(true);
    }
    _this.proxyWebkitFullscreen_();
    _this.triggerReady();
    return _this;
  }
  var _proto = Html52.prototype;
  _proto.dispose = function dispose() {
    if (this.el_ && this.el_.resetSourceset_) {
      this.el_.resetSourceset_();
    }
    Html52.disposeMediaElement(this.el_);
    this.options_ = null;
    _Tech.prototype.dispose.call(this);
  };
  _proto.setupSourcesetHandling_ = function setupSourcesetHandling_() {
    setupSourceset(this);
  };
  _proto.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
    var textTracks = this.textTracks();
    var metadataTracksPreFullscreenState;
    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot2() {
      metadataTracksPreFullscreenState = [];
      for (var i = 0; i < textTracks.length; i++) {
        var track = textTracks[i];
        if (track.kind === "metadata") {
          metadataTracksPreFullscreenState.push({
            track,
            storedMode: track.mode
          });
        }
      }
    };
    takeMetadataTrackSnapshot();
    textTracks.addEventListener("change", takeMetadataTrackSnapshot);
    this.on("dispose", function() {
      return textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
    });
    var restoreTrackMode = function restoreTrackMode2() {
      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {
        var storedTrack = metadataTracksPreFullscreenState[i];
        if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) {
          storedTrack.track.mode = storedTrack.storedMode;
        }
      }
      textTracks.removeEventListener("change", restoreTrackMode2);
    };
    this.on("webkitbeginfullscreen", function() {
      textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
      textTracks.removeEventListener("change", restoreTrackMode);
      textTracks.addEventListener("change", restoreTrackMode);
    });
    this.on("webkitendfullscreen", function() {
      textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
      textTracks.addEventListener("change", takeMetadataTrackSnapshot);
      textTracks.removeEventListener("change", restoreTrackMode);
    });
  };
  _proto.overrideNative_ = function overrideNative_(type2, override) {
    var _this2 = this;
    if (override !== this["featuresNative" + type2 + "Tracks"]) {
      return;
    }
    var lowerCaseType = type2.toLowerCase();
    if (this[lowerCaseType + "TracksListeners_"]) {
      Object.keys(this[lowerCaseType + "TracksListeners_"]).forEach(function(eventName) {
        var elTracks = _this2.el()[lowerCaseType + "Tracks"];
        elTracks.removeEventListener(eventName, _this2[lowerCaseType + "TracksListeners_"][eventName]);
      });
    }
    this["featuresNative" + type2 + "Tracks"] = !override;
    this[lowerCaseType + "TracksListeners_"] = null;
    this.proxyNativeTracksForType_(lowerCaseType);
  };
  _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks(override) {
    this.overrideNative_("Audio", override);
  };
  _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks(override) {
    this.overrideNative_("Video", override);
  };
  _proto.proxyNativeTracksForType_ = function proxyNativeTracksForType_(name) {
    var _this3 = this;
    var props = NORMAL[name];
    var elTracks = this.el()[props.getterName];
    var techTracks = this[props.getterName]();
    if (!this["featuresNative" + props.capitalName + "Tracks"] || !elTracks || !elTracks.addEventListener) {
      return;
    }
    var listeners = {
      change: function change(e) {
        var event = {
          type: "change",
          target: techTracks,
          currentTarget: techTracks,
          srcElement: techTracks
        };
        techTracks.trigger(event);
        if (name === "text") {
          _this3[REMOTE.remoteText.getterName]().trigger(event);
        }
      },
      addtrack: function addtrack(e) {
        techTracks.addTrack(e.track);
      },
      removetrack: function removetrack(e) {
        techTracks.removeTrack(e.track);
      }
    };
    var removeOldTracks = function removeOldTracks2() {
      var removeTracks = [];
      for (var i = 0; i < techTracks.length; i++) {
        var found = false;
        for (var j2 = 0; j2 < elTracks.length; j2++) {
          if (elTracks[j2] === techTracks[i]) {
            found = true;
            break;
          }
        }
        if (!found) {
          removeTracks.push(techTracks[i]);
        }
      }
      while (removeTracks.length) {
        techTracks.removeTrack(removeTracks.shift());
      }
    };
    this[props.getterName + "Listeners_"] = listeners;
    Object.keys(listeners).forEach(function(eventName) {
      var listener = listeners[eventName];
      elTracks.addEventListener(eventName, listener);
      _this3.on("dispose", function(e) {
        return elTracks.removeEventListener(eventName, listener);
      });
    });
    this.on("loadstart", removeOldTracks);
    this.on("dispose", function(e) {
      return _this3.off("loadstart", removeOldTracks);
    });
  };
  _proto.proxyNativeTracks_ = function proxyNativeTracks_() {
    var _this4 = this;
    NORMAL.names.forEach(function(name) {
      _this4.proxyNativeTracksForType_(name);
    });
  };
  _proto.createEl = function createEl2() {
    var el = this.options_.tag;
    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
      if (el) {
        var clone = el.cloneNode(true);
        if (el.parentNode) {
          el.parentNode.insertBefore(clone, el);
        }
        Html52.disposeMediaElement(el);
        el = clone;
      } else {
        el = import_document.default.createElement("video");
        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        var attributes = mergeOptions$3({}, tagAttributes);
        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }
        setAttributes(el, assign(attributes, {
          id: this.options_.techId,
          "class": "vjs-tech"
        }));
      }
      el.playerId = this.options_.playerId;
    }
    if (typeof this.options_.preload !== "undefined") {
      setAttribute(el, "preload", this.options_.preload);
    }
    if (this.options_.disablePictureInPicture !== void 0) {
      el.disablePictureInPicture = this.options_.disablePictureInPicture;
    }
    var settingsAttrs = ["loop", "muted", "playsinline", "autoplay"];
    for (var i = 0; i < settingsAttrs.length; i++) {
      var attr = settingsAttrs[i];
      var value = this.options_[attr];
      if (typeof value !== "undefined") {
        if (value) {
          setAttribute(el, attr, attr);
        } else {
          removeAttribute(el, attr);
        }
        el[attr] = value;
      }
    }
    return el;
  };
  _proto.handleLateInit_ = function handleLateInit_(el) {
    if (el.networkState === 0 || el.networkState === 3) {
      return;
    }
    if (el.readyState === 0) {
      var loadstartFired = false;
      var setLoadstartFired = function setLoadstartFired2() {
        loadstartFired = true;
      };
      this.on("loadstart", setLoadstartFired);
      var triggerLoadstart = function triggerLoadstart2() {
        if (!loadstartFired) {
          this.trigger("loadstart");
        }
      };
      this.on("loadedmetadata", triggerLoadstart);
      this.ready(function() {
        this.off("loadstart", setLoadstartFired);
        this.off("loadedmetadata", triggerLoadstart);
        if (!loadstartFired) {
          this.trigger("loadstart");
        }
      });
      return;
    }
    var eventsToTrigger = ["loadstart"];
    eventsToTrigger.push("loadedmetadata");
    if (el.readyState >= 2) {
      eventsToTrigger.push("loadeddata");
    }
    if (el.readyState >= 3) {
      eventsToTrigger.push("canplay");
    }
    if (el.readyState >= 4) {
      eventsToTrigger.push("canplaythrough");
    }
    this.ready(function() {
      eventsToTrigger.forEach(function(type2) {
        this.trigger(type2);
      }, this);
    });
  };
  _proto.setScrubbing = function setScrubbing(isScrubbing) {
    this.isScrubbing_ = isScrubbing;
  };
  _proto.scrubbing = function scrubbing() {
    return this.isScrubbing_;
  };
  _proto.setCurrentTime = function setCurrentTime(seconds) {
    try {
      if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {
        this.el_.fastSeek(seconds);
      } else {
        this.el_.currentTime = seconds;
      }
    } catch (e) {
      log$1(e, "Video is not ready. (Video.js)");
    }
  };
  _proto.duration = function duration5() {
    var _this5 = this;
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      var checkProgress = function checkProgress2() {
        if (_this5.el_.currentTime > 0) {
          if (_this5.el_.duration === Infinity) {
            _this5.trigger("durationchange");
          }
          _this5.off("timeupdate", checkProgress2);
        }
      };
      this.on("timeupdate", checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  };
  _proto.width = function width2() {
    return this.el_.offsetWidth;
  };
  _proto.height = function height2() {
    return this.el_.offsetHeight;
  };
  _proto.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
    var _this6 = this;
    if (!("webkitDisplayingFullscreen" in this.el_)) {
      return;
    }
    var endFn = function endFn2() {
      this.trigger("fullscreenchange", {
        isFullscreen: false
      });
      if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {
        this.el_.controls = false;
      }
    };
    var beginFn = function beginFn2() {
      if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
        this.one("webkitendfullscreen", endFn);
        this.trigger("fullscreenchange", {
          isFullscreen: true,
          // set a flag in case another tech triggers fullscreenchange
          nativeIOSFullscreen: true
        });
      }
    };
    this.on("webkitbeginfullscreen", beginFn);
    this.on("dispose", function() {
      _this6.off("webkitbeginfullscreen", beginFn);
      _this6.off("webkitendfullscreen", endFn);
    });
  };
  _proto.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === "function") {
      var userAgent = import_window6.default.navigator && import_window6.default.navigator.userAgent || "";
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };
  _proto.enterFullScreen = function enterFullScreen() {
    var video = this.el_;
    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      silencePromise(this.el_.play());
      this.setTimeout(function() {
        video.pause();
        try {
          video.webkitEnterFullScreen();
        } catch (e) {
          this.trigger("fullscreenerror", e);
        }
      }, 0);
    } else {
      try {
        video.webkitEnterFullScreen();
      } catch (e) {
        this.trigger("fullscreenerror", e);
      }
    }
  };
  _proto.exitFullScreen = function exitFullScreen() {
    if (!this.el_.webkitDisplayingFullscreen) {
      this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
      return;
    }
    this.el_.webkitExitFullScreen();
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    return this.el_.requestPictureInPicture();
  };
  _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb) {
    if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
      return this.el_.requestVideoFrameCallback(cb);
    }
    return _Tech.prototype.requestVideoFrameCallback.call(this, cb);
  };
  _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id) {
    if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
      this.el_.cancelVideoFrameCallback(id);
    } else {
      _Tech.prototype.cancelVideoFrameCallback.call(this, id);
    }
  };
  _proto.src = function src(_src) {
    if (_src === void 0) {
      return this.el_.src;
    }
    this.setSrc(_src);
  };
  _proto.reset = function reset3() {
    Html52.resetMediaElement(this.el_);
  };
  _proto.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  };
  _proto.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }
    return this.el_.addTextTrack(kind, label, language);
  };
  _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.createRemoteTextTrack.call(this, options);
    }
    var htmlTrackElement = import_document.default.createElement("track");
    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options["default"]) {
      htmlTrackElement["default"] = options["default"];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }
    return htmlTrackElement;
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);
    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }
    return htmlTrackElement;
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    _Tech.prototype.removeRemoteTextTrack.call(this, track);
    if (this.featuresNativeTextTracks) {
      var tracks = this.$$("track");
      var i = tracks.length;
      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === "function") {
      return this.el().getVideoPlaybackQuality();
    }
    var videoPlaybackQuality = {};
    if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }
    if (import_window6.default.performance && typeof import_window6.default.performance.now === "function") {
      videoPlaybackQuality.creationTime = import_window6.default.performance.now();
    } else if (import_window6.default.performance && import_window6.default.performance.timing && typeof import_window6.default.performance.timing.navigationStart === "number") {
      videoPlaybackQuality.creationTime = import_window6.default.Date.now() - import_window6.default.performance.timing.navigationStart;
    }
    return videoPlaybackQuality;
  };
  return Html52;
}(Tech);
defineLazyProperty(Html5, "TEST_VID", function() {
  if (!isReal()) {
    return;
  }
  var video = import_document.default.createElement("video");
  var track = import_document.default.createElement("track");
  track.kind = "captions";
  track.srclang = "en";
  track.label = "English";
  video.appendChild(track);
  return video;
});
Html5.isSupported = function() {
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }
  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};
Html5.canPlayType = function(type2) {
  return Html5.TEST_VID.canPlayType(type2);
};
Html5.canPlaySource = function(srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};
Html5.canControlVolume = function() {
  try {
    var volume = Html5.TEST_VID.volume;
    Html5.TEST_VID.volume = volume / 2 + 0.1;
    var canControl = volume !== Html5.TEST_VID.volume;
    if (canControl && IS_IOS) {
      import_window6.default.setTimeout(function() {
        if (Html5 && Html5.prototype) {
          Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
        }
      });
      return false;
    }
    return canControl;
  } catch (e) {
    return false;
  }
};
Html5.canMuteVolume = function() {
  try {
    var muted = Html5.TEST_VID.muted;
    Html5.TEST_VID.muted = !muted;
    if (Html5.TEST_VID.muted) {
      setAttribute(Html5.TEST_VID, "muted", "muted");
    } else {
      removeAttribute(Html5.TEST_VID, "muted", "muted");
    }
    return muted !== Html5.TEST_VID.muted;
  } catch (e) {
    return false;
  }
};
Html5.canControlPlaybackRate = function() {
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;
    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};
Html5.canOverrideAttributes = function() {
  try {
    var noop2 = function noop3() {
    };
    Object.defineProperty(import_document.default.createElement("video"), "src", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(import_document.default.createElement("audio"), "src", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(import_document.default.createElement("video"), "innerHTML", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(import_document.default.createElement("audio"), "innerHTML", {
      get: noop2,
      set: noop2
    });
  } catch (e) {
    return false;
  }
  return true;
};
Html5.supportsNativeTextTracks = function() {
  return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
};
Html5.supportsNativeVideoTracks = function() {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};
Html5.supportsNativeAudioTracks = function() {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};
Html5.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
[["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function(_ref) {
  var key = _ref[0], fn = _ref[1];
  defineLazyProperty(Html5.prototype, key, function() {
    return Html5[fn]();
  }, true);
});
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
Html5.prototype.movingMediaElementInDOM = !IS_IOS;
Html5.prototype.featuresFullscreenResize = true;
Html5.prototype.featuresProgressEvents = true;
Html5.prototype.featuresTimeupdateEvents = true;
Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);
var canPlayType;
Html5.patchCanPlayType = function() {
  if (ANDROID_VERSION >= 4 && !IS_FIREFOX && !IS_CHROME) {
    canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
    Html5.TEST_VID.constructor.prototype.canPlayType = function(type2) {
      var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
      if (type2 && mpegurlRE.test(type2)) {
        return "maybe";
      }
      return canPlayType.call(this, type2);
    };
  }
};
Html5.unpatchCanPlayType = function() {
  var r2 = Html5.TEST_VID.constructor.prototype.canPlayType;
  if (canPlayType) {
    Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  }
  return r2;
};
Html5.patchCanPlayType();
Html5.disposeMediaElement = function(el) {
  if (!el) {
    return;
  }
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }
  el.removeAttribute("src");
  if (typeof el.load === "function") {
    (function() {
      try {
        el.load();
      } catch (e) {
      }
    })();
  }
};
Html5.resetMediaElement = function(el) {
  if (!el) {
    return;
  }
  var sources = el.querySelectorAll("source");
  var i = sources.length;
  while (i--) {
    el.removeChild(sources[i]);
  }
  el.removeAttribute("src");
  if (typeof el.load === "function") {
    (function() {
      try {
        el.load();
      } catch (e) {
      }
    })();
  }
};
[
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  "controls",
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop] || this.el_.hasAttribute(prop);
  };
});
[
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(prop) {
  Html5.prototype["set" + toTitleCase$1(prop)] = function(v2) {
    this.el_[prop] = v2;
    if (v2) {
      this.el_.setAttribute(prop, prop);
    } else {
      this.el_.removeAttribute(prop);
    }
  };
});
[
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  "paused",
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  "currentTime",
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  "buffered",
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  "poster",
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  "error",
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  "seeking",
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  "seekable",
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  "ended",
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "defaultPlaybackRate",
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  "played",
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  "networkState",
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  "readyState",
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoWidth",
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoHeight",
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop];
  };
});
[
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  "src",
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  "poster",
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  "defaultPlaybackRate",
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(prop) {
  Html5.prototype["set" + toTitleCase$1(prop)] = function(v2) {
    this.el_[prop] = v2;
  };
});
[
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  "pause",
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  "load",
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  "play"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop]();
  };
});
Tech.withSourceHandlers(Html5);
Html5.nativeSourceHandler = {};
Html5.nativeSourceHandler.canPlayType = function(type2) {
  try {
    return Html5.TEST_VID.canPlayType(type2);
  } catch (e) {
    return "";
  }
};
Html5.nativeSourceHandler.canHandleSource = function(source, options) {
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);
  } else if (source.src) {
    var ext = getFileExtension(source.src);
    return Html5.nativeSourceHandler.canPlayType("video/" + ext);
  }
  return "";
};
Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
  tech.setSrc(source.src);
};
Html5.nativeSourceHandler.dispose = function() {
};
Html5.registerSourceHandler(Html5.nativeSourceHandler);
Tech.registerTech("Html5", Html5);
var TECH_EVENTS_RETRIGGER = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  "progress",
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  "abort",
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  "suspend",
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  "emptied",
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  "stalled",
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  "loadedmetadata",
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  "loadeddata",
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  "timeupdate",
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  "resize",
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  "volumechange",
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  "texttrackchange"
];
var TECH_EVENTS_QUEUE = {
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  playing: "Playing",
  seeked: "Seeked"
};
var BREAKPOINT_ORDER = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"];
var BREAKPOINT_CLASSES = {};
BREAKPOINT_ORDER.forEach(function(k2) {
  var v2 = k2.charAt(0) === "x" ? "x-" + k2.substring(1) : k2;
  BREAKPOINT_CLASSES[k2] = "vjs-layout-" + v2;
});
var DEFAULT_BREAKPOINTS = {
  tiny: 210,
  xsmall: 320,
  small: 425,
  medium: 768,
  large: 1440,
  xlarge: 2560,
  huge: Infinity
};
var Player = function(_Component) {
  _inheritsLoose(Player2, _Component);
  function Player2(tag, options, ready) {
    var _this;
    tag.id = tag.id || options.id || "vjs_video_" + newGUID();
    options = assign(Player2.getTagSettings(tag), options);
    options.initChildren = false;
    options.createEl = false;
    options.evented = false;
    options.reportTouchActivity = false;
    if (!options.language) {
      if (typeof tag.closest === "function") {
        var closest = tag.closest("[lang]");
        if (closest && closest.getAttribute) {
          options.language = closest.getAttribute("lang");
        }
      } else {
        var element = tag;
        while (element && element.nodeType === 1) {
          if (getAttributes(element).hasOwnProperty("lang")) {
            options.language = element.getAttribute("lang");
            break;
          }
          element = element.parentNode;
        }
      }
    }
    _this = _Component.call(this, null, options, ready) || this;
    _this.boundDocumentFullscreenChange_ = function(e) {
      return _this.documentFullscreenChange_(e);
    };
    _this.boundFullWindowOnEscKey_ = function(e) {
      return _this.fullWindowOnEscKey(e);
    };
    _this.boundUpdateStyleEl_ = function(e) {
      return _this.updateStyleEl_(e);
    };
    _this.boundApplyInitTime_ = function(e) {
      return _this.applyInitTime_(e);
    };
    _this.boundUpdateCurrentBreakpoint_ = function(e) {
      return _this.updateCurrentBreakpoint_(e);
    };
    _this.boundHandleTechClick_ = function(e) {
      return _this.handleTechClick_(e);
    };
    _this.boundHandleTechDoubleClick_ = function(e) {
      return _this.handleTechDoubleClick_(e);
    };
    _this.boundHandleTechTouchStart_ = function(e) {
      return _this.handleTechTouchStart_(e);
    };
    _this.boundHandleTechTouchMove_ = function(e) {
      return _this.handleTechTouchMove_(e);
    };
    _this.boundHandleTechTouchEnd_ = function(e) {
      return _this.handleTechTouchEnd_(e);
    };
    _this.boundHandleTechTap_ = function(e) {
      return _this.handleTechTap_(e);
    };
    _this.isFullscreen_ = false;
    _this.log = createLogger(_this.id_);
    _this.fsApi_ = FullscreenApi;
    _this.isPosterFromTech_ = false;
    _this.queuedCallbacks_ = [];
    _this.isReady_ = false;
    _this.hasStarted_ = false;
    _this.userActive_ = false;
    _this.debugEnabled_ = false;
    _this.audioOnlyMode_ = false;
    _this.audioPosterMode_ = false;
    _this.audioOnlyCache_ = {
      playerHeight: null,
      hiddenChildren: []
    };
    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
      throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
    }
    _this.tag = tag;
    _this.tagAttributes = tag && getAttributes(tag);
    _this.language(_this.options_.language);
    if (options.languages) {
      var languagesToLower = {};
      Object.getOwnPropertyNames(options.languages).forEach(function(name) {
        languagesToLower[name.toLowerCase()] = options.languages[name];
      });
      _this.languages_ = languagesToLower;
    } else {
      _this.languages_ = Player2.prototype.options_.languages;
    }
    _this.resetCache_();
    _this.poster_ = options.poster || "";
    _this.controls_ = !!options.controls;
    tag.controls = false;
    tag.removeAttribute("controls");
    _this.changingSrc_ = false;
    _this.playCallbacks_ = [];
    _this.playTerminatedQueue_ = [];
    if (tag.hasAttribute("autoplay")) {
      _this.autoplay(true);
    } else {
      _this.autoplay(_this.options_.autoplay);
    }
    if (options.plugins) {
      Object.keys(options.plugins).forEach(function(name) {
        if (typeof _this[name] !== "function") {
          throw new Error('plugin "' + name + '" does not exist');
        }
      });
    }
    _this.scrubbing_ = false;
    _this.el_ = _this.createEl();
    evented(_assertThisInitialized(_this), {
      eventBusKey: "el_"
    });
    if (_this.fsApi_.requestFullscreen) {
      on(import_document.default, _this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
      _this.on(_this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
    }
    if (_this.fluid_) {
      _this.on(["playerreset", "resize"], _this.boundUpdateStyleEl_);
    }
    var playerOptionsCopy = mergeOptions$3(_this.options_);
    if (options.plugins) {
      Object.keys(options.plugins).forEach(function(name) {
        _this[name](options.plugins[name]);
      });
    }
    if (options.debug) {
      _this.debug(true);
    }
    _this.options_.playerOptions = playerOptionsCopy;
    _this.middleware_ = [];
    _this.playbackRates(options.playbackRates);
    _this.initChildren();
    _this.isAudio(tag.nodeName.toLowerCase() === "audio");
    if (_this.controls()) {
      _this.addClass("vjs-controls-enabled");
    } else {
      _this.addClass("vjs-controls-disabled");
    }
    _this.el_.setAttribute("role", "region");
    if (_this.isAudio()) {
      _this.el_.setAttribute("aria-label", _this.localize("Audio Player"));
    } else {
      _this.el_.setAttribute("aria-label", _this.localize("Video Player"));
    }
    if (_this.isAudio()) {
      _this.addClass("vjs-audio");
    }
    if (_this.flexNotSupported_()) {
      _this.addClass("vjs-no-flex");
    }
    if (TOUCH_ENABLED) {
      _this.addClass("vjs-touch-enabled");
    }
    if (!IS_IOS) {
      _this.addClass("vjs-workinghover");
    }
    Player2.players[_this.id_] = _assertThisInitialized(_this);
    var majorVersion = version$5.split(".")[0];
    _this.addClass("vjs-v" + majorVersion);
    _this.userActive(true);
    _this.reportUserActivity();
    _this.one("play", function(e) {
      return _this.listenForUserActivity_(e);
    });
    _this.on("stageclick", function(e) {
      return _this.handleStageClick_(e);
    });
    _this.on("keydown", function(e) {
      return _this.handleKeyDown(e);
    });
    _this.on("languagechange", function(e) {
      return _this.handleLanguagechange(e);
    });
    _this.breakpoints(_this.options_.breakpoints);
    _this.responsive(_this.options_.responsive);
    _this.on("ready", function() {
      _this.audioPosterMode(_this.options_.audioPosterMode);
      _this.audioOnlyMode(_this.options_.audioOnlyMode);
    });
    return _this;
  }
  var _proto = Player2.prototype;
  _proto.dispose = function dispose() {
    var _this2 = this;
    this.trigger("dispose");
    this.off("dispose");
    off(import_document.default, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
    off(import_document.default, "keydown", this.boundFullWindowOnEscKey_);
    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
      this.styleEl_ = null;
    }
    Player2.players[this.id_] = null;
    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }
    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }
    if (this.tech_) {
      this.tech_.dispose();
      this.isPosterFromTech_ = false;
      this.poster_ = "";
    }
    if (this.playerElIngest_) {
      this.playerElIngest_ = null;
    }
    if (this.tag) {
      this.tag = null;
    }
    clearCacheForPlayer(this);
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      var list = _this2[props.getterName]();
      if (list && list.off) {
        list.off();
      }
    });
    _Component.prototype.dispose.call(this, {
      restoreEl: this.options_.restoreEl
    });
  };
  _proto.createEl = function createEl2() {
    var tag = this.tag;
    var el;
    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
    var divEmbed = this.tag.tagName.toLowerCase() === "video-js";
    if (playerElIngest) {
      el = this.el_ = tag.parentNode;
    } else if (!divEmbed) {
      el = this.el_ = _Component.prototype.createEl.call(this, "div");
    }
    var attrs = getAttributes(tag);
    if (divEmbed) {
      el = this.el_ = tag;
      tag = this.tag = import_document.default.createElement("video");
      while (el.children.length) {
        tag.appendChild(el.firstChild);
      }
      if (!hasClass(el, "video-js")) {
        addClass(el, "video-js");
      }
      el.appendChild(tag);
      playerElIngest = this.playerElIngest_ = el;
      Object.keys(el).forEach(function(k2) {
        try {
          tag[k2] = el[k2];
        } catch (e) {
        }
      });
    }
    tag.setAttribute("tabindex", "-1");
    attrs.tabindex = "-1";
    if (IE_VERSION || IS_CHROME && IS_WINDOWS) {
      tag.setAttribute("role", "application");
      attrs.role = "application";
    }
    tag.removeAttribute("width");
    tag.removeAttribute("height");
    if ("width" in attrs) {
      delete attrs.width;
    }
    if ("height" in attrs) {
      delete attrs.height;
    }
    Object.getOwnPropertyNames(attrs).forEach(function(attr) {
      if (!(divEmbed && attr === "class")) {
        el.setAttribute(attr, attrs[attr]);
      }
      if (divEmbed) {
        tag.setAttribute(attr, attrs[attr]);
      }
    });
    tag.playerId = tag.id;
    tag.id += "_html5_api";
    tag.className = "vjs-tech";
    tag.player = el.player = this;
    this.addClass("vjs-paused");
    if (import_window6.default.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement("vjs-styles-dimensions");
      var defaultsStyleEl = $(".vjs-styles-defaults");
      var head = $("head");
      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }
    this.fill_ = false;
    this.fluid_ = false;
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fill(this.options_.fill);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);
    this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
    var links = tag.getElementsByTagName("a");
    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);
      addClass(linkEl, "vjs-hidden");
      linkEl.setAttribute("hidden", "hidden");
    }
    tag.initNetworkState_ = tag.networkState;
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el, tag);
    }
    prependTo(tag, el);
    this.children_.unshift(tag);
    this.el_.setAttribute("lang", this.language_);
    this.el_.setAttribute("translate", "no");
    this.el_ = el;
    return el;
  };
  _proto.crossOrigin = function crossOrigin(value) {
    if (!value) {
      return this.techGet_("crossOrigin");
    }
    if (value !== "anonymous" && value !== "use-credentials") {
      log$1.warn('crossOrigin must be "anonymous" or "use-credentials", given "' + value + '"');
      return;
    }
    this.techCall_("setCrossOrigin", value);
    return;
  };
  _proto.width = function width2(value) {
    return this.dimension("width", value);
  };
  _proto.height = function height2(value) {
    return this.dimension("height", value);
  };
  _proto.dimension = function dimension(_dimension, value) {
    var privDimension = _dimension + "_";
    if (value === void 0) {
      return this[privDimension] || 0;
    }
    if (value === "" || value === "auto") {
      this[privDimension] = void 0;
      this.updateStyleEl_();
      return;
    }
    var parsedVal = parseFloat(value);
    if (isNaN(parsedVal)) {
      log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
      return;
    }
    this[privDimension] = parsedVal;
    this.updateStyleEl_();
  };
  _proto.fluid = function fluid(bool) {
    var _this3 = this;
    if (bool === void 0) {
      return !!this.fluid_;
    }
    this.fluid_ = !!bool;
    if (isEvented(this)) {
      this.off(["playerreset", "resize"], this.boundUpdateStyleEl_);
    }
    if (bool) {
      this.addClass("vjs-fluid");
      this.fill(false);
      addEventedCallback(this, function() {
        _this3.on(["playerreset", "resize"], _this3.boundUpdateStyleEl_);
      });
    } else {
      this.removeClass("vjs-fluid");
    }
    this.updateStyleEl_();
  };
  _proto.fill = function fill(bool) {
    if (bool === void 0) {
      return !!this.fill_;
    }
    this.fill_ = !!bool;
    if (bool) {
      this.addClass("vjs-fill");
      this.fluid(false);
    } else {
      this.removeClass("vjs-fill");
    }
  };
  _proto.aspectRatio = function aspectRatio(ratio) {
    if (ratio === void 0) {
      return this.aspectRatio_;
    }
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
    }
    this.aspectRatio_ = ratio;
    this.fluid(true);
    this.updateStyleEl_();
  };
  _proto.updateStyleEl_ = function updateStyleEl_() {
    if (import_window6.default.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === "number" ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === "number" ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();
      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }
      return;
    }
    var width2;
    var height2;
    var aspectRatio;
    var idClass;
    if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") {
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      aspectRatio = this.videoWidth() + ":" + this.videoHeight();
    } else {
      aspectRatio = "16:9";
    }
    var ratioParts = aspectRatio.split(":");
    var ratioMultiplier = ratioParts[1] / ratioParts[0];
    if (this.width_ !== void 0) {
      width2 = this.width_;
    } else if (this.height_ !== void 0) {
      width2 = this.height_ / ratioMultiplier;
    } else {
      width2 = this.videoWidth() || 300;
    }
    if (this.height_ !== void 0) {
      height2 = this.height_;
    } else {
      height2 = width2 * ratioMultiplier;
    }
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = "dimensions-" + this.id();
    } else {
      idClass = this.id() + "-dimensions";
    }
    this.addClass(idClass);
    setTextContent(this.styleEl_, "\n      ." + idClass + " {\n        width: " + width2 + "px;\n        height: " + height2 + "px;\n      }\n\n      ." + idClass + ".vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: " + ratioMultiplier * 100 + "%;\n      }\n    ");
  };
  _proto.loadTech_ = function loadTech_(techName, source) {
    var _this4 = this;
    if (this.tech_) {
      this.unloadTech_();
    }
    var titleTechName = toTitleCase$1(techName);
    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
    if (titleTechName !== "Html5" && this.tag) {
      Tech.getTech("Html5").disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }
    this.techName_ = titleTechName;
    this.isReady_ = false;
    var autoplay = this.autoplay();
    if (typeof this.autoplay() === "string" || this.autoplay() === true && this.options_.normalizeAutoplay) {
      autoplay = false;
    }
    var techOptions = {
      source,
      autoplay,
      "nativeControlsForTouch": this.options_.nativeControlsForTouch,
      "playerId": this.id(),
      "techId": this.id() + "_" + camelTechName + "_api",
      "playsinline": this.options_.playsinline,
      "preload": this.options_.preload,
      "loop": this.options_.loop,
      "disablePictureInPicture": this.options_.disablePictureInPicture,
      "muted": this.options_.muted,
      "poster": this.poster(),
      "language": this.language(),
      "playerElIngest": this.playerElIngest_ || false,
      "vtt.js": this.options_["vtt.js"],
      "canOverridePoster": !!this.options_.techCanOverridePoster,
      "enableSourceset": this.options_.enableSourceset,
      "Promise": this.options_.Promise
    };
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      techOptions[props.getterName] = _this4[props.privateName];
    });
    assign(techOptions, this.options_[titleTechName]);
    assign(techOptions, this.options_[camelTechName]);
    assign(techOptions, this.options_[techName.toLowerCase()]);
    if (this.tag) {
      techOptions.tag = this.tag;
    }
    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }
    var TechClass = Tech.getTech(techName);
    if (!TechClass) {
      throw new Error("No Tech named '" + titleTechName + "' exists! '" + titleTechName + "' should be registered using videojs.registerTech()'");
    }
    this.tech_ = new TechClass(techOptions);
    this.tech_.ready(bind(this, this.handleTechReady_), true);
    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
    TECH_EVENTS_RETRIGGER.forEach(function(event) {
      _this4.on(_this4.tech_, event, function(e) {
        return _this4["handleTech" + toTitleCase$1(event) + "_"](e);
      });
    });
    Object.keys(TECH_EVENTS_QUEUE).forEach(function(event) {
      _this4.on(_this4.tech_, event, function(eventObj) {
        if (_this4.tech_.playbackRate() === 0 && _this4.tech_.seeking()) {
          _this4.queuedCallbacks_.push({
            callback: _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"].bind(_this4),
            event: eventObj
          });
          return;
        }
        _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"](eventObj);
      });
    });
    this.on(this.tech_, "loadstart", function(e) {
      return _this4.handleTechLoadStart_(e);
    });
    this.on(this.tech_, "sourceset", function(e) {
      return _this4.handleTechSourceset_(e);
    });
    this.on(this.tech_, "waiting", function(e) {
      return _this4.handleTechWaiting_(e);
    });
    this.on(this.tech_, "ended", function(e) {
      return _this4.handleTechEnded_(e);
    });
    this.on(this.tech_, "seeking", function(e) {
      return _this4.handleTechSeeking_(e);
    });
    this.on(this.tech_, "play", function(e) {
      return _this4.handleTechPlay_(e);
    });
    this.on(this.tech_, "firstplay", function(e) {
      return _this4.handleTechFirstPlay_(e);
    });
    this.on(this.tech_, "pause", function(e) {
      return _this4.handleTechPause_(e);
    });
    this.on(this.tech_, "durationchange", function(e) {
      return _this4.handleTechDurationChange_(e);
    });
    this.on(this.tech_, "fullscreenchange", function(e, data) {
      return _this4.handleTechFullscreenChange_(e, data);
    });
    this.on(this.tech_, "fullscreenerror", function(e, err) {
      return _this4.handleTechFullscreenError_(e, err);
    });
    this.on(this.tech_, "enterpictureinpicture", function(e) {
      return _this4.handleTechEnterPictureInPicture_(e);
    });
    this.on(this.tech_, "leavepictureinpicture", function(e) {
      return _this4.handleTechLeavePictureInPicture_(e);
    });
    this.on(this.tech_, "error", function(e) {
      return _this4.handleTechError_(e);
    });
    this.on(this.tech_, "posterchange", function(e) {
      return _this4.handleTechPosterChange_(e);
    });
    this.on(this.tech_, "textdata", function(e) {
      return _this4.handleTechTextData_(e);
    });
    this.on(this.tech_, "ratechange", function(e) {
      return _this4.handleTechRateChange_(e);
    });
    this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_);
    this.usingNativeControls(this.techGet_("controls"));
    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };
  _proto.unloadTech_ = function unloadTech_() {
    var _this5 = this;
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      _this5[props.privateName] = _this5[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
    this.isReady_ = false;
    this.tech_.dispose();
    this.tech_ = false;
    if (this.isPosterFromTech_) {
      this.poster_ = "";
      this.trigger("posterchange");
    }
    this.isPosterFromTech_ = false;
  };
  _proto.tech = function tech(safety) {
    if (safety === void 0) {
      log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n");
    }
    return this.tech_;
  };
  _proto.addTechControlsListeners_ = function addTechControlsListeners_() {
    this.removeTechControlsListeners_();
    this.on(this.tech_, "click", this.boundHandleTechClick_);
    this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
    this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
    this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
    this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
    this.on(this.tech_, "tap", this.boundHandleTechTap_);
  };
  _proto.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    this.off(this.tech_, "tap", this.boundHandleTechTap_);
    this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
    this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
    this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
    this.off(this.tech_, "click", this.boundHandleTechClick_);
    this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
  };
  _proto.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();
    if (this.cache_.volume) {
      this.techCall_("setVolume", this.cache_.volume);
    }
    this.handleTechPosterChange_();
    this.handleTechDurationChange_();
  };
  _proto.handleTechLoadStart_ = function handleTechLoadStart_() {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-seeking");
    this.error(null);
    this.handleTechDurationChange_();
    if (!this.paused()) {
      this.trigger("loadstart");
      this.trigger("firstplay");
    } else {
      this.hasStarted(false);
      this.trigger("loadstart");
    }
    this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? "play" : this.autoplay());
  };
  _proto.manualAutoplay_ = function manualAutoplay_(type2) {
    var _this6 = this;
    if (!this.tech_ || typeof type2 !== "string") {
      return;
    }
    var resolveMuted = function resolveMuted2() {
      var previouslyMuted = _this6.muted();
      _this6.muted(true);
      var restoreMuted = function restoreMuted2() {
        _this6.muted(previouslyMuted);
      };
      _this6.playTerminatedQueue_.push(restoreMuted);
      var mutedPromise = _this6.play();
      if (!isPromise(mutedPromise)) {
        return;
      }
      return mutedPromise["catch"](function(err) {
        restoreMuted();
        throw new Error("Rejection at manualAutoplay. Restoring muted value. " + (err ? err : ""));
      });
    };
    var promise;
    if (type2 === "any" && !this.muted()) {
      promise = this.play();
      if (isPromise(promise)) {
        promise = promise["catch"](resolveMuted);
      }
    } else if (type2 === "muted" && !this.muted()) {
      promise = resolveMuted();
    } else {
      promise = this.play();
    }
    if (!isPromise(promise)) {
      return;
    }
    return promise.then(function() {
      _this6.trigger({
        type: "autoplay-success",
        autoplay: type2
      });
    })["catch"](function() {
      _this6.trigger({
        type: "autoplay-failure",
        autoplay: type2
      });
    });
  };
  _proto.updateSourceCaches_ = function updateSourceCaches_(srcObj) {
    if (srcObj === void 0) {
      srcObj = "";
    }
    var src = srcObj;
    var type2 = "";
    if (typeof src !== "string") {
      src = srcObj.src;
      type2 = srcObj.type;
    }
    this.cache_.source = this.cache_.source || {};
    this.cache_.sources = this.cache_.sources || [];
    if (src && !type2) {
      type2 = findMimetype(this, src);
    }
    this.cache_.source = mergeOptions$3({}, srcObj, {
      src,
      type: type2
    });
    var matchingSources = this.cache_.sources.filter(function(s) {
      return s.src && s.src === src;
    });
    var sourceElSources = [];
    var sourceEls = this.$$("source");
    var matchingSourceEls = [];
    for (var i = 0; i < sourceEls.length; i++) {
      var sourceObj = getAttributes(sourceEls[i]);
      sourceElSources.push(sourceObj);
      if (sourceObj.src && sourceObj.src === src) {
        matchingSourceEls.push(sourceObj.src);
      }
    }
    if (matchingSourceEls.length && !matchingSources.length) {
      this.cache_.sources = sourceElSources;
    } else if (!matchingSources.length) {
      this.cache_.sources = [this.cache_.source];
    }
    this.cache_.src = src;
  };
  _proto.handleTechSourceset_ = function handleTechSourceset_(event) {
    var _this7 = this;
    if (!this.changingSrc_) {
      var updateSourceCaches = function updateSourceCaches2(src) {
        return _this7.updateSourceCaches_(src);
      };
      var playerSrc = this.currentSource().src;
      var eventSrc = event.src;
      if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
        if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
          updateSourceCaches = function updateSourceCaches2() {
          };
        }
      }
      updateSourceCaches(eventSrc);
      if (!event.src) {
        this.tech_.any(["sourceset", "loadstart"], function(e) {
          if (e.type === "sourceset") {
            return;
          }
          var techSrc = _this7.techGet("currentSrc");
          _this7.lastSource_.tech = techSrc;
          _this7.updateSourceCaches_(techSrc);
        });
      }
    }
    this.lastSource_ = {
      player: this.currentSource().src,
      tech: event.src
    };
    this.trigger({
      src: event.src,
      type: "sourceset"
    });
  };
  _proto.hasStarted = function hasStarted(request) {
    if (request === void 0) {
      return this.hasStarted_;
    }
    if (request === this.hasStarted_) {
      return;
    }
    this.hasStarted_ = request;
    if (this.hasStarted_) {
      this.addClass("vjs-has-started");
      this.trigger("firstplay");
    } else {
      this.removeClass("vjs-has-started");
    }
  };
  _proto.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-paused");
    this.addClass("vjs-playing");
    this.hasStarted(true);
    this.trigger("play");
  };
  _proto.handleTechRateChange_ = function handleTechRateChange_() {
    if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
      this.queuedCallbacks_.forEach(function(queued) {
        return queued.callback(queued.event);
      });
      this.queuedCallbacks_ = [];
    }
    this.cache_.lastPlaybackRate = this.tech_.playbackRate();
    this.trigger("ratechange");
  };
  _proto.handleTechWaiting_ = function handleTechWaiting_() {
    var _this8 = this;
    this.addClass("vjs-waiting");
    this.trigger("waiting");
    var timeWhenWaiting = this.currentTime();
    var timeUpdateListener = function timeUpdateListener2() {
      if (timeWhenWaiting !== _this8.currentTime()) {
        _this8.removeClass("vjs-waiting");
        _this8.off("timeupdate", timeUpdateListener2);
      }
    };
    this.on("timeupdate", timeUpdateListener);
  };
  _proto.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass("vjs-waiting");
    this.trigger("canplay");
  };
  _proto.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass("vjs-waiting");
    this.trigger("canplaythrough");
  };
  _proto.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass("vjs-waiting");
    this.trigger("playing");
  };
  _proto.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass("vjs-seeking");
    this.trigger("seeking");
  };
  _proto.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass("vjs-seeking");
    this.removeClass("vjs-ended");
    this.trigger("seeked");
  };
  _proto.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    if (this.options_.starttime) {
      log$1.warn("Passing the `starttime` option to the player will be deprecated in 6.0");
      this.currentTime(this.options_.starttime);
    }
    this.addClass("vjs-has-started");
    this.trigger("firstplay");
  };
  _proto.handleTechPause_ = function handleTechPause_() {
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.trigger("pause");
  };
  _proto.handleTechEnded_ = function handleTechEnded_() {
    this.addClass("vjs-ended");
    this.removeClass("vjs-waiting");
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }
    this.trigger("ended");
  };
  _proto.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_("duration"));
  };
  _proto.handleTechClick_ = function handleTechClick_(event) {
    if (!this.controls_) {
      return;
    }
    if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== false) {
      if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click === "function") {
        this.options_.userActions.click.call(this, event);
      } else if (this.paused()) {
        silencePromise(this.play());
      } else {
        this.pause();
      }
    }
  };
  _proto.handleTechDoubleClick_ = function handleTechDoubleClick_(event) {
    if (!this.controls_) {
      return;
    }
    var inAllowedEls = Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), function(el) {
      return el.contains(event.target);
    });
    if (!inAllowedEls) {
      if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== false) {
        if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick === "function") {
          this.options_.userActions.doubleClick.call(this, event);
        } else if (this.isFullscreen()) {
          this.exitFullscreen();
        } else {
          this.requestFullscreen();
        }
      }
    }
  };
  _proto.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };
  _proto.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };
  _proto.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };
  _proto.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    if (event.cancelable) {
      event.preventDefault();
    }
  };
  _proto.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };
  _proto.toggleFullscreenClass_ = function toggleFullscreenClass_() {
    if (this.isFullscreen()) {
      this.addClass("vjs-fullscreen");
    } else {
      this.removeClass("vjs-fullscreen");
    }
  };
  _proto.documentFullscreenChange_ = function documentFullscreenChange_(e) {
    var targetPlayer = e.target.player;
    if (targetPlayer && targetPlayer !== this) {
      return;
    }
    var el = this.el();
    var isFs = import_document.default[this.fsApi_.fullscreenElement] === el;
    if (!isFs && el.matches) {
      isFs = el.matches(":" + this.fsApi_.fullscreen);
    } else if (!isFs && el.msMatchesSelector) {
      isFs = el.msMatchesSelector(":" + this.fsApi_.fullscreen);
    }
    this.isFullscreen(isFs);
  };
  _proto.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    var _this9 = this;
    if (data) {
      if (data.nativeIOSFullscreen) {
        this.addClass("vjs-ios-native-fs");
        this.tech_.one("webkitendfullscreen", function() {
          _this9.removeClass("vjs-ios-native-fs");
        });
      }
      this.isFullscreen(data.isFullscreen);
    }
  };
  _proto.handleTechFullscreenError_ = function handleTechFullscreenError_(event, err) {
    this.trigger("fullscreenerror", err);
  };
  _proto.togglePictureInPictureClass_ = function togglePictureInPictureClass_() {
    if (this.isInPictureInPicture()) {
      this.addClass("vjs-picture-in-picture");
    } else {
      this.removeClass("vjs-picture-in-picture");
    }
  };
  _proto.handleTechEnterPictureInPicture_ = function handleTechEnterPictureInPicture_(event) {
    this.isInPictureInPicture(true);
  };
  _proto.handleTechLeavePictureInPicture_ = function handleTechLeavePictureInPicture_(event) {
    this.isInPictureInPicture(false);
  };
  _proto.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();
    this.error(error);
  };
  _proto.handleTechTextData_ = function handleTechTextData_() {
    var data = null;
    if (arguments.length > 1) {
      data = arguments[1];
    }
    this.trigger("textdata", data);
  };
  _proto.getCache = function getCache() {
    return this.cache_;
  };
  _proto.resetCache_ = function resetCache_() {
    this.cache_ = {
      // Right now, the currentTime is not _really_ cached because it is always
      // retrieved from the tech (see: currentTime). However, for completeness,
      // we set it to zero here to ensure that if we do start actually caching
      // it, we reset it along with everything else.
      currentTime: 0,
      initTime: 0,
      inactivityTimeout: this.options_.inactivityTimeout,
      duration: NaN,
      lastVolume: 1,
      lastPlaybackRate: this.defaultPlaybackRate(),
      media: null,
      src: "",
      source: {},
      sources: [],
      playbackRates: [],
      volume: 1
    };
  };
  _proto.techCall_ = function techCall_(method, arg) {
    this.ready(function() {
      if (method in allowedSetters) {
        return set(this.middleware_, this.tech_, method, arg);
      } else if (method in allowedMediators) {
        return mediate(this.middleware_, this.tech_, method, arg);
      }
      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e) {
        log$1(e);
        throw e;
      }
    }, true);
  };
  _proto.techGet_ = function techGet_(method) {
    if (!this.tech_ || !this.tech_.isReady_) {
      return;
    }
    if (method in allowedGetters) {
      return get(this.middleware_, this.tech_, method);
    } else if (method in allowedMediators) {
      return mediate(this.middleware_, this.tech_, method);
    }
    try {
      return this.tech_[method]();
    } catch (e) {
      if (this.tech_[method] === void 0) {
        log$1("Video.js: " + method + " method not defined for " + this.techName_ + " playback technology.", e);
        throw e;
      }
      if (e.name === "TypeError") {
        log$1("Video.js: " + method + " unavailable on " + this.techName_ + " playback technology element.", e);
        this.tech_.isReady_ = false;
        throw e;
      }
      log$1(e);
      throw e;
    }
  };
  _proto.play = function play() {
    var _this10 = this;
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      return new PromiseClass(function(resolve) {
        _this10.play_(resolve);
      });
    }
    return this.play_();
  };
  _proto.play_ = function play_(callback2) {
    var _this11 = this;
    if (callback2 === void 0) {
      callback2 = silencePromise;
    }
    this.playCallbacks_.push(callback2);
    var isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
    var isSafariOrIOS = Boolean(IS_ANY_SAFARI || IS_IOS);
    if (this.waitToPlay_) {
      this.off(["ready", "loadstart"], this.waitToPlay_);
      this.waitToPlay_ = null;
    }
    if (!this.isReady_ || !isSrcReady) {
      this.waitToPlay_ = function(e) {
        _this11.play_();
      };
      this.one(["ready", "loadstart"], this.waitToPlay_);
      if (!isSrcReady && isSafariOrIOS) {
        this.load();
      }
      return;
    }
    var val = this.techGet_("play");
    var isNativeReplay = isSafariOrIOS && this.hasClass("vjs-ended");
    if (isNativeReplay) {
      this.resetProgressBar_();
    }
    if (val === null) {
      this.runPlayTerminatedQueue_();
    } else {
      this.runPlayCallbacks_(val);
    }
  };
  _proto.runPlayTerminatedQueue_ = function runPlayTerminatedQueue_() {
    var queue = this.playTerminatedQueue_.slice(0);
    this.playTerminatedQueue_ = [];
    queue.forEach(function(q) {
      q();
    });
  };
  _proto.runPlayCallbacks_ = function runPlayCallbacks_(val) {
    var callbacks = this.playCallbacks_.slice(0);
    this.playCallbacks_ = [];
    this.playTerminatedQueue_ = [];
    callbacks.forEach(function(cb) {
      cb(val);
    });
  };
  _proto.pause = function pause() {
    this.techCall_("pause");
  };
  _proto.paused = function paused() {
    return this.techGet_("paused") === false ? false : true;
  };
  _proto.played = function played() {
    return this.techGet_("played") || createTimeRanges(0, 0);
  };
  _proto.scrubbing = function scrubbing(isScrubbing) {
    if (typeof isScrubbing === "undefined") {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;
    this.techCall_("setScrubbing", this.scrubbing_);
    if (isScrubbing) {
      this.addClass("vjs-scrubbing");
    } else {
      this.removeClass("vjs-scrubbing");
    }
  };
  _proto.currentTime = function currentTime(seconds) {
    if (typeof seconds !== "undefined") {
      if (seconds < 0) {
        seconds = 0;
      }
      if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
        this.cache_.initTime = seconds;
        this.off("canplay", this.boundApplyInitTime_);
        this.one("canplay", this.boundApplyInitTime_);
        return;
      }
      this.techCall_("setCurrentTime", seconds);
      this.cache_.initTime = 0;
      return;
    }
    this.cache_.currentTime = this.techGet_("currentTime") || 0;
    return this.cache_.currentTime;
  };
  _proto.applyInitTime_ = function applyInitTime_() {
    this.currentTime(this.cache_.initTime);
  };
  _proto.duration = function duration5(seconds) {
    if (seconds === void 0) {
      return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
    }
    seconds = parseFloat(seconds);
    if (seconds < 0) {
      seconds = Infinity;
    }
    if (seconds !== this.cache_.duration) {
      this.cache_.duration = seconds;
      if (seconds === Infinity) {
        this.addClass("vjs-live");
      } else {
        this.removeClass("vjs-live");
      }
      if (!isNaN(seconds)) {
        this.trigger("durationchange");
      }
    }
  };
  _proto.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };
  _proto.remainingTimeDisplay = function remainingTimeDisplay() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  };
  _proto.buffered = function buffered() {
    var buffered2 = this.techGet_("buffered");
    if (!buffered2 || !buffered2.length) {
      buffered2 = createTimeRanges(0, 0);
    }
    return buffered2;
  };
  _proto.bufferedPercent = function bufferedPercent$1() {
    return bufferedPercent(this.buffered(), this.duration());
  };
  _proto.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered();
    var duration5 = this.duration();
    var end = buffered.end(buffered.length - 1);
    if (end > duration5) {
      end = duration5;
    }
    return end;
  };
  _proto.volume = function volume(percentAsDecimal) {
    var vol;
    if (percentAsDecimal !== void 0) {
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
      this.cache_.volume = vol;
      this.techCall_("setVolume", vol);
      if (vol > 0) {
        this.lastVolume_(vol);
      }
      return;
    }
    vol = parseFloat(this.techGet_("volume"));
    return isNaN(vol) ? 1 : vol;
  };
  _proto.muted = function muted(_muted) {
    if (_muted !== void 0) {
      this.techCall_("setMuted", _muted);
      return;
    }
    return this.techGet_("muted") || false;
  };
  _proto.defaultMuted = function defaultMuted(_defaultMuted) {
    if (_defaultMuted !== void 0) {
      return this.techCall_("setDefaultMuted", _defaultMuted);
    }
    return this.techGet_("defaultMuted") || false;
  };
  _proto.lastVolume_ = function lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  };
  _proto.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_("supportsFullScreen") || false;
  };
  _proto.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== void 0) {
      var oldValue = this.isFullscreen_;
      this.isFullscreen_ = Boolean(isFS);
      if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
        this.trigger("fullscreenchange");
      }
      this.toggleFullscreenClass_();
      return;
    }
    return this.isFullscreen_;
  };
  _proto.requestFullscreen = function requestFullscreen(fullscreenOptions) {
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      var self2 = this;
      return new PromiseClass(function(resolve, reject) {
        function offHandler() {
          self2.off("fullscreenerror", errorHandler);
          self2.off("fullscreenchange", changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e, err) {
          offHandler();
          reject(err);
        }
        self2.one("fullscreenchange", changeHandler);
        self2.one("fullscreenerror", errorHandler);
        var promise = self2.requestFullscreenHelper_(fullscreenOptions);
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    return this.requestFullscreenHelper_();
  };
  _proto.requestFullscreenHelper_ = function requestFullscreenHelper_(fullscreenOptions) {
    var _this12 = this;
    var fsOptions;
    if (!this.fsApi_.prefixed) {
      fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
      if (fullscreenOptions !== void 0) {
        fsOptions = fullscreenOptions;
      }
    }
    if (this.fsApi_.requestFullscreen) {
      var promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
      if (promise) {
        promise.then(function() {
          return _this12.isFullscreen(true);
        }, function() {
          return _this12.isFullscreen(false);
        });
      }
      return promise;
    } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
      this.techCall_("enterFullScreen");
    } else {
      this.enterFullWindow();
    }
  };
  _proto.exitFullscreen = function exitFullscreen() {
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      var self2 = this;
      return new PromiseClass(function(resolve, reject) {
        function offHandler() {
          self2.off("fullscreenerror", errorHandler);
          self2.off("fullscreenchange", changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e, err) {
          offHandler();
          reject(err);
        }
        self2.one("fullscreenchange", changeHandler);
        self2.one("fullscreenerror", errorHandler);
        var promise = self2.exitFullscreenHelper_();
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    return this.exitFullscreenHelper_();
  };
  _proto.exitFullscreenHelper_ = function exitFullscreenHelper_() {
    var _this13 = this;
    if (this.fsApi_.requestFullscreen) {
      var promise = import_document.default[this.fsApi_.exitFullscreen]();
      if (promise) {
        silencePromise(promise.then(function() {
          return _this13.isFullscreen(false);
        }));
      }
      return promise;
    } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
      this.techCall_("exitFullScreen");
    } else {
      this.exitFullWindow();
    }
  };
  _proto.enterFullWindow = function enterFullWindow() {
    this.isFullscreen(true);
    this.isFullWindow = true;
    this.docOrigOverflow = import_document.default.documentElement.style.overflow;
    on(import_document.default, "keydown", this.boundFullWindowOnEscKey_);
    import_document.default.documentElement.style.overflow = "hidden";
    addClass(import_document.default.body, "vjs-full-window");
    this.trigger("enterFullWindow");
  };
  _proto.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (import_keycode.default.isEventKey(event, "Esc")) {
      if (this.isFullscreen() === true) {
        if (!this.isFullWindow) {
          this.exitFullscreen();
        } else {
          this.exitFullWindow();
        }
      }
    }
  };
  _proto.exitFullWindow = function exitFullWindow() {
    this.isFullscreen(false);
    this.isFullWindow = false;
    off(import_document.default, "keydown", this.boundFullWindowOnEscKey_);
    import_document.default.documentElement.style.overflow = this.docOrigOverflow;
    removeClass(import_document.default.body, "vjs-full-window");
    this.trigger("exitFullWindow");
  };
  _proto.disablePictureInPicture = function disablePictureInPicture(value) {
    if (value === void 0) {
      return this.techGet_("disablePictureInPicture");
    }
    this.techCall_("setDisablePictureInPicture", value);
    this.options_.disablePictureInPicture = value;
    this.trigger("disablepictureinpicturechanged");
  };
  _proto.isInPictureInPicture = function isInPictureInPicture(isPiP) {
    if (isPiP !== void 0) {
      this.isInPictureInPicture_ = !!isPiP;
      this.togglePictureInPictureClass_();
      return;
    }
    return !!this.isInPictureInPicture_;
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    if ("pictureInPictureEnabled" in import_document.default && this.disablePictureInPicture() === false) {
      return this.techGet_("requestPictureInPicture");
    }
  };
  _proto.exitPictureInPicture = function exitPictureInPicture() {
    if ("pictureInPictureEnabled" in import_document.default) {
      return import_document.default.exitPictureInPicture();
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    var userActions = this.options_.userActions;
    if (!userActions || !userActions.hotkeys) {
      return;
    }
    var excludeElement = function excludeElement2(el) {
      var tagName = el.tagName.toLowerCase();
      if (el.isContentEditable) {
        return true;
      }
      var allowedInputTypes = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
      if (tagName === "input") {
        return allowedInputTypes.indexOf(el.type) === -1;
      }
      var excludedTags = ["textarea"];
      return excludedTags.indexOf(tagName) !== -1;
    };
    if (excludeElement(this.el_.ownerDocument.activeElement)) {
      return;
    }
    if (typeof userActions.hotkeys === "function") {
      userActions.hotkeys.call(this, event);
    } else {
      this.handleHotkeys(event);
    }
  };
  _proto.handleHotkeys = function handleHotkeys(event) {
    var hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
    var _hotkeys$fullscreenKe = hotkeys.fullscreenKey, fullscreenKey = _hotkeys$fullscreenKe === void 0 ? function(keydownEvent) {
      return import_keycode.default.isEventKey(keydownEvent, "f");
    } : _hotkeys$fullscreenKe, _hotkeys$muteKey = hotkeys.muteKey, muteKey = _hotkeys$muteKey === void 0 ? function(keydownEvent) {
      return import_keycode.default.isEventKey(keydownEvent, "m");
    } : _hotkeys$muteKey, _hotkeys$playPauseKey = hotkeys.playPauseKey, playPauseKey = _hotkeys$playPauseKey === void 0 ? function(keydownEvent) {
      return import_keycode.default.isEventKey(keydownEvent, "k") || import_keycode.default.isEventKey(keydownEvent, "Space");
    } : _hotkeys$playPauseKey;
    if (fullscreenKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var FSToggle = Component$1.getComponent("FullscreenToggle");
      if (import_document.default[this.fsApi_.fullscreenEnabled] !== false) {
        FSToggle.prototype.handleClick.call(this, event);
      }
    } else if (muteKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var MuteToggle2 = Component$1.getComponent("MuteToggle");
      MuteToggle2.prototype.handleClick.call(this, event);
    } else if (playPauseKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var PlayToggle2 = Component$1.getComponent("PlayToggle");
      PlayToggle2.prototype.handleClick.call(this, event);
    }
  };
  _proto.canPlayType = function canPlayType3(type2) {
    var can;
    for (var i = 0, j2 = this.options_.techOrder; i < j2.length; i++) {
      var techName = j2[i];
      var tech = Tech.getTech(techName);
      if (!tech) {
        tech = Component$1.getComponent(techName);
      }
      if (!tech) {
        log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }
      if (tech.isSupported()) {
        can = tech.canPlayType(type2);
        if (can) {
          return can;
        }
      }
    }
    return "";
  };
  _proto.selectSource = function selectSource(sources) {
    var _this14 = this;
    var techs = this.options_.techOrder.map(function(techName) {
      return [techName, Tech.getTech(techName)];
    }).filter(function(_ref) {
      var techName = _ref[0], tech = _ref[1];
      if (tech) {
        return tech.isSupported();
      }
      log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair2(outerArray, innerArray, tester) {
      var found;
      outerArray.some(function(outerChoice) {
        return innerArray.some(function(innerChoice) {
          found = tester(outerChoice, innerChoice);
          if (found) {
            return true;
          }
        });
      });
      return found;
    };
    var foundSourceAndTech;
    var flip = function flip2(fn) {
      return function(a, b2) {
        return fn(b2, a);
      };
    };
    var finder = function finder2(_ref2, source) {
      var techName = _ref2[0], tech = _ref2[1];
      if (tech.canPlaySource(source, _this14.options_[techName.toLowerCase()])) {
        return {
          source,
          tech: techName
        };
      }
    };
    if (this.options_.sourceOrder) {
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
    } else {
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }
    return foundSourceAndTech || false;
  };
  _proto.handleSrc_ = function handleSrc_(source, isRetry) {
    var _this15 = this;
    if (typeof source === "undefined") {
      return this.cache_.src || "";
    }
    if (this.resetRetryOnError_) {
      this.resetRetryOnError_();
    }
    var sources = filterSource(source);
    if (!sources.length) {
      this.setTimeout(function() {
        this.error({
          code: 4,
          message: this.options_.notSupportedMessage
        });
      }, 0);
      return;
    }
    this.changingSrc_ = true;
    if (!isRetry) {
      this.cache_.sources = sources;
    }
    this.updateSourceCaches_(sources[0]);
    setSource(this, sources[0], function(middlewareSource, mws) {
      _this15.middleware_ = mws;
      if (!isRetry) {
        _this15.cache_.sources = sources;
      }
      _this15.updateSourceCaches_(middlewareSource);
      var err = _this15.src_(middlewareSource);
      if (err) {
        if (sources.length > 1) {
          return _this15.handleSrc_(sources.slice(1));
        }
        _this15.changingSrc_ = false;
        _this15.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0);
        _this15.triggerReady();
        return;
      }
      setTech(mws, _this15.tech_);
    });
    if (this.options_.retryOnError && sources.length > 1) {
      var retry = function retry2() {
        _this15.error(null);
        _this15.handleSrc_(sources.slice(1), true);
      };
      var stopListeningForErrors = function stopListeningForErrors2() {
        _this15.off("error", retry);
      };
      this.one("error", retry);
      this.one("playing", stopListeningForErrors);
      this.resetRetryOnError_ = function() {
        _this15.off("error", retry);
        _this15.off("playing", stopListeningForErrors);
      };
    }
  };
  _proto.src = function src(source) {
    return this.handleSrc_(source, false);
  };
  _proto.src_ = function src_(source) {
    var _this16 = this;
    var sourceTech = this.selectSource([source]);
    if (!sourceTech) {
      return true;
    }
    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;
      this.loadTech_(sourceTech.tech, sourceTech.source);
      this.tech_.ready(function() {
        _this16.changingSrc_ = false;
      });
      return false;
    }
    this.ready(function() {
      if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) {
        this.techCall_("setSource", source);
      } else {
        this.techCall_("src", source.src);
      }
      this.changingSrc_ = false;
    }, true);
    return false;
  };
  _proto.load = function load() {
    this.techCall_("load");
  };
  _proto.reset = function reset3() {
    var _this17 = this;
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (this.paused() || !PromiseClass) {
      this.doReset_();
    } else {
      var playPromise = this.play();
      silencePromise(playPromise.then(function() {
        return _this17.doReset_();
      }));
    }
  };
  _proto.doReset_ = function doReset_() {
    if (this.tech_) {
      this.tech_.clearTracks("text");
    }
    this.resetCache_();
    this.poster("");
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_("reset");
    this.resetControlBarUI_();
    if (isEvented(this)) {
      this.trigger("playerreset");
    }
  };
  _proto.resetControlBarUI_ = function resetControlBarUI_() {
    this.resetProgressBar_();
    this.resetPlaybackRate_();
    this.resetVolumeBar_();
  };
  _proto.resetProgressBar_ = function resetProgressBar_() {
    this.currentTime(0);
    var _ref3 = this.controlBar || {}, durationDisplay = _ref3.durationDisplay, remainingTimeDisplay = _ref3.remainingTimeDisplay;
    if (durationDisplay) {
      durationDisplay.updateContent();
    }
    if (remainingTimeDisplay) {
      remainingTimeDisplay.updateContent();
    }
  };
  _proto.resetPlaybackRate_ = function resetPlaybackRate_() {
    this.playbackRate(this.defaultPlaybackRate());
    this.handleTechRateChange_();
  };
  _proto.resetVolumeBar_ = function resetVolumeBar_() {
    this.volume(1);
    this.trigger("volumechange");
  };
  _proto.currentSources = function currentSources() {
    var source = this.currentSource();
    var sources = [];
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }
    return this.cache_.sources || sources;
  };
  _proto.currentSource = function currentSource() {
    return this.cache_.source || {};
  };
  _proto.currentSrc = function currentSrc() {
    return this.currentSource() && this.currentSource().src || "";
  };
  _proto.currentType = function currentType() {
    return this.currentSource() && this.currentSource().type || "";
  };
  _proto.preload = function preload(value) {
    if (value !== void 0) {
      this.techCall_("setPreload", value);
      this.options_.preload = value;
      return;
    }
    return this.techGet_("preload");
  };
  _proto.autoplay = function autoplay(value) {
    if (value === void 0) {
      return this.options_.autoplay || false;
    }
    var techAutoplay;
    if (typeof value === "string" && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
      this.options_.autoplay = value;
      this.manualAutoplay_(typeof value === "string" ? value : "play");
      techAutoplay = false;
    } else if (!value) {
      this.options_.autoplay = false;
    } else {
      this.options_.autoplay = true;
    }
    techAutoplay = typeof techAutoplay === "undefined" ? this.options_.autoplay : techAutoplay;
    if (this.tech_) {
      this.techCall_("setAutoplay", techAutoplay);
    }
  };
  _proto.playsinline = function playsinline(value) {
    if (value !== void 0) {
      this.techCall_("setPlaysinline", value);
      this.options_.playsinline = value;
      return this;
    }
    return this.techGet_("playsinline");
  };
  _proto.loop = function loop(value) {
    if (value !== void 0) {
      this.techCall_("setLoop", value);
      this.options_.loop = value;
      return;
    }
    return this.techGet_("loop");
  };
  _proto.poster = function poster(src) {
    if (src === void 0) {
      return this.poster_;
    }
    if (!src) {
      src = "";
    }
    if (src === this.poster_) {
      return;
    }
    this.poster_ = src;
    this.techCall_("setPoster", src);
    this.isPosterFromTech_ = false;
    this.trigger("posterchange");
  };
  _proto.handleTechPosterChange_ = function handleTechPosterChange_() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      var newPoster = this.tech_.poster() || "";
      if (newPoster !== this.poster_) {
        this.poster_ = newPoster;
        this.isPosterFromTech_ = true;
        this.trigger("posterchange");
      }
    }
  };
  _proto.controls = function controls(bool) {
    if (bool === void 0) {
      return !!this.controls_;
    }
    bool = !!bool;
    if (this.controls_ === bool) {
      return;
    }
    this.controls_ = bool;
    if (this.usingNativeControls()) {
      this.techCall_("setControls", bool);
    }
    if (this.controls_) {
      this.removeClass("vjs-controls-disabled");
      this.addClass("vjs-controls-enabled");
      this.trigger("controlsenabled");
      if (!this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }
    } else {
      this.removeClass("vjs-controls-enabled");
      this.addClass("vjs-controls-disabled");
      this.trigger("controlsdisabled");
      if (!this.usingNativeControls()) {
        this.removeTechControlsListeners_();
      }
    }
  };
  _proto.usingNativeControls = function usingNativeControls(bool) {
    if (bool === void 0) {
      return !!this.usingNativeControls_;
    }
    bool = !!bool;
    if (this.usingNativeControls_ === bool) {
      return;
    }
    this.usingNativeControls_ = bool;
    if (this.usingNativeControls_) {
      this.addClass("vjs-using-native-controls");
      this.trigger("usingnativecontrols");
    } else {
      this.removeClass("vjs-using-native-controls");
      this.trigger("usingcustomcontrols");
    }
  };
  _proto.error = function error(err) {
    var _this18 = this;
    if (err === void 0) {
      return this.error_ || null;
    }
    hooks("beforeerror").forEach(function(hookFunction) {
      var newErr = hookFunction(_this18, err);
      if (!(isObject3(newErr) && !Array.isArray(newErr) || typeof newErr === "string" || typeof newErr === "number" || newErr === null)) {
        _this18.log.error("please return a value that MediaError expects in beforeerror hooks");
        return;
      }
      err = newErr;
    });
    if (this.options_.suppressNotSupportedError && err && err.code === 4) {
      var triggerSuppressedError = function triggerSuppressedError2() {
        this.error(err);
      };
      this.options_.suppressNotSupportedError = false;
      this.any(["click", "touchstart"], triggerSuppressedError);
      this.one("loadstart", function() {
        this.off(["click", "touchstart"], triggerSuppressedError);
      });
      return;
    }
    if (err === null) {
      this.error_ = err;
      this.removeClass("vjs-error");
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }
    this.error_ = new MediaError(err);
    this.addClass("vjs-error");
    log$1.error("(CODE:" + this.error_.code + " " + MediaError.errorTypes[this.error_.code] + ")", this.error_.message, this.error_);
    this.trigger("error");
    hooks("error").forEach(function(hookFunction) {
      return hookFunction(_this18, _this18.error_);
    });
    return;
  };
  _proto.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };
  _proto.userActive = function userActive(bool) {
    if (bool === void 0) {
      return this.userActive_;
    }
    bool = !!bool;
    if (bool === this.userActive_) {
      return;
    }
    this.userActive_ = bool;
    if (this.userActive_) {
      this.userActivity_ = true;
      this.removeClass("vjs-user-inactive");
      this.addClass("vjs-user-active");
      this.trigger("useractive");
      return;
    }
    if (this.tech_) {
      this.tech_.one("mousemove", function(e) {
        e.stopPropagation();
        e.preventDefault();
      });
    }
    this.userActivity_ = false;
    this.removeClass("vjs-user-active");
    this.addClass("vjs-user-inactive");
    this.trigger("userinactive");
  };
  _proto.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress;
    var lastMoveX;
    var lastMoveY;
    var handleActivity = bind(this, this.reportUserActivity);
    var handleMouseMove = function handleMouseMove2(e) {
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };
    var handleMouseDown = function handleMouseDown2() {
      handleActivity();
      this.clearInterval(mouseInProgress);
      mouseInProgress = this.setInterval(handleActivity, 250);
    };
    var handleMouseUpAndMouseLeave = function handleMouseUpAndMouseLeave2(event) {
      handleActivity();
      this.clearInterval(mouseInProgress);
    };
    this.on("mousedown", handleMouseDown);
    this.on("mousemove", handleMouseMove);
    this.on("mouseup", handleMouseUpAndMouseLeave);
    this.on("mouseleave", handleMouseUpAndMouseLeave);
    var controlBar = this.getChild("controlBar");
    if (controlBar && !IS_IOS && !IS_ANDROID) {
      controlBar.on("mouseenter", function(event) {
        if (this.player().options_.inactivityTimeout !== 0) {
          this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
        }
        this.player().options_.inactivityTimeout = 0;
      });
      controlBar.on("mouseleave", function(event) {
        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
      });
    }
    this.on("keydown", handleActivity);
    this.on("keyup", handleActivity);
    var inactivityTimeout;
    this.setInterval(function() {
      if (!this.userActivity_) {
        return;
      }
      this.userActivity_ = false;
      this.userActive(true);
      this.clearTimeout(inactivityTimeout);
      var timeout = this.options_.inactivityTimeout;
      if (timeout <= 0) {
        return;
      }
      inactivityTimeout = this.setTimeout(function() {
        if (!this.userActivity_) {
          this.userActive(false);
        }
      }, timeout);
    }, 250);
  };
  _proto.playbackRate = function playbackRate(rate) {
    if (rate !== void 0) {
      this.techCall_("setPlaybackRate", rate);
      return;
    }
    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
    }
    return 1;
  };
  _proto.defaultPlaybackRate = function defaultPlaybackRate(rate) {
    if (rate !== void 0) {
      return this.techCall_("setDefaultPlaybackRate", rate);
    }
    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_("defaultPlaybackRate");
    }
    return 1;
  };
  _proto.isAudio = function isAudio(bool) {
    if (bool !== void 0) {
      this.isAudio_ = !!bool;
      return;
    }
    return !!this.isAudio_;
  };
  _proto.enableAudioOnlyUI_ = function enableAudioOnlyUI_() {
    var _this19 = this;
    this.addClass("vjs-audio-only-mode");
    var playerChildren = this.children();
    var controlBar = this.getChild("ControlBar");
    var controlBarHeight = controlBar && controlBar.currentHeight();
    playerChildren.forEach(function(child) {
      if (child === controlBar) {
        return;
      }
      if (child.el_ && !child.hasClass("vjs-hidden")) {
        child.hide();
        _this19.audioOnlyCache_.hiddenChildren.push(child);
      }
    });
    this.audioOnlyCache_.playerHeight = this.currentHeight();
    this.height(controlBarHeight);
    this.trigger("audioonlymodechange");
  };
  _proto.disableAudioOnlyUI_ = function disableAudioOnlyUI_() {
    this.removeClass("vjs-audio-only-mode");
    this.audioOnlyCache_.hiddenChildren.forEach(function(child) {
      return child.show();
    });
    this.height(this.audioOnlyCache_.playerHeight);
    this.trigger("audioonlymodechange");
  };
  _proto.audioOnlyMode = function audioOnlyMode(value) {
    var _this20 = this;
    if (typeof value !== "boolean" || value === this.audioOnlyMode_) {
      return this.audioOnlyMode_;
    }
    this.audioOnlyMode_ = value;
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      if (value) {
        var exitPromises = [];
        if (this.isInPictureInPicture()) {
          exitPromises.push(this.exitPictureInPicture());
        }
        if (this.isFullscreen()) {
          exitPromises.push(this.exitFullscreen());
        }
        if (this.audioPosterMode()) {
          exitPromises.push(this.audioPosterMode(false));
        }
        return PromiseClass.all(exitPromises).then(function() {
          return _this20.enableAudioOnlyUI_();
        });
      }
      return PromiseClass.resolve().then(function() {
        return _this20.disableAudioOnlyUI_();
      });
    }
    if (value) {
      if (this.isInPictureInPicture()) {
        this.exitPictureInPicture();
      }
      if (this.isFullscreen()) {
        this.exitFullscreen();
      }
      this.enableAudioOnlyUI_();
    } else {
      this.disableAudioOnlyUI_();
    }
  };
  _proto.enablePosterModeUI_ = function enablePosterModeUI_() {
    var tech = this.tech_ && this.tech_;
    tech.hide();
    this.addClass("vjs-audio-poster-mode");
    this.trigger("audiopostermodechange");
  };
  _proto.disablePosterModeUI_ = function disablePosterModeUI_() {
    var tech = this.tech_ && this.tech_;
    tech.show();
    this.removeClass("vjs-audio-poster-mode");
    this.trigger("audiopostermodechange");
  };
  _proto.audioPosterMode = function audioPosterMode(value) {
    var _this21 = this;
    if (typeof value !== "boolean" || value === this.audioPosterMode_) {
      return this.audioPosterMode_;
    }
    this.audioPosterMode_ = value;
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      if (value) {
        if (this.audioOnlyMode()) {
          var audioOnlyModePromise = this.audioOnlyMode(false);
          return audioOnlyModePromise.then(function() {
            _this21.enablePosterModeUI_();
          });
        }
        return PromiseClass.resolve().then(function() {
          _this21.enablePosterModeUI_();
        });
      }
      return PromiseClass.resolve().then(function() {
        _this21.disablePosterModeUI_();
      });
    }
    if (value) {
      if (this.audioOnlyMode()) {
        this.audioOnlyMode(false);
      }
      this.enablePosterModeUI_();
      return;
    }
    this.disablePosterModeUI_();
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(obj) {
    if (obj === void 0) {
      obj = {};
    }
    var _obj = obj, track = _obj.track;
    if (!track) {
      track = obj;
    }
    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return this.techGet_("getVideoPlaybackQuality");
  };
  _proto.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };
  _proto.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };
  _proto.language = function language(code) {
    if (code === void 0) {
      return this.language_;
    }
    if (this.language_ !== String(code).toLowerCase()) {
      this.language_ = String(code).toLowerCase();
      if (isEvented(this)) {
        this.trigger("languagechange");
      }
    }
  };
  _proto.languages = function languages() {
    return mergeOptions$3(Player2.prototype.options_.languages, this.languages_);
  };
  _proto.toJSON = function toJSON() {
    var options = mergeOptions$3(this.options_);
    var tracks = options.tracks;
    options.tracks = [];
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      track = mergeOptions$3(track);
      track.player = void 0;
      options.tracks[i] = track;
    }
    return options;
  };
  _proto.createModal = function createModal(content, options) {
    var _this22 = this;
    options = options || {};
    options.content = content || "";
    var modal = new ModalDialog(this, options);
    this.addChild(modal);
    modal.on("dispose", function() {
      _this22.removeChild(modal);
    });
    modal.open();
    return modal;
  };
  _proto.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {
    if (!this.responsive()) {
      return;
    }
    var currentBreakpoint = this.currentBreakpoint();
    var currentWidth = this.currentWidth();
    for (var i = 0; i < BREAKPOINT_ORDER.length; i++) {
      var candidateBreakpoint = BREAKPOINT_ORDER[i];
      var maxWidth = this.breakpoints_[candidateBreakpoint];
      if (currentWidth <= maxWidth) {
        if (currentBreakpoint === candidateBreakpoint) {
          return;
        }
        if (currentBreakpoint) {
          this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
        }
        this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
        this.breakpoint_ = candidateBreakpoint;
        break;
      }
    }
  };
  _proto.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {
    var className = this.currentBreakpointClass();
    this.breakpoint_ = "";
    if (className) {
      this.removeClass(className);
    }
  };
  _proto.breakpoints = function breakpoints(_breakpoints) {
    if (_breakpoints === void 0) {
      return assign(this.breakpoints_);
    }
    this.breakpoint_ = "";
    this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints);
    this.updateCurrentBreakpoint_();
    return assign(this.breakpoints_);
  };
  _proto.responsive = function responsive(value) {
    if (value === void 0) {
      return this.responsive_;
    }
    value = Boolean(value);
    var current = this.responsive_;
    if (value === current) {
      return;
    }
    this.responsive_ = value;
    if (value) {
      this.on("playerresize", this.boundUpdateCurrentBreakpoint_);
      this.updateCurrentBreakpoint_();
    } else {
      this.off("playerresize", this.boundUpdateCurrentBreakpoint_);
      this.removeCurrentBreakpoint_();
    }
    return value;
  };
  _proto.currentBreakpoint = function currentBreakpoint() {
    return this.breakpoint_;
  };
  _proto.currentBreakpointClass = function currentBreakpointClass() {
    return BREAKPOINT_CLASSES[this.breakpoint_] || "";
  };
  _proto.loadMedia = function loadMedia(media, ready) {
    var _this23 = this;
    if (!media || typeof media !== "object") {
      return;
    }
    this.reset();
    this.cache_.media = mergeOptions$3(media);
    var _this$cache_$media = this.cache_.media, artwork = _this$cache_$media.artwork, poster = _this$cache_$media.poster, src = _this$cache_$media.src, textTracks = _this$cache_$media.textTracks;
    if (!artwork && poster) {
      this.cache_.media.artwork = [{
        src: poster,
        type: getMimetype(poster)
      }];
    }
    if (src) {
      this.src(src);
    }
    if (poster) {
      this.poster(poster);
    }
    if (Array.isArray(textTracks)) {
      textTracks.forEach(function(tt) {
        return _this23.addRemoteTextTrack(tt, false);
      });
    }
    this.ready(ready);
  };
  _proto.getMedia = function getMedia() {
    if (!this.cache_.media) {
      var poster = this.poster();
      var src = this.currentSources();
      var textTracks = Array.prototype.map.call(this.remoteTextTracks(), function(tt) {
        return {
          kind: tt.kind,
          label: tt.label,
          language: tt.language,
          src: tt.src
        };
      });
      var media = {
        src,
        textTracks
      };
      if (poster) {
        media.poster = poster;
        media.artwork = [{
          src: media.poster,
          type: getMimetype(media.poster)
        }];
      }
      return media;
    }
    return mergeOptions$3(this.cache_.media);
  };
  Player2.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      sources: [],
      tracks: []
    };
    var tagOptions = getAttributes(tag);
    var dataSetup = tagOptions["data-setup"];
    if (hasClass(tag, "vjs-fill")) {
      tagOptions.fill = true;
    }
    if (hasClass(tag, "vjs-fluid")) {
      tagOptions.fluid = true;
    }
    if (dataSetup !== null) {
      var _safeParseTuple = (0, import_tuple.default)(dataSetup || "{}"), err = _safeParseTuple[0], data = _safeParseTuple[1];
      if (err) {
        log$1.error(err);
      }
      assign(tagOptions, data);
    }
    assign(baseOptions, tagOptions);
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;
      for (var i = 0, j2 = children.length; i < j2; i++) {
        var child = children[i];
        var childName = child.nodeName.toLowerCase();
        if (childName === "source") {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === "track") {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }
    return baseOptions;
  };
  _proto.flexNotSupported_ = function flexNotSupported_() {
    var elem = import_document.default.createElement("i");
    return !("flexBasis" in elem.style || "webkitFlexBasis" in elem.style || "mozFlexBasis" in elem.style || "msFlexBasis" in elem.style || // IE10-specific (2012 flex spec), available for completeness
    "msFlexOrder" in elem.style);
  };
  _proto.debug = function debug(enabled) {
    if (enabled === void 0) {
      return this.debugEnabled_;
    }
    if (enabled) {
      this.trigger("debugon");
      this.previousLogLevel_ = this.log.level;
      this.log.level("debug");
      this.debugEnabled_ = true;
    } else {
      this.trigger("debugoff");
      this.log.level(this.previousLogLevel_);
      this.previousLogLevel_ = void 0;
      this.debugEnabled_ = false;
    }
  };
  _proto.playbackRates = function playbackRates(newRates) {
    if (newRates === void 0) {
      return this.cache_.playbackRates;
    }
    if (!Array.isArray(newRates)) {
      return;
    }
    if (!newRates.every(function(rate) {
      return typeof rate === "number";
    })) {
      return;
    }
    this.cache_.playbackRates = newRates;
    this.trigger("playbackrateschange");
  };
  return Player2;
}(Component$1);
ALL.names.forEach(function(name) {
  var props = ALL[name];
  Player.prototype[props.getterName] = function() {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});
Player.prototype.crossorigin = Player.prototype.crossOrigin;
Player.players = {};
var navigator = import_window6.default.navigator;
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,
  html5: {},
  // default inactivity timeout
  inactivityTimeout: 2e3,
  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],
  liveui: false,
  // Included control sets
  children: ["mediaLoader", "posterImage", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
  language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || "en",
  // locales and their language translations
  languages: {},
  // Default message to show when a video cannot be played.
  notSupportedMessage: "No compatible source was found for this media.",
  normalizeAutoplay: false,
  fullscreen: {
    options: {
      navigationUI: "hide"
    }
  },
  breakpoints: {},
  responsive: false,
  audioOnlyMode: false,
  audioPosterMode: false
};
[
  /**
   * Returns whether or not the player is in the "ended" state.
   *
   * @return {Boolean} True if the player is in the ended state, false if not.
   * @method Player#ended
   */
  "ended",
  /**
   * Returns whether or not the player is in the "seeking" state.
   *
   * @return {Boolean} True if the player is in the seeking state, false if not.
   * @method Player#seeking
   */
  "seeking",
  /**
   * Returns the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @return {TimeRanges} the seekable intervals of the media timeline
   * @method Player#seekable
   */
  "seekable",
  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {number} the current network activity state
   * @method Player#networkState
   */
  "networkState",
  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {number} the current playback rendering state
   * @method Player#readyState
   */
  "readyState"
].forEach(function(fn) {
  Player.prototype[fn] = function() {
    return this.techGet_(fn);
  };
});
TECH_EVENTS_RETRIGGER.forEach(function(event) {
  Player.prototype["handleTech" + toTitleCase$1(event) + "_"] = function() {
    return this.trigger(event);
  };
});
Component$1.registerComponent("Player", Player);
var BASE_PLUGIN_NAME = "plugin";
var PLUGIN_CACHE_KEY = "activePlugins_";
var pluginStorage = {};
var pluginExists = function pluginExists2(name) {
  return pluginStorage.hasOwnProperty(name);
};
var getPlugin = function getPlugin2(name) {
  return pluginExists(name) ? pluginStorage[name] : void 0;
};
var markPluginAsActive = function markPluginAsActive2(player, name) {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};
var triggerSetupEvent = function triggerSetupEvent2(player, hash, before) {
  var eventName = (before ? "before" : "") + "pluginsetup";
  player.trigger(eventName, hash);
  player.trigger(eventName + ":" + hash.name, hash);
};
var createBasicPlugin = function createBasicPlugin2(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper2() {
    triggerSetupEvent(this, {
      name,
      plugin,
      instance: null
    }, true);
    var instance = plugin.apply(this, arguments);
    markPluginAsActive(this, name);
    triggerSetupEvent(this, {
      name,
      plugin,
      instance
    });
    return instance;
  };
  Object.keys(plugin).forEach(function(prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });
  return basicPluginWrapper;
};
var createPluginFactory = function createPluginFactory2(name, PluginSubClass) {
  PluginSubClass.prototype.name = name;
  return function() {
    triggerSetupEvent(this, {
      name,
      plugin: PluginSubClass,
      instance: null
    }, true);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var instance = _construct(PluginSubClass, [this].concat(args));
    this[name] = function() {
      return instance;
    };
    triggerSetupEvent(this, instance.getEventHash());
    return instance;
  };
};
var Plugin = function() {
  function Plugin2(player) {
    if (this.constructor === Plugin2) {
      throw new Error("Plugin must be sub-classed; not directly instantiated.");
    }
    this.player = player;
    if (!this.log) {
      this.log = this.player.log.createLogger(this.name);
    }
    evented(this);
    delete this.trigger;
    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);
    this.dispose = this.dispose.bind(this);
    player.on("dispose", this.dispose);
  }
  var _proto = Plugin2.prototype;
  _proto.version = function version2() {
    return this.constructor.VERSION;
  };
  _proto.getEventHash = function getEventHash(hash) {
    if (hash === void 0) {
      hash = {};
    }
    hash.name = this.name;
    hash.plugin = this.constructor;
    hash.instance = this;
    return hash;
  };
  _proto.trigger = function trigger$12(event, hash) {
    if (hash === void 0) {
      hash = {};
    }
    return trigger(this.eventBusEl_, event, this.getEventHash(hash));
  };
  _proto.handleStateChanged = function handleStateChanged(e) {
  };
  _proto.dispose = function dispose() {
    var name = this.name, player = this.player;
    this.trigger("dispose");
    this.off();
    player.off("dispose", this.dispose);
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;
    player[name] = createPluginFactory(name, pluginStorage[name]);
  };
  Plugin2.isBasic = function isBasic(plugin) {
    var p = typeof plugin === "string" ? getPlugin(plugin) : plugin;
    return typeof p === "function" && !Plugin2.prototype.isPrototypeOf(p.prototype);
  };
  Plugin2.registerPlugin = function registerPlugin(name, plugin) {
    if (typeof name !== "string") {
      throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + typeof name + ".");
    }
    if (pluginExists(name)) {
      log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
    }
    if (typeof plugin !== "function") {
      throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + typeof plugin + ".");
    }
    pluginStorage[name] = plugin;
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin2.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }
    return plugin;
  };
  Plugin2.deregisterPlugin = function deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error("Cannot de-register base plugin.");
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  };
  Plugin2.getPlugins = function getPlugins(names) {
    if (names === void 0) {
      names = Object.keys(pluginStorage);
    }
    var result;
    names.forEach(function(name) {
      var plugin = getPlugin(name);
      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });
    return result;
  };
  Plugin2.getPluginVersion = function getPluginVersion(name) {
    var plugin = getPlugin(name);
    return plugin && plugin.VERSION || "";
  };
  return Plugin2;
}();
Plugin.getPlugin = getPlugin;
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
Player.prototype.usingPlugin = function(name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};
Player.prototype.hasPlugin = function(name) {
  return !!pluginExists(name);
};
var hasLogged = false;
var extend = function extend2(superClass, subClassMethods) {
  if (subClassMethods === void 0) {
    subClassMethods = {};
  }
  if (!hasLogged) {
    log$1.warn("videojs.extend is deprecated as of Video.js 7.22.0 and will be removed in Video.js 8.0.0");
    hasLogged = true;
  }
  var subClass = function subClass2() {
    superClass.apply(this, arguments);
  };
  var methods = {};
  if (typeof subClassMethods === "object") {
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === "function") {
    subClass = subClassMethods;
  }
  _inherits(subClass, superClass);
  if (superClass) {
    subClass.super_ = superClass;
  }
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }
  return subClass;
};
var normalizeId = function normalizeId2(id) {
  return id.indexOf("#") === 0 ? id.slice(1) : id;
};
function videojs(id, options, ready) {
  var player = videojs.getPlayer(id);
  if (player) {
    if (options) {
      log$1.warn('Player "' + id + '" is already initialised. Options will not be applied.');
    }
    if (ready) {
      player.ready(ready);
    }
    return player;
  }
  var el = typeof id === "string" ? $("#" + normalizeId(id)) : id;
  if (!isEl(el)) {
    throw new TypeError("The element or ID supplied is not valid. (videojs)");
  }
  if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {
    log$1.warn("The element supplied is not included in the DOM");
  }
  options = options || {};
  if (options.restoreEl === true) {
    options.restoreEl = (el.parentNode && el.parentNode.hasAttribute("data-vjs-player") ? el.parentNode : el).cloneNode(true);
  }
  hooks("beforesetup").forEach(function(hookFunction) {
    var opts = hookFunction(el, mergeOptions$3(options));
    if (!isObject3(opts) || Array.isArray(opts)) {
      log$1.error("please return an object in beforesetup hooks");
      return;
    }
    options = mergeOptions$3(options, opts);
  });
  var PlayerComponent = Component$1.getComponent("Player");
  player = new PlayerComponent(el, options, ready);
  hooks("setup").forEach(function(hookFunction) {
    return hookFunction(player);
  });
  return player;
}
videojs.hooks_ = hooks_;
videojs.hooks = hooks;
videojs.hook = hook;
videojs.hookOnce = hookOnce;
videojs.removeHook = removeHook;
if (import_window6.default.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  style = $(".vjs-styles-defaults");
  if (!style) {
    style = createStyleElement("vjs-styles-defaults");
    head = $("head");
    if (head) {
      head.insertBefore(style, head.firstChild);
    }
    setTextContent(style, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    ");
  }
}
var style;
var head;
autoSetupTimeout(1, videojs);
videojs.VERSION = version$5;
videojs.options = Player.prototype.options_;
videojs.getPlayers = function() {
  return Player.players;
};
videojs.getPlayer = function(id) {
  var players = Player.players;
  var tag;
  if (typeof id === "string") {
    var nId = normalizeId(id);
    var player = players[nId];
    if (player) {
      return player;
    }
    tag = $("#" + nId);
  } else {
    tag = id;
  }
  if (isEl(tag)) {
    var _tag = tag, _player = _tag.player, playerId = _tag.playerId;
    if (_player || players[playerId]) {
      return _player || players[playerId];
    }
  }
};
videojs.getAllPlayers = function() {
  return (
    // Disposed players leave a key with a `null` value, so we need to make sure
    // we filter those out.
    Object.keys(Player.players).map(function(k2) {
      return Player.players[k2];
    }).filter(Boolean)
  );
};
videojs.players = Player.players;
videojs.getComponent = Component$1.getComponent;
videojs.registerComponent = function(name, comp) {
  if (Tech.isTech(comp)) {
    log$1.warn("The " + name + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)");
  }
  Component$1.registerComponent.call(Component$1, name, comp);
};
videojs.getTech = Tech.getTech;
videojs.registerTech = Tech.registerTech;
videojs.use = use;
Object.defineProperty(videojs, "middleware", {
  value: {},
  writeable: false,
  enumerable: true
});
Object.defineProperty(videojs.middleware, "TERMINATOR", {
  value: TERMINATOR,
  writeable: false,
  enumerable: true
});
videojs.browser = browser;
videojs.TOUCH_ENABLED = TOUCH_ENABLED;
videojs.extend = extend;
videojs.mergeOptions = mergeOptions$3;
videojs.bind = bind;
videojs.registerPlugin = Plugin.registerPlugin;
videojs.deregisterPlugin = Plugin.deregisterPlugin;
videojs.plugin = function(name, plugin) {
  log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
  return Plugin.registerPlugin(name, plugin);
};
videojs.getPlugins = Plugin.getPlugins;
videojs.getPlugin = Plugin.getPlugin;
videojs.getPluginVersion = Plugin.getPluginVersion;
videojs.addLanguage = function(code, data) {
  var _mergeOptions;
  code = ("" + code).toLowerCase();
  videojs.options.languages = mergeOptions$3(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));
  return videojs.options.languages[code];
};
videojs.log = log$1;
videojs.createLogger = createLogger;
videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;
videojs.formatTime = formatTime;
videojs.setFormatTime = setFormatTime;
videojs.resetFormatTime = resetFormatTime;
videojs.parseUrl = parseUrl;
videojs.isCrossOrigin = isCrossOrigin;
videojs.EventTarget = EventTarget$2;
videojs.on = on;
videojs.one = one;
videojs.off = off;
videojs.trigger = trigger;
videojs.xhr = import_xhr.default;
videojs.TextTrack = TextTrack;
videojs.AudioTrack = AudioTrack;
videojs.VideoTrack = VideoTrack;
["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach(function(k2) {
  videojs[k2] = function() {
    log$1.warn("videojs." + k2 + "() is deprecated; use videojs.dom." + k2 + "() instead");
    return Dom[k2].apply(null, arguments);
  };
});
videojs.computedStyle = computedStyle;
videojs.dom = Dom;
videojs.url = Url;
videojs.defineLazyProperty = defineLazyProperty;
videojs.addLanguage("en", {
  "Non-Fullscreen": "Exit Fullscreen"
});
var resolveUrl3 = resolve_url_default;
var resolveManifestRedirect = function resolveManifestRedirect2(handleManifestRedirect, url, req) {
  if (handleManifestRedirect && req && req.responseURL && url !== req.responseURL) {
    return req.responseURL;
  }
  return url;
};
var logger = function logger2(source) {
  if (videojs.log.debug) {
    return videojs.log.debug.bind(videojs, "VHS:", source + " >");
  }
  return function() {
  };
};
var TIME_FUDGE_FACTOR = 1 / 30;
var SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;
var filterRanges = function filterRanges2(timeRanges, predicate) {
  var results = [];
  var i;
  if (timeRanges && timeRanges.length) {
    for (i = 0; i < timeRanges.length; i++) {
      if (predicate(timeRanges.start(i), timeRanges.end(i))) {
        results.push([timeRanges.start(i), timeRanges.end(i)]);
      }
    }
  }
  return videojs.createTimeRanges(results);
};
var findRange = function findRange2(buffered, time) {
  return filterRanges(buffered, function(start2, end) {
    return start2 - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;
  });
};
var findNextRange = function findNextRange2(timeRanges, time) {
  return filterRanges(timeRanges, function(start2) {
    return start2 - TIME_FUDGE_FACTOR >= time;
  });
};
var findGaps = function findGaps2(buffered) {
  if (buffered.length < 2) {
    return videojs.createTimeRanges();
  }
  var ranges = [];
  for (var i = 1; i < buffered.length; i++) {
    var start2 = buffered.end(i - 1);
    var end = buffered.start(i);
    ranges.push([start2, end]);
  }
  return videojs.createTimeRanges(ranges);
};
var bufferIntersection = function bufferIntersection2(bufferA, bufferB) {
  var start2 = null;
  var end = null;
  var arity = 0;
  var extents = [];
  var ranges = [];
  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {
    return videojs.createTimeRange();
  }
  var count = bufferA.length;
  while (count--) {
    extents.push({
      time: bufferA.start(count),
      type: "start"
    });
    extents.push({
      time: bufferA.end(count),
      type: "end"
    });
  }
  count = bufferB.length;
  while (count--) {
    extents.push({
      time: bufferB.start(count),
      type: "start"
    });
    extents.push({
      time: bufferB.end(count),
      type: "end"
    });
  }
  extents.sort(function(a, b2) {
    return a.time - b2.time;
  });
  for (count = 0; count < extents.length; count++) {
    if (extents[count].type === "start") {
      arity++;
      if (arity === 2) {
        start2 = extents[count].time;
      }
    } else if (extents[count].type === "end") {
      arity--;
      if (arity === 1) {
        end = extents[count].time;
      }
    }
    if (start2 !== null && end !== null) {
      ranges.push([start2, end]);
      start2 = null;
      end = null;
    }
  }
  return videojs.createTimeRanges(ranges);
};
var printableRange = function printableRange2(range3) {
  var strArr = [];
  if (!range3 || !range3.length) {
    return "";
  }
  for (var i = 0; i < range3.length; i++) {
    strArr.push(range3.start(i) + " => " + range3.end(i));
  }
  return strArr.join(", ");
};
var timeUntilRebuffer = function timeUntilRebuffer2(buffered, currentTime, playbackRate) {
  if (playbackRate === void 0) {
    playbackRate = 1;
  }
  var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
  return (bufferedEnd - currentTime) / playbackRate;
};
var timeRangesToArray = function timeRangesToArray2(timeRanges) {
  var timeRangesList = [];
  for (var i = 0; i < timeRanges.length; i++) {
    timeRangesList.push({
      start: timeRanges.start(i),
      end: timeRanges.end(i)
    });
  }
  return timeRangesList;
};
var isRangeDifferent = function isRangeDifferent2(a, b2) {
  if (a === b2) {
    return false;
  }
  if (!a && b2 || !b2 && a) {
    return true;
  }
  if (a.length !== b2.length) {
    return true;
  }
  for (var i = 0; i < a.length; i++) {
    if (a.start(i) !== b2.start(i) || a.end(i) !== b2.end(i)) {
      return true;
    }
  }
  return false;
};
var lastBufferedEnd = function lastBufferedEnd2(a) {
  if (!a || !a.length || !a.end) {
    return;
  }
  return a.end(a.length - 1);
};
var timeAheadOf = function timeAheadOf2(range3, startTime) {
  var time = 0;
  if (!range3 || !range3.length) {
    return time;
  }
  for (var i = 0; i < range3.length; i++) {
    var start2 = range3.start(i);
    var end = range3.end(i);
    if (startTime > end) {
      continue;
    }
    if (startTime > start2 && startTime <= end) {
      time += end - startTime;
      continue;
    }
    time += end - start2;
  }
  return time;
};
var createTimeRange = videojs.createTimeRange;
var segmentDurationWithParts = function segmentDurationWithParts2(playlist, segment) {
  if (!segment.preload) {
    return segment.duration;
  }
  var result = 0;
  (segment.parts || []).forEach(function(p) {
    result += p.duration;
  });
  (segment.preloadHints || []).forEach(function(p) {
    if (p.type === "PART") {
      result += playlist.partTargetDuration;
    }
  });
  return result;
};
var getPartsAndSegments = function getPartsAndSegments2(playlist) {
  return (playlist.segments || []).reduce(function(acc, segment, si) {
    if (segment.parts) {
      segment.parts.forEach(function(part, pi) {
        acc.push({
          duration: part.duration,
          segmentIndex: si,
          partIndex: pi,
          part,
          segment
        });
      });
    } else {
      acc.push({
        duration: segment.duration,
        segmentIndex: si,
        partIndex: null,
        segment,
        part: null
      });
    }
    return acc;
  }, []);
};
var getLastParts = function getLastParts2(media) {
  var lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
  return lastSegment && lastSegment.parts || [];
};
var getKnownPartCount = function getKnownPartCount2(_ref) {
  var preloadSegment = _ref.preloadSegment;
  if (!preloadSegment) {
    return;
  }
  var parts = preloadSegment.parts, preloadHints = preloadSegment.preloadHints;
  var partCount = (preloadHints || []).reduce(function(count, hint) {
    return count + (hint.type === "PART" ? 1 : 0);
  }, 0);
  partCount += parts && parts.length ? parts.length : 0;
  return partCount;
};
var liveEdgeDelay = function liveEdgeDelay2(master, media) {
  if (media.endList) {
    return 0;
  }
  if (master && master.suggestedPresentationDelay) {
    return master.suggestedPresentationDelay;
  }
  var hasParts = getLastParts(media).length > 0;
  if (hasParts && media.serverControl && media.serverControl.partHoldBack) {
    return media.serverControl.partHoldBack;
  } else if (hasParts && media.partTargetDuration) {
    return media.partTargetDuration * 3;
  } else if (media.serverControl && media.serverControl.holdBack) {
    return media.serverControl.holdBack;
  } else if (media.targetDuration) {
    return media.targetDuration * 3;
  }
  return 0;
};
var backwardDuration = function backwardDuration2(playlist, endSequence) {
  var result = 0;
  var i = endSequence - playlist.mediaSequence;
  var segment = playlist.segments[i];
  if (segment) {
    if (typeof segment.start !== "undefined") {
      return {
        result: segment.start,
        precise: true
      };
    }
    if (typeof segment.end !== "undefined") {
      return {
        result: segment.end - segment.duration,
        precise: true
      };
    }
  }
  while (i--) {
    segment = playlist.segments[i];
    if (typeof segment.end !== "undefined") {
      return {
        result: result + segment.end,
        precise: true
      };
    }
    result += segmentDurationWithParts(playlist, segment);
    if (typeof segment.start !== "undefined") {
      return {
        result: result + segment.start,
        precise: true
      };
    }
  }
  return {
    result,
    precise: false
  };
};
var forwardDuration = function forwardDuration2(playlist, endSequence) {
  var result = 0;
  var segment;
  var i = endSequence - playlist.mediaSequence;
  for (; i < playlist.segments.length; i++) {
    segment = playlist.segments[i];
    if (typeof segment.start !== "undefined") {
      return {
        result: segment.start - result,
        precise: true
      };
    }
    result += segmentDurationWithParts(playlist, segment);
    if (typeof segment.end !== "undefined") {
      return {
        result: segment.end - result,
        precise: true
      };
    }
  }
  return {
    result: -1,
    precise: false
  };
};
var intervalDuration = function intervalDuration2(playlist, endSequence, expired) {
  if (typeof endSequence === "undefined") {
    endSequence = playlist.mediaSequence + playlist.segments.length;
  }
  if (endSequence < playlist.mediaSequence) {
    return 0;
  }
  var backward = backwardDuration(playlist, endSequence);
  if (backward.precise) {
    return backward.result;
  }
  var forward = forwardDuration(playlist, endSequence);
  if (forward.precise) {
    return forward.result;
  }
  return backward.result + expired;
};
var duration2 = function duration3(playlist, endSequence, expired) {
  if (!playlist) {
    return 0;
  }
  if (typeof expired !== "number") {
    expired = 0;
  }
  if (typeof endSequence === "undefined") {
    if (playlist.totalDuration) {
      return playlist.totalDuration;
    }
    if (!playlist.endList) {
      return import_window6.default.Infinity;
    }
  }
  return intervalDuration(playlist, endSequence, expired);
};
var sumDurations = function sumDurations2(_ref2) {
  var defaultDuration = _ref2.defaultDuration, durationList = _ref2.durationList, startIndex = _ref2.startIndex, endIndex = _ref2.endIndex;
  var durations = 0;
  if (startIndex > endIndex) {
    var _ref3 = [endIndex, startIndex];
    startIndex = _ref3[0];
    endIndex = _ref3[1];
  }
  if (startIndex < 0) {
    for (var i = startIndex; i < Math.min(0, endIndex); i++) {
      durations += defaultDuration;
    }
    startIndex = 0;
  }
  for (var _i = startIndex; _i < endIndex; _i++) {
    durations += durationList[_i].duration;
  }
  return durations;
};
var playlistEnd = function playlistEnd2(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
  if (!playlist || !playlist.segments) {
    return null;
  }
  if (playlist.endList) {
    return duration2(playlist);
  }
  if (expired === null) {
    return null;
  }
  expired = expired || 0;
  var lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
  if (useSafeLiveEnd) {
    liveEdgePadding = typeof liveEdgePadding === "number" ? liveEdgePadding : liveEdgeDelay(null, playlist);
    lastSegmentEndTime -= liveEdgePadding;
  }
  return Math.max(0, lastSegmentEndTime);
};
var seekable = function seekable2(playlist, expired, liveEdgePadding) {
  var useSafeLiveEnd = true;
  var seekableStart = expired || 0;
  var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
  if (seekableEnd === null) {
    return createTimeRange();
  }
  return createTimeRange(seekableStart, seekableEnd);
};
var getMediaInfoForTime = function getMediaInfoForTime2(_ref4) {
  var playlist = _ref4.playlist, currentTime = _ref4.currentTime, startingSegmentIndex = _ref4.startingSegmentIndex, startingPartIndex = _ref4.startingPartIndex, startTime = _ref4.startTime, experimentalExactManifestTimings = _ref4.experimentalExactManifestTimings;
  var time = currentTime - startTime;
  var partsAndSegments = getPartsAndSegments(playlist);
  var startIndex = 0;
  for (var i = 0; i < partsAndSegments.length; i++) {
    var partAndSegment = partsAndSegments[i];
    if (startingSegmentIndex !== partAndSegment.segmentIndex) {
      continue;
    }
    if (typeof startingPartIndex === "number" && typeof partAndSegment.partIndex === "number" && startingPartIndex !== partAndSegment.partIndex) {
      continue;
    }
    startIndex = i;
    break;
  }
  if (time < 0) {
    if (startIndex > 0) {
      for (var _i2 = startIndex - 1; _i2 >= 0; _i2--) {
        var _partAndSegment = partsAndSegments[_i2];
        time += _partAndSegment.duration;
        if (experimentalExactManifestTimings) {
          if (time < 0) {
            continue;
          }
        } else if (time + TIME_FUDGE_FACTOR <= 0) {
          continue;
        }
        return {
          partIndex: _partAndSegment.partIndex,
          segmentIndex: _partAndSegment.segmentIndex,
          startTime: startTime - sumDurations({
            defaultDuration: playlist.targetDuration,
            durationList: partsAndSegments,
            startIndex,
            endIndex: _i2
          })
        };
      }
    }
    return {
      partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
      segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
      startTime: currentTime
    };
  }
  if (startIndex < 0) {
    for (var _i3 = startIndex; _i3 < 0; _i3++) {
      time -= playlist.targetDuration;
      if (time < 0) {
        return {
          partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
          segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
          startTime: currentTime
        };
      }
    }
    startIndex = 0;
  }
  for (var _i4 = startIndex; _i4 < partsAndSegments.length; _i4++) {
    var _partAndSegment2 = partsAndSegments[_i4];
    time -= _partAndSegment2.duration;
    if (experimentalExactManifestTimings) {
      if (time > 0) {
        continue;
      }
    } else if (time - TIME_FUDGE_FACTOR >= 0) {
      continue;
    }
    return {
      partIndex: _partAndSegment2.partIndex,
      segmentIndex: _partAndSegment2.segmentIndex,
      startTime: startTime + sumDurations({
        defaultDuration: playlist.targetDuration,
        durationList: partsAndSegments,
        startIndex,
        endIndex: _i4
      })
    };
  }
  return {
    segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
    partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
    startTime: currentTime
  };
};
var isBlacklisted = function isBlacklisted2(playlist) {
  return playlist.excludeUntil && playlist.excludeUntil > Date.now();
};
var isIncompatible = function isIncompatible2(playlist) {
  return playlist.excludeUntil && playlist.excludeUntil === Infinity;
};
var isEnabled = function isEnabled2(playlist) {
  var blacklisted = isBlacklisted(playlist);
  return !playlist.disabled && !blacklisted;
};
var isDisabled = function isDisabled2(playlist) {
  return playlist.disabled;
};
var isAes = function isAes2(media) {
  for (var i = 0; i < media.segments.length; i++) {
    if (media.segments[i].key) {
      return true;
    }
  }
  return false;
};
var hasAttribute = function hasAttribute2(attr, playlist) {
  return playlist.attributes && playlist.attributes[attr];
};
var estimateSegmentRequestTime = function estimateSegmentRequestTime2(segmentDuration, bandwidth2, playlist, bytesReceived) {
  if (bytesReceived === void 0) {
    bytesReceived = 0;
  }
  if (!hasAttribute("BANDWIDTH", playlist)) {
    return NaN;
  }
  var size = segmentDuration * playlist.attributes.BANDWIDTH;
  return (size - bytesReceived * 8) / bandwidth2;
};
var isLowestEnabledRendition = function isLowestEnabledRendition2(master, media) {
  if (master.playlists.length === 1) {
    return true;
  }
  var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
  return master.playlists.filter(function(playlist) {
    if (!isEnabled(playlist)) {
      return false;
    }
    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
  }).length === 0;
};
var playlistMatch = function playlistMatch2(a, b2) {
  if (!a && !b2 || !a && b2 || a && !b2) {
    return false;
  }
  if (a === b2) {
    return true;
  }
  if (a.id && b2.id && a.id === b2.id) {
    return true;
  }
  if (a.resolvedUri && b2.resolvedUri && a.resolvedUri === b2.resolvedUri) {
    return true;
  }
  if (a.uri && b2.uri && a.uri === b2.uri) {
    return true;
  }
  return false;
};
var someAudioVariant = function someAudioVariant2(master, callback2) {
  var AUDIO5 = master && master.mediaGroups && master.mediaGroups.AUDIO || {};
  var found = false;
  for (var groupName in AUDIO5) {
    for (var label in AUDIO5[groupName]) {
      found = callback2(AUDIO5[groupName][label]);
      if (found) {
        break;
      }
    }
    if (found) {
      break;
    }
  }
  return !!found;
};
var isAudioOnly = function isAudioOnly2(master) {
  if (!master || !master.playlists || !master.playlists.length) {
    var found = someAudioVariant(master, function(variant) {
      return variant.playlists && variant.playlists.length || variant.uri;
    });
    return found;
  }
  var _loop = function _loop2(i2) {
    var playlist = master.playlists[i2];
    var CODECS = playlist.attributes && playlist.attributes.CODECS;
    if (CODECS && CODECS.split(",").every(function(c) {
      return isAudioCodec(c);
    })) {
      return "continue";
    }
    var found2 = someAudioVariant(master, function(variant) {
      return playlistMatch(playlist, variant);
    });
    if (found2) {
      return "continue";
    }
    return {
      v: false
    };
  };
  for (var i = 0; i < master.playlists.length; i++) {
    var _ret = _loop(i);
    if (_ret === "continue") continue;
    if (typeof _ret === "object") return _ret.v;
  }
  return true;
};
var Playlist = {
  liveEdgeDelay,
  duration: duration2,
  seekable,
  getMediaInfoForTime,
  isEnabled,
  isDisabled,
  isBlacklisted,
  isIncompatible,
  playlistEnd,
  isAes,
  hasAttribute,
  estimateSegmentRequestTime,
  isLowestEnabledRendition,
  isAudioOnly,
  playlistMatch,
  segmentDurationWithParts
};
var log = videojs.log;
var createPlaylistID = function createPlaylistID2(index, uri) {
  return index + "-" + uri;
};
var groupID = function groupID2(type2, group, label) {
  return "placeholder-uri-" + type2 + "-" + group + "-" + label;
};
var parseManifest = function parseManifest2(_ref) {
  var onwarn = _ref.onwarn, oninfo = _ref.oninfo, manifestString = _ref.manifestString, _ref$customTagParsers = _ref.customTagParsers, customTagParsers = _ref$customTagParsers === void 0 ? [] : _ref$customTagParsers, _ref$customTagMappers = _ref.customTagMappers, customTagMappers = _ref$customTagMappers === void 0 ? [] : _ref$customTagMappers, experimentalLLHLS = _ref.experimentalLLHLS;
  var parser6 = new Parser();
  if (onwarn) {
    parser6.on("warn", onwarn);
  }
  if (oninfo) {
    parser6.on("info", oninfo);
  }
  customTagParsers.forEach(function(customParser) {
    return parser6.addParser(customParser);
  });
  customTagMappers.forEach(function(mapper) {
    return parser6.addTagMapper(mapper);
  });
  parser6.push(manifestString);
  parser6.end();
  var manifest = parser6.manifest;
  if (!experimentalLLHLS) {
    ["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function(k2) {
      if (manifest.hasOwnProperty(k2)) {
        delete manifest[k2];
      }
    });
    if (manifest.segments) {
      manifest.segments.forEach(function(segment) {
        ["parts", "preloadHints"].forEach(function(k2) {
          if (segment.hasOwnProperty(k2)) {
            delete segment[k2];
          }
        });
      });
    }
  }
  if (!manifest.targetDuration) {
    var targetDuration = 10;
    if (manifest.segments && manifest.segments.length) {
      targetDuration = manifest.segments.reduce(function(acc, s) {
        return Math.max(acc, s.duration);
      }, 0);
    }
    if (onwarn) {
      onwarn("manifest has no targetDuration defaulting to " + targetDuration);
    }
    manifest.targetDuration = targetDuration;
  }
  var parts = getLastParts(manifest);
  if (parts.length && !manifest.partTargetDuration) {
    var partTargetDuration = parts.reduce(function(acc, p) {
      return Math.max(acc, p.duration);
    }, 0);
    if (onwarn) {
      onwarn("manifest has no partTargetDuration defaulting to " + partTargetDuration);
      log.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.");
    }
    manifest.partTargetDuration = partTargetDuration;
  }
  return manifest;
};
var forEachMediaGroup3 = function forEachMediaGroup4(master, callback2) {
  if (!master.mediaGroups) {
    return;
  }
  ["AUDIO", "SUBTITLES"].forEach(function(mediaType) {
    if (!master.mediaGroups[mediaType]) {
      return;
    }
    for (var groupKey in master.mediaGroups[mediaType]) {
      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
        callback2(mediaProperties, mediaType, groupKey, labelKey);
      }
    }
  });
};
var setupMediaPlaylist = function setupMediaPlaylist2(_ref2) {
  var playlist = _ref2.playlist, uri = _ref2.uri, id = _ref2.id;
  playlist.id = id;
  playlist.playlistErrors_ = 0;
  if (uri) {
    playlist.uri = uri;
  }
  playlist.attributes = playlist.attributes || {};
};
var setupMediaPlaylists = function setupMediaPlaylists2(master) {
  var i = master.playlists.length;
  while (i--) {
    var playlist = master.playlists[i];
    setupMediaPlaylist({
      playlist,
      id: createPlaylistID(i, playlist.uri)
    });
    playlist.resolvedUri = resolveUrl3(master.uri, playlist.uri);
    master.playlists[playlist.id] = playlist;
    master.playlists[playlist.uri] = playlist;
    if (!playlist.attributes.BANDWIDTH) {
      log.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
    }
  }
};
var resolveMediaGroupUris = function resolveMediaGroupUris2(master) {
  forEachMediaGroup3(master, function(properties) {
    if (properties.uri) {
      properties.resolvedUri = resolveUrl3(master.uri, properties.uri);
    }
  });
};
var masterForMedia = function masterForMedia2(media, uri) {
  var id = createPlaylistID(0, uri);
  var master = {
    mediaGroups: {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    },
    uri: import_window6.default.location.href,
    resolvedUri: import_window6.default.location.href,
    playlists: [{
      uri,
      id,
      resolvedUri: uri,
      // m3u8-parser does not attach an attributes property to media playlists so make
      // sure that the property is attached to avoid undefined reference errors
      attributes: {}
    }]
  };
  master.playlists[id] = master.playlists[0];
  master.playlists[uri] = master.playlists[0];
  return master;
};
var addPropertiesToMaster = function addPropertiesToMaster2(master, uri, createGroupID) {
  if (createGroupID === void 0) {
    createGroupID = groupID;
  }
  master.uri = uri;
  for (var i = 0; i < master.playlists.length; i++) {
    if (!master.playlists[i].uri) {
      var phonyUri = "placeholder-uri-" + i;
      master.playlists[i].uri = phonyUri;
    }
  }
  var audioOnlyMaster = isAudioOnly(master);
  forEachMediaGroup3(master, function(properties, mediaType, groupKey, labelKey) {
    if (!properties.playlists || !properties.playlists.length) {
      if (audioOnlyMaster && mediaType === "AUDIO" && !properties.uri) {
        for (var _i = 0; _i < master.playlists.length; _i++) {
          var p = master.playlists[_i];
          if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {
            return;
          }
        }
      }
      properties.playlists = [_extends({}, properties)];
    }
    properties.playlists.forEach(function(p2, i2) {
      var groupId = createGroupID(mediaType, groupKey, labelKey, p2);
      var id = createPlaylistID(i2, groupId);
      if (p2.uri) {
        p2.resolvedUri = p2.resolvedUri || resolveUrl3(master.uri, p2.uri);
      } else {
        p2.uri = i2 === 0 ? groupId : id;
        p2.resolvedUri = p2.uri;
      }
      p2.id = p2.id || id;
      p2.attributes = p2.attributes || {};
      master.playlists[p2.id] = p2;
      master.playlists[p2.uri] = p2;
    });
  });
  setupMediaPlaylists(master);
  resolveMediaGroupUris(master);
};
var mergeOptions$2 = videojs.mergeOptions;
var EventTarget$1 = videojs.EventTarget;
var addLLHLSQueryDirectives = function addLLHLSQueryDirectives2(uri, media) {
  if (media.endList || !media.serverControl) {
    return uri;
  }
  var parameters = {};
  if (media.serverControl.canBlockReload) {
    var preloadSegment = media.preloadSegment;
    var nextMSN = media.mediaSequence + media.segments.length;
    if (preloadSegment) {
      var parts = preloadSegment.parts || [];
      var nextPart = getKnownPartCount(media) - 1;
      if (nextPart > -1 && nextPart !== parts.length - 1) {
        parameters._HLS_part = nextPart;
      }
      if (nextPart > -1 || parts.length) {
        nextMSN--;
      }
    }
    parameters._HLS_msn = nextMSN;
  }
  if (media.serverControl && media.serverControl.canSkipUntil) {
    parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES";
  }
  if (Object.keys(parameters).length) {
    var parsedUri = new import_window6.default.URL(uri);
    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(name) {
      if (!parameters.hasOwnProperty(name)) {
        return;
      }
      parsedUri.searchParams.set(name, parameters[name]);
    });
    uri = parsedUri.toString();
  }
  return uri;
};
var updateSegment = function updateSegment2(a, b2) {
  if (!a) {
    return b2;
  }
  var result = mergeOptions$2(a, b2);
  if (a.preloadHints && !b2.preloadHints) {
    delete result.preloadHints;
  }
  if (a.parts && !b2.parts) {
    delete result.parts;
  } else if (a.parts && b2.parts) {
    for (var i = 0; i < b2.parts.length; i++) {
      if (a.parts && a.parts[i]) {
        result.parts[i] = mergeOptions$2(a.parts[i], b2.parts[i]);
      }
    }
  }
  if (!a.skipped && b2.skipped) {
    result.skipped = false;
  }
  if (a.preload && !b2.preload) {
    result.preload = false;
  }
  return result;
};
var updateSegments = function updateSegments2(original, update, offset) {
  var oldSegments = original.slice();
  var newSegments = update.slice();
  offset = offset || 0;
  var result = [];
  var currentMap;
  for (var newIndex = 0; newIndex < newSegments.length; newIndex++) {
    var oldSegment = oldSegments[newIndex + offset];
    var newSegment = newSegments[newIndex];
    if (oldSegment) {
      currentMap = oldSegment.map || currentMap;
      result.push(updateSegment(oldSegment, newSegment));
    } else {
      if (currentMap && !newSegment.map) {
        newSegment.map = currentMap;
      }
      result.push(newSegment);
    }
  }
  return result;
};
var resolveSegmentUris = function resolveSegmentUris2(segment, baseUri) {
  if (!segment.resolvedUri && segment.uri) {
    segment.resolvedUri = resolveUrl3(baseUri, segment.uri);
  }
  if (segment.key && !segment.key.resolvedUri) {
    segment.key.resolvedUri = resolveUrl3(baseUri, segment.key.uri);
  }
  if (segment.map && !segment.map.resolvedUri) {
    segment.map.resolvedUri = resolveUrl3(baseUri, segment.map.uri);
  }
  if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {
    segment.map.key.resolvedUri = resolveUrl3(baseUri, segment.map.key.uri);
  }
  if (segment.parts && segment.parts.length) {
    segment.parts.forEach(function(p) {
      if (p.resolvedUri) {
        return;
      }
      p.resolvedUri = resolveUrl3(baseUri, p.uri);
    });
  }
  if (segment.preloadHints && segment.preloadHints.length) {
    segment.preloadHints.forEach(function(p) {
      if (p.resolvedUri) {
        return;
      }
      p.resolvedUri = resolveUrl3(baseUri, p.uri);
    });
  }
};
var getAllSegments = function getAllSegments2(media) {
  var segments = media.segments || [];
  var preloadSegment = media.preloadSegment;
  if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
    if (preloadSegment.preloadHints) {
      for (var i = 0; i < preloadSegment.preloadHints.length; i++) {
        if (preloadSegment.preloadHints[i].type === "MAP") {
          return segments;
        }
      }
    }
    preloadSegment.duration = media.targetDuration;
    preloadSegment.preload = true;
    segments.push(preloadSegment);
  }
  return segments;
};
var isPlaylistUnchanged = function isPlaylistUnchanged2(a, b2) {
  return a === b2 || a.segments && b2.segments && a.segments.length === b2.segments.length && a.endList === b2.endList && a.mediaSequence === b2.mediaSequence && a.preloadSegment === b2.preloadSegment;
};
var updateMaster$1 = function updateMaster(master, newMedia, unchangedCheck) {
  if (unchangedCheck === void 0) {
    unchangedCheck = isPlaylistUnchanged;
  }
  var result = mergeOptions$2(master, {});
  var oldMedia = result.playlists[newMedia.id];
  if (!oldMedia) {
    return null;
  }
  if (unchangedCheck(oldMedia, newMedia)) {
    return null;
  }
  newMedia.segments = getAllSegments(newMedia);
  var mergedPlaylist = mergeOptions$2(oldMedia, newMedia);
  if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {
    delete mergedPlaylist.preloadSegment;
  }
  if (oldMedia.segments) {
    if (newMedia.skip) {
      newMedia.segments = newMedia.segments || [];
      for (var i = 0; i < newMedia.skip.skippedSegments; i++) {
        newMedia.segments.unshift({
          skipped: true
        });
      }
    }
    mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
  }
  mergedPlaylist.segments.forEach(function(segment) {
    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
  });
  for (var _i = 0; _i < result.playlists.length; _i++) {
    if (result.playlists[_i].id === newMedia.id) {
      result.playlists[_i] = mergedPlaylist;
    }
  }
  result.playlists[newMedia.id] = mergedPlaylist;
  result.playlists[newMedia.uri] = mergedPlaylist;
  forEachMediaGroup3(master, function(properties, mediaType, groupKey, labelKey) {
    if (!properties.playlists) {
      return;
    }
    for (var _i2 = 0; _i2 < properties.playlists.length; _i2++) {
      if (newMedia.id === properties.playlists[_i2].id) {
        properties.playlists[_i2] = mergedPlaylist;
      }
    }
  });
  return result;
};
var refreshDelay = function refreshDelay2(media, update) {
  var segments = media.segments || [];
  var lastSegment = segments[segments.length - 1];
  var lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
  var lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
  if (update && lastDuration) {
    return lastDuration * 1e3;
  }
  return (media.partTargetDuration || media.targetDuration || 10) * 500;
};
var PlaylistLoader = function(_EventTarget) {
  _inheritsLoose(PlaylistLoader2, _EventTarget);
  function PlaylistLoader2(src, vhs, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    if (!src) {
      throw new Error("A non-empty playlist URL or object is required");
    }
    _this.logger_ = logger("PlaylistLoader");
    var _options = options, _options$withCredenti = _options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti, _options$handleManife = _options.handleManifestRedirects, handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
    _this.src = src;
    _this.vhs_ = vhs;
    _this.withCredentials = withCredentials;
    _this.handleManifestRedirects = handleManifestRedirects;
    var vhsOptions = vhs.options_;
    _this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
    _this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
    _this.experimentalLLHLS = vhsOptions && vhsOptions.experimentalLLHLS || false;
    if (videojs.browser.IE_VERSION) {
      _this.experimentalLLHLS = false;
    }
    _this.state = "HAVE_NOTHING";
    _this.handleMediaupdatetimeout_ = _this.handleMediaupdatetimeout_.bind(_assertThisInitialized(_this));
    _this.on("mediaupdatetimeout", _this.handleMediaupdatetimeout_);
    return _this;
  }
  var _proto = PlaylistLoader2.prototype;
  _proto.handleMediaupdatetimeout_ = function handleMediaupdatetimeout_() {
    var _this2 = this;
    if (this.state !== "HAVE_METADATA") {
      return;
    }
    var media = this.media();
    var uri = resolveUrl3(this.master.uri, media.uri);
    if (this.experimentalLLHLS) {
      uri = addLLHLSQueryDirectives(uri, media);
    }
    this.state = "HAVE_CURRENT_METADATA";
    this.request = this.vhs_.xhr({
      uri,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this2.request) {
        return;
      }
      if (error) {
        return _this2.playlistRequestError(_this2.request, _this2.media(), "HAVE_METADATA");
      }
      _this2.haveMetadata({
        playlistString: _this2.request.responseText,
        url: _this2.media().uri,
        id: _this2.media().id
      });
    });
  };
  _proto.playlistRequestError = function playlistRequestError(xhr, playlist, startingState) {
    var uri = playlist.uri, id = playlist.id;
    this.request = null;
    if (startingState) {
      this.state = startingState;
    }
    this.error = {
      playlist: this.master.playlists[id],
      status: xhr.status,
      message: "HLS playlist request error at URL: " + uri + ".",
      responseText: xhr.responseText,
      code: xhr.status >= 500 ? 4 : 2
    };
    this.trigger("error");
  };
  _proto.parseManifest_ = function parseManifest_(_ref) {
    var _this3 = this;
    var url = _ref.url, manifestString = _ref.manifestString;
    return parseManifest({
      onwarn: function onwarn(_ref2) {
        var message = _ref2.message;
        return _this3.logger_("m3u8-parser warn for " + url + ": " + message);
      },
      oninfo: function oninfo(_ref3) {
        var message = _ref3.message;
        return _this3.logger_("m3u8-parser info for " + url + ": " + message);
      },
      manifestString,
      customTagParsers: this.customTagParsers,
      customTagMappers: this.customTagMappers,
      experimentalLLHLS: this.experimentalLLHLS
    });
  };
  _proto.haveMetadata = function haveMetadata(_ref4) {
    var playlistString = _ref4.playlistString, playlistObject = _ref4.playlistObject, url = _ref4.url, id = _ref4.id;
    this.request = null;
    this.state = "HAVE_METADATA";
    var playlist = playlistObject || this.parseManifest_({
      url,
      manifestString: playlistString
    });
    playlist.lastRequest = Date.now();
    setupMediaPlaylist({
      playlist,
      uri: url,
      id
    });
    var update = updateMaster$1(this.master, playlist);
    this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
    this.pendingMedia_ = null;
    if (update) {
      this.master = update;
      this.media_ = this.master.playlists[id];
    } else {
      this.trigger("playlistunchanged");
    }
    this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));
    this.trigger("loadedplaylist");
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.stopRequest();
    import_window6.default.clearTimeout(this.mediaUpdateTimeout);
    import_window6.default.clearTimeout(this.finalRenditionTimeout);
    this.off();
  };
  _proto.stopRequest = function stopRequest() {
    if (this.request) {
      var oldRequest = this.request;
      this.request = null;
      oldRequest.onreadystatechange = null;
      oldRequest.abort();
    }
  };
  _proto.media = function media(playlist, shouldDelay) {
    var _this4 = this;
    if (!playlist) {
      return this.media_;
    }
    if (this.state === "HAVE_NOTHING") {
      throw new Error("Cannot switch media playlist from " + this.state);
    }
    if (typeof playlist === "string") {
      if (!this.master.playlists[playlist]) {
        throw new Error("Unknown playlist URI: " + playlist);
      }
      playlist = this.master.playlists[playlist];
    }
    import_window6.default.clearTimeout(this.finalRenditionTimeout);
    if (shouldDelay) {
      var delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1e3 || 5 * 1e3;
      this.finalRenditionTimeout = import_window6.default.setTimeout(this.media.bind(this, playlist, false), delay);
      return;
    }
    var startingState = this.state;
    var mediaChange = !this.media_ || playlist.id !== this.media_.id;
    var masterPlaylistRef = this.master.playlists[playlist.id];
    if (masterPlaylistRef && masterPlaylistRef.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
    // media playlist or, for the case of demuxed audio, a resolved audio media group)
    playlist.endList && playlist.segments.length) {
      if (this.request) {
        this.request.onreadystatechange = null;
        this.request.abort();
        this.request = null;
      }
      this.state = "HAVE_METADATA";
      this.media_ = playlist;
      if (mediaChange) {
        this.trigger("mediachanging");
        if (startingState === "HAVE_MASTER") {
          this.trigger("loadedmetadata");
        } else {
          this.trigger("mediachange");
        }
      }
      return;
    }
    this.updateMediaUpdateTimeout_(refreshDelay(playlist, true));
    if (!mediaChange) {
      return;
    }
    this.state = "SWITCHING_MEDIA";
    if (this.request) {
      if (playlist.resolvedUri === this.request.url) {
        return;
      }
      this.request.onreadystatechange = null;
      this.request.abort();
      this.request = null;
    }
    if (this.media_) {
      this.trigger("mediachanging");
    }
    this.pendingMedia_ = playlist;
    this.request = this.vhs_.xhr({
      uri: playlist.resolvedUri,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this4.request) {
        return;
      }
      playlist.lastRequest = Date.now();
      playlist.resolvedUri = resolveManifestRedirect(_this4.handleManifestRedirects, playlist.resolvedUri, req);
      if (error) {
        return _this4.playlistRequestError(_this4.request, playlist, startingState);
      }
      _this4.haveMetadata({
        playlistString: req.responseText,
        url: playlist.uri,
        id: playlist.id
      });
      if (startingState === "HAVE_MASTER") {
        _this4.trigger("loadedmetadata");
      } else {
        _this4.trigger("mediachange");
      }
    });
  };
  _proto.pause = function pause() {
    if (this.mediaUpdateTimeout) {
      import_window6.default.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    this.stopRequest();
    if (this.state === "HAVE_NOTHING") {
      this.started = false;
    }
    if (this.state === "SWITCHING_MEDIA") {
      if (this.media_) {
        this.state = "HAVE_METADATA";
      } else {
        this.state = "HAVE_MASTER";
      }
    } else if (this.state === "HAVE_CURRENT_METADATA") {
      this.state = "HAVE_METADATA";
    }
  };
  _proto.load = function load(shouldDelay) {
    var _this5 = this;
    if (this.mediaUpdateTimeout) {
      import_window6.default.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    var media = this.media();
    if (shouldDelay) {
      var delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1e3 : 5 * 1e3;
      this.mediaUpdateTimeout = import_window6.default.setTimeout(function() {
        _this5.mediaUpdateTimeout = null;
        _this5.load();
      }, delay);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    if (media && !media.endList) {
      this.trigger("mediaupdatetimeout");
    } else {
      this.trigger("loadedplaylist");
    }
  };
  _proto.updateMediaUpdateTimeout_ = function updateMediaUpdateTimeout_(delay) {
    var _this6 = this;
    if (this.mediaUpdateTimeout) {
      import_window6.default.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    if (!this.media() || this.media().endList) {
      return;
    }
    this.mediaUpdateTimeout = import_window6.default.setTimeout(function() {
      _this6.mediaUpdateTimeout = null;
      _this6.trigger("mediaupdatetimeout");
      _this6.updateMediaUpdateTimeout_(delay);
    }, delay);
  };
  _proto.start = function start2() {
    var _this7 = this;
    this.started = true;
    if (typeof this.src === "object") {
      if (!this.src.uri) {
        this.src.uri = import_window6.default.location.href;
      }
      this.src.resolvedUri = this.src.uri;
      setTimeout(function() {
        _this7.setupInitialPlaylist(_this7.src);
      }, 0);
      return;
    }
    this.request = this.vhs_.xhr({
      uri: this.src,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this7.request) {
        return;
      }
      _this7.request = null;
      if (error) {
        _this7.error = {
          status: req.status,
          message: "HLS playlist request error at URL: " + _this7.src + ".",
          responseText: req.responseText,
          // MEDIA_ERR_NETWORK
          code: 2
        };
        if (_this7.state === "HAVE_NOTHING") {
          _this7.started = false;
        }
        return _this7.trigger("error");
      }
      _this7.src = resolveManifestRedirect(_this7.handleManifestRedirects, _this7.src, req);
      var manifest = _this7.parseManifest_({
        manifestString: req.responseText,
        url: _this7.src
      });
      _this7.setupInitialPlaylist(manifest);
    });
  };
  _proto.srcUri = function srcUri() {
    return typeof this.src === "string" ? this.src : this.src.uri;
  };
  _proto.setupInitialPlaylist = function setupInitialPlaylist(manifest) {
    this.state = "HAVE_MASTER";
    if (manifest.playlists) {
      this.master = manifest;
      addPropertiesToMaster(this.master, this.srcUri());
      manifest.playlists.forEach(function(playlist) {
        playlist.segments = getAllSegments(playlist);
        playlist.segments.forEach(function(segment) {
          resolveSegmentUris(segment, playlist.resolvedUri);
        });
      });
      this.trigger("loadedplaylist");
      if (!this.request) {
        this.media(this.master.playlists[0]);
      }
      return;
    }
    var uri = this.srcUri() || import_window6.default.location.href;
    this.master = masterForMedia(manifest, uri);
    this.haveMetadata({
      playlistObject: manifest,
      url: uri,
      id: this.master.playlists[0].id
    });
    this.trigger("loadedmetadata");
  };
  return PlaylistLoader2;
}(EventTarget$1);
var videojsXHR = videojs.xhr;
var mergeOptions$1 = videojs.mergeOptions;
var callbackWrapper = function callbackWrapper2(request, error, response, callback2) {
  var reqResponse = request.responseType === "arraybuffer" ? request.response : request.responseText;
  if (!error && reqResponse) {
    request.responseTime = Date.now();
    request.roundTripTime = request.responseTime - request.requestTime;
    request.bytesReceived = reqResponse.byteLength || reqResponse.length;
    if (!request.bandwidth) {
      request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1e3);
    }
  }
  if (response.headers) {
    request.responseHeaders = response.headers;
  }
  if (error && error.code === "ETIMEDOUT") {
    request.timedout = true;
  }
  if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {
    error = new Error("XHR Failed with a response of: " + (request && (reqResponse || request.responseText)));
  }
  callback2(error, request);
};
var xhrFactory = function xhrFactory2() {
  var xhr = function XhrFunction(options, callback2) {
    options = mergeOptions$1({
      timeout: 45e3
    }, options);
    var beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;
    if (beforeRequest && typeof beforeRequest === "function") {
      var newOptions = beforeRequest(options);
      if (newOptions) {
        options = newOptions;
      }
    }
    var xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;
    var request = xhrMethod(options, function(error, response) {
      return callbackWrapper(request, error, response, callback2);
    });
    var originalAbort = request.abort;
    request.abort = function() {
      request.aborted = true;
      return originalAbort.apply(request, arguments);
    };
    request.uri = options.uri;
    request.requestTime = Date.now();
    return request;
  };
  xhr.original = true;
  return xhr;
};
var byterangeStr = function byterangeStr2(byterange) {
  var byterangeEnd;
  var byterangeStart = byterange.offset;
  if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
    byterangeEnd = import_window6.default.BigInt(byterange.offset) + import_window6.default.BigInt(byterange.length) - import_window6.default.BigInt(1);
  } else {
    byterangeEnd = byterange.offset + byterange.length - 1;
  }
  return "bytes=" + byterangeStart + "-" + byterangeEnd;
};
var segmentXhrHeaders = function segmentXhrHeaders2(segment) {
  var headers = {};
  if (segment.byterange) {
    headers.Range = byterangeStr(segment.byterange);
  }
  return headers;
};
var textRange = function textRange2(range3, i) {
  return range3.start(i) + "-" + range3.end(i);
};
var formatHexString = function formatHexString2(e, i) {
  var value = e.toString(16);
  return "00".substring(0, 2 - value.length) + value + (i % 2 ? " " : "");
};
var formatAsciiString = function formatAsciiString2(e) {
  if (e >= 32 && e < 126) {
    return String.fromCharCode(e);
  }
  return ".";
};
var createTransferableMessage = function createTransferableMessage2(message) {
  var transferable = {};
  Object.keys(message).forEach(function(key) {
    var value = message[key];
    if (isArrayBufferView(value)) {
      transferable[key] = {
        bytes: value.buffer,
        byteOffset: value.byteOffset,
        byteLength: value.byteLength
      };
    } else {
      transferable[key] = value;
    }
  });
  return transferable;
};
var initSegmentId = function initSegmentId2(initSegment) {
  var byterange = initSegment.byterange || {
    length: Infinity,
    offset: 0
  };
  return [byterange.length, byterange.offset, initSegment.resolvedUri].join(",");
};
var segmentKeyId = function segmentKeyId2(key) {
  return key.resolvedUri;
};
var hexDump = function hexDump2(data) {
  var bytes = Array.prototype.slice.call(data);
  var step = 16;
  var result = "";
  var hex;
  var ascii;
  for (var j2 = 0; j2 < bytes.length / step; j2++) {
    hex = bytes.slice(j2 * step, j2 * step + step).map(formatHexString).join("");
    ascii = bytes.slice(j2 * step, j2 * step + step).map(formatAsciiString).join("");
    result += hex + " " + ascii + "\n";
  }
  return result;
};
var tagDump = function tagDump2(_ref) {
  var bytes = _ref.bytes;
  return hexDump(bytes);
};
var textRanges = function textRanges2(ranges) {
  var result = "";
  var i;
  for (i = 0; i < ranges.length; i++) {
    result += textRange(ranges, i) + " ";
  }
  return result;
};
var utils = Object.freeze({
  __proto__: null,
  createTransferableMessage,
  initSegmentId,
  segmentKeyId,
  hexDump,
  tagDump,
  textRanges
});
var SEGMENT_END_FUDGE_PERCENT = 0.25;
var playerTimeToProgramTime = function playerTimeToProgramTime2(playerTime, segment) {
  if (!segment.dateTimeObject) {
    return null;
  }
  var transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
  var transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
  var startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
  var offsetFromSegmentStart = playerTime - startOfSegment;
  return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1e3);
};
var originalSegmentVideoDuration = function originalSegmentVideoDuration2(videoTimingInfo) {
  return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
};
var findSegmentForProgramTime = function findSegmentForProgramTime2(programTime, playlist) {
  var dateTimeObject;
  try {
    dateTimeObject = new Date(programTime);
  } catch (e) {
    return null;
  }
  if (!playlist || !playlist.segments || playlist.segments.length === 0) {
    return null;
  }
  var segment = playlist.segments[0];
  if (dateTimeObject < segment.dateTimeObject) {
    return null;
  }
  for (var i = 0; i < playlist.segments.length - 1; i++) {
    segment = playlist.segments[i];
    var nextSegmentStart = playlist.segments[i + 1].dateTimeObject;
    if (dateTimeObject < nextSegmentStart) {
      break;
    }
  }
  var lastSegment = playlist.segments[playlist.segments.length - 1];
  var lastSegmentStart = lastSegment.dateTimeObject;
  var lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;
  var lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1e3);
  if (dateTimeObject > lastSegmentEnd) {
    return null;
  }
  if (dateTimeObject > lastSegmentStart) {
    segment = lastSegment;
  }
  return {
    segment,
    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
    // Although, given that all segments have accurate date time objects, the segment
    // selected should be accurate, unless the video has been transmuxed at some point
    // (determined by the presence of the videoTimingInfo object), the segment's "player
    // time" (the start time in the player) can't be considered accurate.
    type: segment.videoTimingInfo ? "accurate" : "estimate"
  };
};
var findSegmentForPlayerTime = function findSegmentForPlayerTime2(time, playlist) {
  if (!playlist || !playlist.segments || playlist.segments.length === 0) {
    return null;
  }
  var segmentEnd = 0;
  var segment;
  for (var i = 0; i < playlist.segments.length; i++) {
    segment = playlist.segments[i];
    segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
    if (time <= segmentEnd) {
      break;
    }
  }
  var lastSegment = playlist.segments[playlist.segments.length - 1];
  if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {
    return null;
  }
  if (time > segmentEnd) {
    if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {
      return null;
    }
    segment = lastSegment;
  }
  return {
    segment,
    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
    // Because videoTimingInfo is only set after transmux, it is the only way to get
    // accurate timing values.
    type: segment.videoTimingInfo ? "accurate" : "estimate"
  };
};
var getOffsetFromTimestamp = function getOffsetFromTimestamp2(comparisonTimeStamp, programTime) {
  var segmentDateTime;
  var programDateTime;
  try {
    segmentDateTime = new Date(comparisonTimeStamp);
    programDateTime = new Date(programTime);
  } catch (e) {
  }
  var segmentTimeEpoch = segmentDateTime.getTime();
  var programTimeEpoch = programDateTime.getTime();
  return (programTimeEpoch - segmentTimeEpoch) / 1e3;
};
var verifyProgramDateTimeTags = function verifyProgramDateTimeTags2(playlist) {
  if (!playlist.segments || playlist.segments.length === 0) {
    return false;
  }
  for (var i = 0; i < playlist.segments.length; i++) {
    var segment = playlist.segments[i];
    if (!segment.dateTimeObject) {
      return false;
    }
  }
  return true;
};
var getProgramTime = function getProgramTime2(_ref) {
  var playlist = _ref.playlist, _ref$time = _ref.time, time = _ref$time === void 0 ? void 0 : _ref$time, callback2 = _ref.callback;
  if (!callback2) {
    throw new Error("getProgramTime: callback must be provided");
  }
  if (!playlist || time === void 0) {
    return callback2({
      message: "getProgramTime: playlist and time must be provided"
    });
  }
  var matchedSegment = findSegmentForPlayerTime(time, playlist);
  if (!matchedSegment) {
    return callback2({
      message: "valid programTime was not found"
    });
  }
  if (matchedSegment.type === "estimate") {
    return callback2({
      message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
      seekTime: matchedSegment.estimatedStart
    });
  }
  var programTimeObject = {
    mediaSeconds: time
  };
  var programTime = playerTimeToProgramTime(time, matchedSegment.segment);
  if (programTime) {
    programTimeObject.programDateTime = programTime.toISOString();
  }
  return callback2(null, programTimeObject);
};
var seekToProgramTime = function seekToProgramTime2(_ref2) {
  var programTime = _ref2.programTime, playlist = _ref2.playlist, _ref2$retryCount = _ref2.retryCount, retryCount = _ref2$retryCount === void 0 ? 2 : _ref2$retryCount, seekTo = _ref2.seekTo, _ref2$pauseAfterSeek = _ref2.pauseAfterSeek, pauseAfterSeek = _ref2$pauseAfterSeek === void 0 ? true : _ref2$pauseAfterSeek, tech = _ref2.tech, callback2 = _ref2.callback;
  if (!callback2) {
    throw new Error("seekToProgramTime: callback must be provided");
  }
  if (typeof programTime === "undefined" || !playlist || !seekTo) {
    return callback2({
      message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
    });
  }
  if (!playlist.endList && !tech.hasStarted_) {
    return callback2({
      message: "player must be playing a live stream to start buffering"
    });
  }
  if (!verifyProgramDateTimeTags(playlist)) {
    return callback2({
      message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
    });
  }
  var matchedSegment = findSegmentForProgramTime(programTime, playlist);
  if (!matchedSegment) {
    return callback2({
      message: programTime + " was not found in the stream"
    });
  }
  var segment = matchedSegment.segment;
  var mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
  if (matchedSegment.type === "estimate") {
    if (retryCount === 0) {
      return callback2({
        message: programTime + " is not buffered yet. Try again"
      });
    }
    seekTo(matchedSegment.estimatedStart + mediaOffset);
    tech.one("seeked", function() {
      seekToProgramTime2({
        programTime,
        playlist,
        retryCount: retryCount - 1,
        seekTo,
        pauseAfterSeek,
        tech,
        callback: callback2
      });
    });
    return;
  }
  var seekToTime = segment.start + mediaOffset;
  var seekedCallback = function seekedCallback2() {
    return callback2(null, tech.currentTime());
  };
  tech.one("seeked", seekedCallback);
  if (pauseAfterSeek) {
    tech.pause();
  }
  seekTo(seekToTime);
};
var callbackOnCompleted = function callbackOnCompleted2(request, cb) {
  if (request.readyState === 4) {
    return cb();
  }
  return;
};
var containerRequest = function containerRequest2(uri, xhr, cb) {
  var bytes = [];
  var id3Offset;
  var finished = false;
  var endRequestAndCallback = function endRequestAndCallback2(err, req, type2, _bytes) {
    req.abort();
    finished = true;
    return cb(err, req, type2, _bytes);
  };
  var progressListener = function progressListener2(error, request2) {
    if (finished) {
      return;
    }
    if (error) {
      return endRequestAndCallback(error, request2, "", bytes);
    }
    var newPart = request2.responseText.substring(bytes && bytes.byteLength || 0, request2.responseText.length);
    bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));
    id3Offset = id3Offset || getId3Offset(bytes);
    if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {
      return callbackOnCompleted(request2, function() {
        return endRequestAndCallback(error, request2, "", bytes);
      });
    }
    var type2 = detectContainerForBytes(bytes);
    if (type2 === "ts" && bytes.length < 188) {
      return callbackOnCompleted(request2, function() {
        return endRequestAndCallback(error, request2, "", bytes);
      });
    }
    if (!type2 && bytes.length < 376) {
      return callbackOnCompleted(request2, function() {
        return endRequestAndCallback(error, request2, "", bytes);
      });
    }
    return endRequestAndCallback(null, request2, type2, bytes);
  };
  var options = {
    uri,
    beforeSend: function beforeSend(request2) {
      request2.overrideMimeType("text/plain; charset=x-user-defined");
      request2.addEventListener("progress", function(_ref) {
        _ref.total;
        _ref.loaded;
        return callbackWrapper(request2, null, {
          statusCode: request2.status
        }, progressListener);
      });
    }
  };
  var request = xhr(options, function(error, response) {
    return callbackWrapper(request, error, response, progressListener);
  });
  return request;
};
var EventTarget2 = videojs.EventTarget;
var mergeOptions = videojs.mergeOptions;
var dashPlaylistUnchanged = function dashPlaylistUnchanged2(a, b2) {
  if (!isPlaylistUnchanged(a, b2)) {
    return false;
  }
  if (a.sidx && b2.sidx && (a.sidx.offset !== b2.sidx.offset || a.sidx.length !== b2.sidx.length)) {
    return false;
  } else if (!a.sidx && b2.sidx || a.sidx && !b2.sidx) {
    return false;
  }
  if (a.segments && !b2.segments || !a.segments && b2.segments) {
    return false;
  }
  if (!a.segments && !b2.segments) {
    return true;
  }
  for (var i = 0; i < a.segments.length; i++) {
    var aSegment = a.segments[i];
    var bSegment = b2.segments[i];
    if (aSegment.uri !== bSegment.uri) {
      return false;
    }
    if (!aSegment.byterange && !bSegment.byterange) {
      continue;
    }
    var aByterange = aSegment.byterange;
    var bByterange = bSegment.byterange;
    if (aByterange && !bByterange || !aByterange && bByterange) {
      return false;
    }
    if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {
      return false;
    }
  }
  return true;
};
var dashGroupId = function dashGroupId2(type2, group, label, playlist) {
  var playlistId = playlist.attributes.NAME || label;
  return "placeholder-uri-" + type2 + "-" + group + "-" + playlistId;
};
var parseMasterXml = function parseMasterXml2(_ref) {
  var masterXml = _ref.masterXml, srcUrl = _ref.srcUrl, clientOffset = _ref.clientOffset, sidxMapping = _ref.sidxMapping, previousManifest = _ref.previousManifest;
  var manifest = parse(masterXml, {
    manifestUri: srcUrl,
    clientOffset,
    sidxMapping,
    previousManifest
  });
  addPropertiesToMaster(manifest, srcUrl, dashGroupId);
  return manifest;
};
var removeOldMediaGroupLabels = function removeOldMediaGroupLabels2(update, newMaster) {
  forEachMediaGroup3(update, function(properties, type2, group, label) {
    if (!(label in newMaster.mediaGroups[type2][group])) {
      delete update.mediaGroups[type2][group][label];
    }
  });
};
var updateMaster2 = function updateMaster3(oldMaster, newMaster, sidxMapping) {
  var noChanges = true;
  var update = mergeOptions(oldMaster, {
    // These are top level properties that can be updated
    duration: newMaster.duration,
    minimumUpdatePeriod: newMaster.minimumUpdatePeriod,
    timelineStarts: newMaster.timelineStarts
  });
  for (var i = 0; i < newMaster.playlists.length; i++) {
    var playlist = newMaster.playlists[i];
    if (playlist.sidx) {
      var sidxKey = generateSidxKey(playlist.sidx);
      if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {
        addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
      }
    }
    var playlistUpdate = updateMaster$1(update, playlist, dashPlaylistUnchanged);
    if (playlistUpdate) {
      update = playlistUpdate;
      noChanges = false;
    }
  }
  forEachMediaGroup3(newMaster, function(properties, type2, group, label) {
    if (properties.playlists && properties.playlists.length) {
      var id = properties.playlists[0].id;
      var _playlistUpdate = updateMaster$1(update, properties.playlists[0], dashPlaylistUnchanged);
      if (_playlistUpdate) {
        update = _playlistUpdate;
        if (!(label in update.mediaGroups[type2][group])) {
          update.mediaGroups[type2][group][label] = properties;
        }
        update.mediaGroups[type2][group][label].playlists[0] = update.playlists[id];
        noChanges = false;
      }
    }
  });
  removeOldMediaGroupLabels(update, newMaster);
  if (newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
    noChanges = false;
  }
  if (noChanges) {
    return null;
  }
  return update;
};
var equivalentSidx = function equivalentSidx2(a, b2) {
  var neitherMap = Boolean(!a.map && !b2.map);
  var equivalentMap = neitherMap || Boolean(a.map && b2.map && a.map.byterange.offset === b2.map.byterange.offset && a.map.byterange.length === b2.map.byterange.length);
  return equivalentMap && a.uri === b2.uri && a.byterange.offset === b2.byterange.offset && a.byterange.length === b2.byterange.length;
};
var compareSidxEntry = function compareSidxEntry2(playlists, oldSidxMapping) {
  var newSidxMapping = {};
  for (var id in playlists) {
    var playlist = playlists[id];
    var currentSidxInfo = playlist.sidx;
    if (currentSidxInfo) {
      var key = generateSidxKey(currentSidxInfo);
      if (!oldSidxMapping[key]) {
        break;
      }
      var savedSidxInfo = oldSidxMapping[key].sidxInfo;
      if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {
        newSidxMapping[key] = oldSidxMapping[key];
      }
    }
  }
  return newSidxMapping;
};
var filterChangedSidxMappings = function filterChangedSidxMappings2(master, oldSidxMapping) {
  var videoSidx = compareSidxEntry(master.playlists, oldSidxMapping);
  var mediaGroupSidx = videoSidx;
  forEachMediaGroup3(master, function(properties, mediaType, groupKey, labelKey) {
    if (properties.playlists && properties.playlists.length) {
      var playlists = properties.playlists;
      mediaGroupSidx = mergeOptions(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));
    }
  });
  return mediaGroupSidx;
};
var DashPlaylistLoader = function(_EventTarget) {
  _inheritsLoose(DashPlaylistLoader2, _EventTarget);
  function DashPlaylistLoader2(srcUrlOrPlaylist, vhs, options, masterPlaylistLoader) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    _this.masterPlaylistLoader_ = masterPlaylistLoader || _assertThisInitialized(_this);
    if (!masterPlaylistLoader) {
      _this.isMaster_ = true;
    }
    var _options = options, _options$withCredenti = _options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti, _options$handleManife = _options.handleManifestRedirects, handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
    _this.vhs_ = vhs;
    _this.withCredentials = withCredentials;
    _this.handleManifestRedirects = handleManifestRedirects;
    if (!srcUrlOrPlaylist) {
      throw new Error("A non-empty playlist URL or object is required");
    }
    _this.on("minimumUpdatePeriod", function() {
      _this.refreshXml_();
    });
    _this.on("mediaupdatetimeout", function() {
      _this.refreshMedia_(_this.media().id);
    });
    _this.state = "HAVE_NOTHING";
    _this.loadedPlaylists_ = {};
    _this.logger_ = logger("DashPlaylistLoader");
    if (_this.isMaster_) {
      _this.masterPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
      _this.masterPlaylistLoader_.sidxMapping_ = {};
    } else {
      _this.childPlaylist_ = srcUrlOrPlaylist;
    }
    return _this;
  }
  var _proto = DashPlaylistLoader2.prototype;
  _proto.requestErrored_ = function requestErrored_(err, request, startingState) {
    if (!this.request) {
      return true;
    }
    this.request = null;
    if (err) {
      this.error = typeof err === "object" && !(err instanceof Error) ? err : {
        status: request.status,
        message: "DASH request error at URL: " + request.uri,
        response: request.response,
        // MEDIA_ERR_NETWORK
        code: 2
      };
      if (startingState) {
        this.state = startingState;
      }
      this.trigger("error");
      return true;
    }
  };
  _proto.addSidxSegments_ = function addSidxSegments_(playlist, startingState, cb) {
    var _this2 = this;
    var sidxKey = playlist.sidx && generateSidxKey(playlist.sidx);
    if (!playlist.sidx || !sidxKey || this.masterPlaylistLoader_.sidxMapping_[sidxKey]) {
      this.mediaRequest_ = import_window6.default.setTimeout(function() {
        return cb(false);
      }, 0);
      return;
    }
    var uri = resolveManifestRedirect(this.handleManifestRedirects, playlist.sidx.resolvedUri);
    var fin = function fin2(err, request) {
      if (_this2.requestErrored_(err, request, startingState)) {
        return;
      }
      var sidxMapping = _this2.masterPlaylistLoader_.sidxMapping_;
      var sidx;
      try {
        sidx = (0, import_parse_sidx.default)(toUint8(request.response).subarray(8));
      } catch (e) {
        _this2.requestErrored_(e, request, startingState);
        return;
      }
      sidxMapping[sidxKey] = {
        sidxInfo: playlist.sidx,
        sidx
      };
      addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);
      return cb(true);
    };
    this.request = containerRequest(uri, this.vhs_.xhr, function(err, request, container, bytes) {
      if (err) {
        return fin(err, request);
      }
      if (!container || container !== "mp4") {
        return fin({
          status: request.status,
          message: "Unsupported " + (container || "unknown") + " container type for sidx segment at URL: " + uri,
          // response is just bytes in this case
          // but we really don't want to return that.
          response: "",
          playlist,
          internal: true,
          blacklistDuration: Infinity,
          // MEDIA_ERR_NETWORK
          code: 2
        }, request);
      }
      var _playlist$sidx$bytera = playlist.sidx.byterange, offset = _playlist$sidx$bytera.offset, length = _playlist$sidx$bytera.length;
      if (bytes.length >= length + offset) {
        return fin(err, {
          response: bytes.subarray(offset, offset + length),
          status: request.status,
          uri: request.uri
        });
      }
      _this2.request = _this2.vhs_.xhr({
        uri,
        responseType: "arraybuffer",
        headers: segmentXhrHeaders({
          byterange: playlist.sidx.byterange
        })
      }, fin);
    });
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.stopRequest();
    this.loadedPlaylists_ = {};
    import_window6.default.clearTimeout(this.minimumUpdatePeriodTimeout_);
    import_window6.default.clearTimeout(this.mediaRequest_);
    import_window6.default.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    this.mediaRequest_ = null;
    this.minimumUpdatePeriodTimeout_ = null;
    if (this.masterPlaylistLoader_.createMupOnMedia_) {
      this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_);
      this.masterPlaylistLoader_.createMupOnMedia_ = null;
    }
    this.off();
  };
  _proto.hasPendingRequest = function hasPendingRequest() {
    return this.request || this.mediaRequest_;
  };
  _proto.stopRequest = function stopRequest() {
    if (this.request) {
      var oldRequest = this.request;
      this.request = null;
      oldRequest.onreadystatechange = null;
      oldRequest.abort();
    }
  };
  _proto.media = function media(playlist) {
    var _this3 = this;
    if (!playlist) {
      return this.media_;
    }
    if (this.state === "HAVE_NOTHING") {
      throw new Error("Cannot switch media playlist from " + this.state);
    }
    var startingState = this.state;
    if (typeof playlist === "string") {
      if (!this.masterPlaylistLoader_.master.playlists[playlist]) {
        throw new Error("Unknown playlist URI: " + playlist);
      }
      playlist = this.masterPlaylistLoader_.master.playlists[playlist];
    }
    var mediaChange = !this.media_ || playlist.id !== this.media_.id;
    if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
      this.state = "HAVE_METADATA";
      this.media_ = playlist;
      if (mediaChange) {
        this.trigger("mediachanging");
        this.trigger("mediachange");
      }
      return;
    }
    if (!mediaChange) {
      return;
    }
    if (this.media_) {
      this.trigger("mediachanging");
    }
    this.addSidxSegments_(playlist, startingState, function(sidxChanged) {
      _this3.haveMetadata({
        startingState,
        playlist
      });
    });
  };
  _proto.haveMetadata = function haveMetadata(_ref2) {
    var startingState = _ref2.startingState, playlist = _ref2.playlist;
    this.state = "HAVE_METADATA";
    this.loadedPlaylists_[playlist.id] = playlist;
    this.mediaRequest_ = null;
    this.refreshMedia_(playlist.id);
    if (startingState === "HAVE_MASTER") {
      this.trigger("loadedmetadata");
    } else {
      this.trigger("mediachange");
    }
  };
  _proto.pause = function pause() {
    if (this.masterPlaylistLoader_.createMupOnMedia_) {
      this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_);
      this.masterPlaylistLoader_.createMupOnMedia_ = null;
    }
    this.stopRequest();
    import_window6.default.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    if (this.isMaster_) {
      import_window6.default.clearTimeout(this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_);
      this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
    }
    if (this.state === "HAVE_NOTHING") {
      this.started = false;
    }
  };
  _proto.load = function load(isFinalRendition) {
    var _this4 = this;
    import_window6.default.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    var media = this.media();
    if (isFinalRendition) {
      var delay = media ? media.targetDuration / 2 * 1e3 : 5 * 1e3;
      this.mediaUpdateTimeout = import_window6.default.setTimeout(function() {
        return _this4.load();
      }, delay);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    if (media && !media.endList) {
      if (this.isMaster_ && !this.minimumUpdatePeriodTimeout_) {
        this.trigger("minimumUpdatePeriod");
        this.updateMinimumUpdatePeriodTimeout_();
      }
      this.trigger("mediaupdatetimeout");
    } else {
      this.trigger("loadedplaylist");
    }
  };
  _proto.start = function start2() {
    var _this5 = this;
    this.started = true;
    if (!this.isMaster_) {
      this.mediaRequest_ = import_window6.default.setTimeout(function() {
        return _this5.haveMaster_();
      }, 0);
      return;
    }
    this.requestMaster_(function(req, masterChanged) {
      _this5.haveMaster_();
      if (!_this5.hasPendingRequest() && !_this5.media_) {
        _this5.media(_this5.masterPlaylistLoader_.master.playlists[0]);
      }
    });
  };
  _proto.requestMaster_ = function requestMaster_(cb) {
    var _this6 = this;
    this.request = this.vhs_.xhr({
      uri: this.masterPlaylistLoader_.srcUrl,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (_this6.requestErrored_(error, req)) {
        if (_this6.state === "HAVE_NOTHING") {
          _this6.started = false;
        }
        return;
      }
      var masterChanged = req.responseText !== _this6.masterPlaylistLoader_.masterXml_;
      _this6.masterPlaylistLoader_.masterXml_ = req.responseText;
      if (req.responseHeaders && req.responseHeaders.date) {
        _this6.masterLoaded_ = Date.parse(req.responseHeaders.date);
      } else {
        _this6.masterLoaded_ = Date.now();
      }
      _this6.masterPlaylistLoader_.srcUrl = resolveManifestRedirect(_this6.handleManifestRedirects, _this6.masterPlaylistLoader_.srcUrl, req);
      if (masterChanged) {
        _this6.handleMaster_();
        _this6.syncClientServerClock_(function() {
          return cb(req, masterChanged);
        });
        return;
      }
      return cb(req, masterChanged);
    });
  };
  _proto.syncClientServerClock_ = function syncClientServerClock_(done) {
    var _this7 = this;
    var utcTiming = parseUTCTiming(this.masterPlaylistLoader_.masterXml_);
    if (utcTiming === null) {
      this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now();
      return done();
    }
    if (utcTiming.method === "DIRECT") {
      this.masterPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
      return done();
    }
    this.request = this.vhs_.xhr({
      uri: resolveUrl3(this.masterPlaylistLoader_.srcUrl, utcTiming.value),
      method: utcTiming.method,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this7.request) {
        return;
      }
      if (error) {
        _this7.masterPlaylistLoader_.clientOffset_ = _this7.masterLoaded_ - Date.now();
        return done();
      }
      var serverTime;
      if (utcTiming.method === "HEAD") {
        if (!req.responseHeaders || !req.responseHeaders.date) {
          serverTime = _this7.masterLoaded_;
        } else {
          serverTime = Date.parse(req.responseHeaders.date);
        }
      } else {
        serverTime = Date.parse(req.responseText);
      }
      _this7.masterPlaylistLoader_.clientOffset_ = serverTime - Date.now();
      done();
    });
  };
  _proto.haveMaster_ = function haveMaster_() {
    this.state = "HAVE_MASTER";
    if (this.isMaster_) {
      this.trigger("loadedplaylist");
    } else if (!this.media_) {
      this.media(this.childPlaylist_);
    }
  };
  _proto.handleMaster_ = function handleMaster_() {
    this.mediaRequest_ = null;
    var oldMaster = this.masterPlaylistLoader_.master;
    var newMaster = parseMasterXml({
      masterXml: this.masterPlaylistLoader_.masterXml_,
      srcUrl: this.masterPlaylistLoader_.srcUrl,
      clientOffset: this.masterPlaylistLoader_.clientOffset_,
      sidxMapping: this.masterPlaylistLoader_.sidxMapping_,
      previousManifest: oldMaster
    });
    if (oldMaster) {
      newMaster = updateMaster2(oldMaster, newMaster, this.masterPlaylistLoader_.sidxMapping_);
    }
    this.masterPlaylistLoader_.master = newMaster ? newMaster : oldMaster;
    var location = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];
    if (location && location !== this.masterPlaylistLoader_.srcUrl) {
      this.masterPlaylistLoader_.srcUrl = location;
    }
    if (!oldMaster || newMaster && newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
      this.updateMinimumUpdatePeriodTimeout_();
    }
    return Boolean(newMaster);
  };
  _proto.updateMinimumUpdatePeriodTimeout_ = function updateMinimumUpdatePeriodTimeout_() {
    var mpl = this.masterPlaylistLoader_;
    if (mpl.createMupOnMedia_) {
      mpl.off("loadedmetadata", mpl.createMupOnMedia_);
      mpl.createMupOnMedia_ = null;
    }
    if (mpl.minimumUpdatePeriodTimeout_) {
      import_window6.default.clearTimeout(mpl.minimumUpdatePeriodTimeout_);
      mpl.minimumUpdatePeriodTimeout_ = null;
    }
    var mup = mpl.master && mpl.master.minimumUpdatePeriod;
    if (mup === 0) {
      if (mpl.media()) {
        mup = mpl.media().targetDuration * 1e3;
      } else {
        mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
        mpl.one("loadedmetadata", mpl.createMupOnMedia_);
      }
    }
    if (typeof mup !== "number" || mup <= 0) {
      if (mup < 0) {
        this.logger_("found invalid minimumUpdatePeriod of " + mup + ", not setting a timeout");
      }
      return;
    }
    this.createMUPTimeout_(mup);
  };
  _proto.createMUPTimeout_ = function createMUPTimeout_(mup) {
    var mpl = this.masterPlaylistLoader_;
    mpl.minimumUpdatePeriodTimeout_ = import_window6.default.setTimeout(function() {
      mpl.minimumUpdatePeriodTimeout_ = null;
      mpl.trigger("minimumUpdatePeriod");
      mpl.createMUPTimeout_(mup);
    }, mup);
  };
  _proto.refreshXml_ = function refreshXml_() {
    var _this8 = this;
    this.requestMaster_(function(req, masterChanged) {
      if (!masterChanged) {
        return;
      }
      if (_this8.media_) {
        _this8.media_ = _this8.masterPlaylistLoader_.master.playlists[_this8.media_.id];
      }
      _this8.masterPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(_this8.masterPlaylistLoader_.master, _this8.masterPlaylistLoader_.sidxMapping_);
      _this8.addSidxSegments_(_this8.media(), _this8.state, function(sidxChanged) {
        _this8.refreshMedia_(_this8.media().id);
      });
    });
  };
  _proto.refreshMedia_ = function refreshMedia_(mediaID) {
    var _this9 = this;
    if (!mediaID) {
      throw new Error("refreshMedia_ must take a media id");
    }
    if (this.media_ && this.isMaster_) {
      this.handleMaster_();
    }
    var playlists = this.masterPlaylistLoader_.master.playlists;
    var mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
    if (mediaChanged) {
      this.media_ = playlists[mediaID];
    } else {
      this.trigger("playlistunchanged");
    }
    if (!this.mediaUpdateTimeout) {
      var createMediaUpdateTimeout = function createMediaUpdateTimeout2() {
        if (_this9.media().endList) {
          return;
        }
        _this9.mediaUpdateTimeout = import_window6.default.setTimeout(function() {
          _this9.trigger("mediaupdatetimeout");
          createMediaUpdateTimeout2();
        }, refreshDelay(_this9.media(), Boolean(mediaChanged)));
      };
      createMediaUpdateTimeout();
    }
    this.trigger("loadedplaylist");
  };
  return DashPlaylistLoader2;
}(EventTarget2);
var Config = {
  GOAL_BUFFER_LENGTH: 30,
  MAX_GOAL_BUFFER_LENGTH: 60,
  BACK_BUFFER_LENGTH: 30,
  GOAL_BUFFER_LENGTH_RATE: 1,
  // 0.5 MB/s
  INITIAL_BANDWIDTH: 4194304,
  // A fudge factor to apply to advertised playlist bitrates to account for
  // temporary flucations in client bandwidth
  BANDWIDTH_VARIANCE: 1.2,
  // How much of the buffer must be filled before we consider upswitching
  BUFFER_LOW_WATER_LINE: 0,
  MAX_BUFFER_LOW_WATER_LINE: 30,
  // TODO: Remove this when experimentalBufferBasedABR is removed
  EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
  BUFFER_LOW_WATER_LINE_RATE: 1,
  // If the buffer is greater than the high water line, we won't switch down
  BUFFER_HIGH_WATER_LINE: 30
};
var stringToArrayBuffer = function stringToArrayBuffer2(string) {
  var view = new Uint8Array(new ArrayBuffer(string.length));
  for (var i = 0; i < string.length; i++) {
    view[i] = string.charCodeAt(i);
  }
  return view.buffer;
};
var browserWorkerPolyFill = function browserWorkerPolyFill2(workerObj) {
  workerObj.on = workerObj.addEventListener;
  workerObj.off = workerObj.removeEventListener;
  return workerObj;
};
var createObjectURL = function createObjectURL2(str) {
  try {
    return URL.createObjectURL(new Blob([str], {
      type: "application/javascript"
    }));
  } catch (e) {
    var blob = new BlobBuilder();
    blob.append(str);
    return URL.createObjectURL(blob.getBlob());
  }
};
var factory = function factory2(code) {
  return function() {
    var objectUrl = createObjectURL(code);
    var worker = browserWorkerPolyFill(new Worker(objectUrl));
    worker.objURL = objectUrl;
    var terminate = worker.terminate;
    worker.on = worker.addEventListener;
    worker.off = worker.removeEventListener;
    worker.terminate = function() {
      URL.revokeObjectURL(objectUrl);
      return terminate.call(this);
    };
    return worker;
  };
};
var transform = function transform2(code) {
  return "var browserWorkerPolyFill = " + browserWorkerPolyFill.toString() + ";\nbrowserWorkerPolyFill(self);\n" + code;
};
var getWorkerString = function getWorkerString2(fn) {
  return fn.toString().replace(/^function.+?{/, "").slice(0, -1);
};
var workerCode$1 = transform(getWorkerString(function() {
  var Stream2 = function Stream3() {
    this.init = function() {
      var listeners = {};
      this.on = function(type3, listener) {
        if (!listeners[type3]) {
          listeners[type3] = [];
        }
        listeners[type3] = listeners[type3].concat(listener);
      };
      this.off = function(type3, listener) {
        var index;
        if (!listeners[type3]) {
          return false;
        }
        index = listeners[type3].indexOf(listener);
        listeners[type3] = listeners[type3].slice();
        listeners[type3].splice(index, 1);
        return index > -1;
      };
      this.trigger = function(type3) {
        var callbacks, i, length, args;
        callbacks = listeners[type3];
        if (!callbacks) {
          return;
        }
        if (arguments.length === 2) {
          length = callbacks.length;
          for (i = 0; i < length; ++i) {
            callbacks[i].call(this, arguments[1]);
          }
        } else {
          args = [];
          i = arguments.length;
          for (i = 1; i < arguments.length; ++i) {
            args.push(arguments[i]);
          }
          length = callbacks.length;
          for (i = 0; i < length; ++i) {
            callbacks[i].apply(this, args);
          }
        }
      };
      this.dispose = function() {
        listeners = {};
      };
    };
  };
  Stream2.prototype.pipe = function(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
    this.on("done", function(flushSource) {
      destination.flush(flushSource);
    });
    this.on("partialdone", function(flushSource) {
      destination.partialFlush(flushSource);
    });
    this.on("endedtimeline", function(flushSource) {
      destination.endTimeline(flushSource);
    });
    this.on("reset", function(flushSource) {
      destination.reset(flushSource);
    });
    return destination;
  };
  Stream2.prototype.push = function(data) {
    this.trigger("data", data);
  };
  Stream2.prototype.flush = function(flushSource) {
    this.trigger("done", flushSource);
  };
  Stream2.prototype.partialFlush = function(flushSource) {
    this.trigger("partialdone", flushSource);
  };
  Stream2.prototype.endTimeline = function(flushSource) {
    this.trigger("endedtimeline", flushSource);
  };
  Stream2.prototype.reset = function(flushSource) {
    this.trigger("reset", flushSource);
  };
  var stream = Stream2;
  var MAX_UINT32$1 = Math.pow(2, 32);
  var getUint64$2 = function getUint642(uint8) {
    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
    var value;
    if (dv.getBigUint64) {
      value = dv.getBigUint64(0);
      if (value < Number.MAX_SAFE_INTEGER) {
        return Number(value);
      }
      return value;
    }
    return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
  };
  var numbers = {
    getUint64: getUint64$2,
    MAX_UINT32: MAX_UINT32$1
  };
  var MAX_UINT32 = numbers.MAX_UINT32;
  var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
  (function() {
    var i;
    types = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      // codingname
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      smhd: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      styp: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: []
    };
    if (typeof Uint8Array === "undefined") {
      return;
    }
    for (i in types) {
      if (types.hasOwnProperty(i)) {
        types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }
    MAJOR_BRAND = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]);
    AVC1_BRAND = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]);
    MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);
    VIDEO_HDLR = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]);
    AUDIO_HDLR = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    HDLR_TYPES = {
      video: VIDEO_HDLR,
      audio: AUDIO_HDLR
    };
    DREF = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]);
    SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance, 0 means centered
      0,
      0
      // reserved
    ]);
    STCO = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    STSC = STCO;
    STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]);
    STTS = STCO;
    VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]);
  })();
  box = function box2(type3) {
    var payload = [], size = 0, i, result, view;
    for (i = 1; i < arguments.length; i++) {
      payload.push(arguments[i]);
    }
    i = payload.length;
    while (i--) {
      size += payload[i].byteLength;
    }
    result = new Uint8Array(size + 8);
    view = new DataView(result.buffer, result.byteOffset, result.byteLength);
    view.setUint32(0, result.byteLength);
    result.set(type3, 4);
    for (i = 0, size = 8; i < payload.length; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  };
  dinf = function dinf2() {
    return box(types.dinf, box(types.dref, DREF));
  };
  esds = function esds2(track) {
    return box(types.esds, new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      // ES_Descriptor
      3,
      // tag, ES_DescrTag
      25,
      // length
      0,
      0,
      // ES_ID
      0,
      // streamDependenceFlag, URL_flag, reserved, streamPriority
      // DecoderConfigDescriptor
      4,
      // tag, DecoderConfigDescrTag
      17,
      // length
      64,
      // object type
      21,
      // streamType
      0,
      6,
      0,
      // bufferSizeDB
      0,
      0,
      218,
      192,
      // maxBitrate
      0,
      0,
      218,
      192,
      // avgBitrate
      // DecoderSpecificInfo
      5,
      // tag, DecoderSpecificInfoTag
      2,
      // length
      // ISO/IEC 14496-3, AudioSpecificConfig
      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1,
      track.samplingfrequencyindex << 7 | track.channelcount << 3,
      6,
      1,
      2
      // GASpecificConfig
    ]));
  };
  ftyp = function ftyp2() {
    return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
  };
  hdlr = function hdlr2(type3) {
    return box(types.hdlr, HDLR_TYPES[type3]);
  };
  mdat = function mdat2(data) {
    return box(types.mdat, data);
  };
  mdhd = function mdhd2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      3,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      track.duration >>> 24 & 255,
      track.duration >>> 16 & 255,
      track.duration >>> 8 & 255,
      track.duration & 255,
      // duration
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]);
    if (track.samplerate) {
      result[12] = track.samplerate >>> 24 & 255;
      result[13] = track.samplerate >>> 16 & 255;
      result[14] = track.samplerate >>> 8 & 255;
      result[15] = track.samplerate & 255;
    }
    return box(types.mdhd, result);
  };
  mdia = function mdia2(track) {
    return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
  };
  mfhd = function mfhd2(sequenceNumber) {
    return box(types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      (sequenceNumber & 4278190080) >> 24,
      (sequenceNumber & 16711680) >> 16,
      (sequenceNumber & 65280) >> 8,
      sequenceNumber & 255
      // sequence_number
    ]));
  };
  minf = function minf2(track) {
    return box(types.minf, track.type === "video" ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
  };
  moof = function moof2(sequenceNumber, tracks) {
    var trackFragments = [], i = tracks.length;
    while (i--) {
      trackFragments[i] = traf(tracks[i]);
    }
    return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));
  };
  moov = function moov2(tracks) {
    var i = tracks.length, boxes = [];
    while (i--) {
      boxes[i] = trak(tracks[i]);
    }
    return box.apply(null, [types.moov, mvhd(4294967295)].concat(boxes).concat(mvex(tracks)));
  };
  mvex = function mvex2(tracks) {
    var i = tracks.length, boxes = [];
    while (i--) {
      boxes[i] = trex(tracks[i]);
    }
    return box.apply(null, [types.mvex].concat(boxes));
  };
  mvhd = function mvhd2(duration5) {
    var bytes = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // creation_time
      0,
      0,
      0,
      2,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      (duration5 & 4278190080) >> 24,
      (duration5 & 16711680) >> 16,
      (duration5 & 65280) >> 8,
      duration5 & 255,
      // duration
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return box(types.mvhd, bytes);
  };
  sdtp = function sdtp2(track) {
    var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i;
    for (i = 0; i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }
    return box(types.sdtp, bytes);
  };
  stbl = function stbl2(track) {
    return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
  };
  (function() {
    var videoSample, audioSample;
    stsd = function stsd2(track) {
      return box(types.stsd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1
      ]), track.type === "video" ? videoSample(track) : audioSample(track));
    };
    videoSample = function videoSample2(track) {
      var sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [], i, avc1Box;
      for (i = 0; i < sps.length; i++) {
        sequenceParameterSets.push((sps[i].byteLength & 65280) >>> 8);
        sequenceParameterSets.push(sps[i].byteLength & 255);
        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
      }
      for (i = 0; i < pps.length; i++) {
        pictureParameterSets.push((pps[i].byteLength & 65280) >>> 8);
        pictureParameterSets.push(pps[i].byteLength & 255);
        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
      }
      avc1Box = [types.avc1, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        (track.width & 65280) >> 8,
        track.width & 255,
        // width
        (track.height & 65280) >> 8,
        track.height & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        19,
        118,
        105,
        100,
        101,
        111,
        106,
        115,
        45,
        99,
        111,
        110,
        116,
        114,
        105,
        98,
        45,
        104,
        108,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
        // pre_defined = -1
      ]), box(types.avcC, new Uint8Array([
        1,
        // configurationVersion
        track.profileIdc,
        // AVCProfileIndication
        track.profileCompatibility,
        // profile_compatibility
        track.levelIdc,
        // AVCLevelIndication
        255
        // lengthSizeMinusOne, hard-coded to 4 bytes
      ].concat(
        [sps.length],
        // numOfSequenceParameterSets
        sequenceParameterSets,
        // "SPS"
        [pps.length],
        // numOfPictureParameterSets
        pictureParameterSets
        // "PPS"
      ))), box(types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
        // avgBitrate
      ]))];
      if (track.sarRatio) {
        var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
        avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 4278190080) >> 24, (hSpacing & 16711680) >> 16, (hSpacing & 65280) >> 8, hSpacing & 255, (vSpacing & 4278190080) >> 24, (vSpacing & 16711680) >> 16, (vSpacing & 65280) >> 8, vSpacing & 255])));
      }
      return box.apply(null, avc1Box);
    };
    audioSample = function audioSample2(track) {
      return box(types.mp4a, new Uint8Array([
        // SampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        // AudioSampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        (track.channelcount & 65280) >> 8,
        track.channelcount & 255,
        // channelcount
        (track.samplesize & 65280) >> 8,
        track.samplesize & 255,
        // samplesize
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        (track.samplerate & 65280) >> 8,
        track.samplerate & 255,
        0,
        0
        // samplerate, 16.16
        // MP4AudioSampleEntry, ISO/IEC 14496-14
      ]), esds(track));
    };
  })();
  tkhd = function tkhd2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      // creation_time
      0,
      0,
      0,
      0,
      // modification_time
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      (track.duration & 4278190080) >> 24,
      (track.duration & 16711680) >> 16,
      (track.duration & 65280) >> 8,
      track.duration & 255,
      // duration
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      1,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      (track.width & 65280) >> 8,
      track.width & 255,
      0,
      0,
      // width
      (track.height & 65280) >> 8,
      track.height & 255,
      0,
      0
      // height
    ]);
    return box(types.tkhd, result);
  };
  traf = function traf2(track) {
    var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
    trackFragmentHeader = box(types.tfhd, new Uint8Array([
      0,
      // version 0
      0,
      0,
      58,
      // flags
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      0,
      0,
      0
      // default_sample_flags
    ]));
    upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);
    lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);
    trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      // baseMediaDecodeTime
      upperWordBaseMediaDecodeTime >>> 24 & 255,
      upperWordBaseMediaDecodeTime >>> 16 & 255,
      upperWordBaseMediaDecodeTime >>> 8 & 255,
      upperWordBaseMediaDecodeTime & 255,
      lowerWordBaseMediaDecodeTime >>> 24 & 255,
      lowerWordBaseMediaDecodeTime >>> 16 & 255,
      lowerWordBaseMediaDecodeTime >>> 8 & 255,
      lowerWordBaseMediaDecodeTime & 255
    ]));
    dataOffset = 32 + // tfhd
    20 + // tfdt
    8 + // traf header
    16 + // mfhd
    8 + // moof header
    8;
    if (track.type === "audio") {
      trackFragmentRun = trun$1(track, dataOffset);
      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
    }
    sampleDependencyTable = sdtp(track);
    trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
  };
  trak = function trak2(track) {
    track.duration = track.duration || 4294967295;
    return box(types.trak, tkhd(track), mdia(track));
  };
  trex = function trex2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]);
    if (track.type !== "video") {
      result[result.length - 1] = 0;
    }
    return box(types.trex, result);
  };
  (function() {
    var audioTrun, videoTrun, trunHeader;
    trunHeader = function trunHeader2(samples, offset) {
      var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
      if (samples.length) {
        if (samples[0].duration !== void 0) {
          durationPresent = 1;
        }
        if (samples[0].size !== void 0) {
          sizePresent = 2;
        }
        if (samples[0].flags !== void 0) {
          flagsPresent = 4;
        }
        if (samples[0].compositionTimeOffset !== void 0) {
          compositionTimeOffset = 8;
        }
      }
      return [
        0,
        // version 0
        0,
        durationPresent | sizePresent | flagsPresent | compositionTimeOffset,
        1,
        // flags
        (samples.length & 4278190080) >>> 24,
        (samples.length & 16711680) >>> 16,
        (samples.length & 65280) >>> 8,
        samples.length & 255,
        // sample_count
        (offset & 4278190080) >>> 24,
        (offset & 16711680) >>> 16,
        (offset & 65280) >>> 8,
        offset & 255
        // data_offset
      ];
    };
    videoTrun = function videoTrun2(track, offset) {
      var bytesOffest, bytes, header, samples, sample, i;
      samples = track.samples || [];
      offset += 8 + 12 + 16 * samples.length;
      header = trunHeader(samples, offset);
      bytes = new Uint8Array(header.length + samples.length * 16);
      bytes.set(header);
      bytesOffest = header.length;
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
        bytes[bytesOffest++] = sample.duration & 255;
        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
        bytes[bytesOffest++] = sample.size & 255;
        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
        bytes[bytesOffest++] = sample.flags.degradationPriority & 240 << 8;
        bytes[bytesOffest++] = sample.flags.degradationPriority & 15;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 65280) >>> 8;
        bytes[bytesOffest++] = sample.compositionTimeOffset & 255;
      }
      return box(types.trun, bytes);
    };
    audioTrun = function audioTrun2(track, offset) {
      var bytes, bytesOffest, header, samples, sample, i;
      samples = track.samples || [];
      offset += 8 + 12 + 8 * samples.length;
      header = trunHeader(samples, offset);
      bytes = new Uint8Array(header.length + samples.length * 8);
      bytes.set(header);
      bytesOffest = header.length;
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
        bytes[bytesOffest++] = sample.duration & 255;
        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
        bytes[bytesOffest++] = sample.size & 255;
      }
      return box(types.trun, bytes);
    };
    trun$1 = function trun2(track, offset) {
      if (track.type === "audio") {
        return audioTrun(track, offset);
      }
      return videoTrun(track, offset);
    };
  })();
  var mp4Generator = {
    ftyp,
    mdat,
    moof,
    moov,
    initSegment: function initSegment(tracks) {
      var fileType = ftyp(), movie = moov(tracks), result;
      result = new Uint8Array(fileType.byteLength + movie.byteLength);
      result.set(fileType);
      result.set(movie, fileType.byteLength);
      return result;
    }
  };
  var groupNalsIntoFrames = function groupNalsIntoFrames2(nalUnits) {
    var i, currentNal, currentFrame = [], frames = [];
    frames.byteLength = 0;
    frames.nalCount = 0;
    frames.duration = 0;
    currentFrame.byteLength = 0;
    for (i = 0; i < nalUnits.length; i++) {
      currentNal = nalUnits[i];
      if (currentNal.nalUnitType === "access_unit_delimiter_rbsp") {
        if (currentFrame.length) {
          currentFrame.duration = currentNal.dts - currentFrame.dts;
          frames.byteLength += currentFrame.byteLength;
          frames.nalCount += currentFrame.length;
          frames.duration += currentFrame.duration;
          frames.push(currentFrame);
        }
        currentFrame = [currentNal];
        currentFrame.byteLength = currentNal.data.byteLength;
        currentFrame.pts = currentNal.pts;
        currentFrame.dts = currentNal.dts;
      } else {
        if (currentNal.nalUnitType === "slice_layer_without_partitioning_rbsp_idr") {
          currentFrame.keyFrame = true;
        }
        currentFrame.duration = currentNal.dts - currentFrame.dts;
        currentFrame.byteLength += currentNal.data.byteLength;
        currentFrame.push(currentNal);
      }
    }
    if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {
      currentFrame.duration = frames[frames.length - 1].duration;
    }
    frames.byteLength += currentFrame.byteLength;
    frames.nalCount += currentFrame.length;
    frames.duration += currentFrame.duration;
    frames.push(currentFrame);
    return frames;
  };
  var groupFramesIntoGops = function groupFramesIntoGops2(frames) {
    var i, currentFrame, currentGop = [], gops = [];
    currentGop.byteLength = 0;
    currentGop.nalCount = 0;
    currentGop.duration = 0;
    currentGop.pts = frames[0].pts;
    currentGop.dts = frames[0].dts;
    gops.byteLength = 0;
    gops.nalCount = 0;
    gops.duration = 0;
    gops.pts = frames[0].pts;
    gops.dts = frames[0].dts;
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      if (currentFrame.keyFrame) {
        if (currentGop.length) {
          gops.push(currentGop);
          gops.byteLength += currentGop.byteLength;
          gops.nalCount += currentGop.nalCount;
          gops.duration += currentGop.duration;
        }
        currentGop = [currentFrame];
        currentGop.nalCount = currentFrame.length;
        currentGop.byteLength = currentFrame.byteLength;
        currentGop.pts = currentFrame.pts;
        currentGop.dts = currentFrame.dts;
        currentGop.duration = currentFrame.duration;
      } else {
        currentGop.duration += currentFrame.duration;
        currentGop.nalCount += currentFrame.length;
        currentGop.byteLength += currentFrame.byteLength;
        currentGop.push(currentFrame);
      }
    }
    if (gops.length && currentGop.duration <= 0) {
      currentGop.duration = gops[gops.length - 1].duration;
    }
    gops.byteLength += currentGop.byteLength;
    gops.nalCount += currentGop.nalCount;
    gops.duration += currentGop.duration;
    gops.push(currentGop);
    return gops;
  };
  var extendFirstKeyFrame = function extendFirstKeyFrame2(gops) {
    var currentGop;
    if (!gops[0][0].keyFrame && gops.length > 1) {
      currentGop = gops.shift();
      gops.byteLength -= currentGop.byteLength;
      gops.nalCount -= currentGop.nalCount;
      gops[0][0].dts = currentGop.dts;
      gops[0][0].pts = currentGop.pts;
      gops[0][0].duration += currentGop.duration;
    }
    return gops;
  };
  var createDefaultSample = function createDefaultSample2() {
    return {
      size: 0,
      flags: {
        isLeading: 0,
        dependsOn: 1,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradationPriority: 0,
        isNonSyncSample: 1
      }
    };
  };
  var sampleForFrame = function sampleForFrame2(frame, dataOffset) {
    var sample = createDefaultSample();
    sample.dataOffset = dataOffset;
    sample.compositionTimeOffset = frame.pts - frame.dts;
    sample.duration = frame.duration;
    sample.size = 4 * frame.length;
    sample.size += frame.byteLength;
    if (frame.keyFrame) {
      sample.flags.dependsOn = 2;
      sample.flags.isNonSyncSample = 0;
    }
    return sample;
  };
  var generateSampleTable$1 = function generateSampleTable2(gops, baseDataOffset) {
    var h3, i, sample, currentGop, currentFrame, dataOffset = baseDataOffset || 0, samples = [];
    for (h3 = 0; h3 < gops.length; h3++) {
      currentGop = gops[h3];
      for (i = 0; i < currentGop.length; i++) {
        currentFrame = currentGop[i];
        sample = sampleForFrame(currentFrame, dataOffset);
        dataOffset += sample.size;
        samples.push(sample);
      }
    }
    return samples;
  };
  var concatenateNalData = function concatenateNalData2(gops) {
    var h3, i, j2, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
    for (h3 = 0; h3 < gops.length; h3++) {
      currentGop = gops[h3];
      for (i = 0; i < currentGop.length; i++) {
        currentFrame = currentGop[i];
        for (j2 = 0; j2 < currentFrame.length; j2++) {
          currentNal = currentFrame[j2];
          view.setUint32(dataOffset, currentNal.data.byteLength);
          dataOffset += 4;
          data.set(currentNal.data, dataOffset);
          dataOffset += currentNal.data.byteLength;
        }
      }
    }
    return data;
  };
  var generateSampleTableForFrame = function generateSampleTableForFrame2(frame, baseDataOffset) {
    var sample, dataOffset = baseDataOffset || 0, samples = [];
    sample = sampleForFrame(frame, dataOffset);
    samples.push(sample);
    return samples;
  };
  var concatenateNalDataForFrame = function concatenateNalDataForFrame2(frame) {
    var i, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
    for (i = 0; i < frame.length; i++) {
      currentNal = frame[i];
      view.setUint32(dataOffset, currentNal.data.byteLength);
      dataOffset += 4;
      data.set(currentNal.data, dataOffset);
      dataOffset += currentNal.data.byteLength;
    }
    return data;
  };
  var frameUtils = {
    groupNalsIntoFrames,
    groupFramesIntoGops,
    extendFirstKeyFrame,
    generateSampleTable: generateSampleTable$1,
    concatenateNalData,
    generateSampleTableForFrame,
    concatenateNalDataForFrame
  };
  var highPrefix = [33, 16, 5, 32, 164, 27];
  var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];
  var zeroFill = function zeroFill2(count) {
    var a = [];
    while (count--) {
      a.push(0);
    }
    return a;
  };
  var makeTable = function makeTable2(metaTable) {
    return Object.keys(metaTable).reduce(function(obj, key) {
      obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {
        return arr.concat(part);
      }, []));
      return obj;
    }, {});
  };
  var silence;
  var silence_1 = function silence_12() {
    if (!silence) {
      var coneOfSilence = {
        96e3: [highPrefix, [227, 64], zeroFill(154), [56]],
        88200: [highPrefix, [231], zeroFill(170), [56]],
        64e3: [highPrefix, [248, 192], zeroFill(240), [56]],
        48e3: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],
        44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],
        32e3: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],
        24e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],
        16e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],
        12e3: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],
        11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],
        8e3: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]
      };
      silence = makeTable(coneOfSilence);
    }
    return silence;
  };
  var ONE_SECOND_IN_TS$4 = 9e4, secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds;
  secondsToVideoTs = function secondsToVideoTs2(seconds) {
    return seconds * ONE_SECOND_IN_TS$4;
  };
  secondsToAudioTs = function secondsToAudioTs2(seconds, sampleRate) {
    return seconds * sampleRate;
  };
  videoTsToSeconds = function videoTsToSeconds2(timestamp) {
    return timestamp / ONE_SECOND_IN_TS$4;
  };
  audioTsToSeconds = function audioTsToSeconds2(timestamp, sampleRate) {
    return timestamp / sampleRate;
  };
  audioTsToVideoTs = function audioTsToVideoTs2(timestamp, sampleRate) {
    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
  };
  videoTsToAudioTs = function videoTsToAudioTs2(timestamp, sampleRate) {
    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
  };
  metadataTsToSeconds = function metadataTsToSeconds2(timestamp, timelineStartPts, keepOriginalTimestamps) {
    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
  };
  var clock = {
    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
    secondsToVideoTs,
    secondsToAudioTs,
    videoTsToSeconds,
    audioTsToSeconds,
    audioTsToVideoTs,
    videoTsToAudioTs,
    metadataTsToSeconds
  };
  var sumFrameByteLengths = function sumFrameByteLengths2(array) {
    var i, currentObj, sum = 0;
    for (i = 0; i < array.length; i++) {
      currentObj = array[i];
      sum += currentObj.data.byteLength;
    }
    return sum;
  };
  var prefixWithSilence = function prefixWithSilence2(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
    var baseMediaDecodeTimeTs, frameDuration = 0, audioGapDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0, silentFrame, i, firstFrame;
    if (!frames.length) {
      return;
    }
    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
    frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));
    if (audioAppendStartTs && videoBaseMediaDecodeTime) {
      audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
      audioFillDuration = audioFillFrameCount * frameDuration;
    }
    if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {
      return;
    }
    silentFrame = silence_1()[track.samplerate];
    if (!silentFrame) {
      silentFrame = frames[0].data;
    }
    for (i = 0; i < audioFillFrameCount; i++) {
      firstFrame = frames[0];
      frames.splice(0, 0, {
        data: silentFrame,
        dts: firstFrame.dts - frameDuration,
        pts: firstFrame.pts - frameDuration
      });
    }
    track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));
    return audioFillDuration;
  };
  var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts2(adtsFrames, track, earliestAllowedDts) {
    if (track.minSegmentDts >= earliestAllowedDts) {
      return adtsFrames;
    }
    track.minSegmentDts = Infinity;
    return adtsFrames.filter(function(currentFrame) {
      if (currentFrame.dts >= earliestAllowedDts) {
        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
        track.minSegmentPts = track.minSegmentDts;
        return true;
      }
      return false;
    });
  };
  var generateSampleTable = function generateSampleTable2(frames) {
    var i, currentFrame, samples = [];
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      samples.push({
        size: currentFrame.data.byteLength,
        duration: 1024
        // For AAC audio, all samples contain 1024 samples
      });
    }
    return samples;
  };
  var concatenateFrameData = function concatenateFrameData2(frames) {
    var i, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      data.set(currentFrame.data, dataOffset);
      dataOffset += currentFrame.data.byteLength;
    }
    return data;
  };
  var audioFrameUtils = {
    prefixWithSilence,
    trimAdtsFramesByEarliestDts,
    generateSampleTable,
    concatenateFrameData
  };
  var ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS;
  var collectDtsInfo = function collectDtsInfo2(track, data) {
    if (typeof data.pts === "number") {
      if (track.timelineStartInfo.pts === void 0) {
        track.timelineStartInfo.pts = data.pts;
      }
      if (track.minSegmentPts === void 0) {
        track.minSegmentPts = data.pts;
      } else {
        track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
      }
      if (track.maxSegmentPts === void 0) {
        track.maxSegmentPts = data.pts;
      } else {
        track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
      }
    }
    if (typeof data.dts === "number") {
      if (track.timelineStartInfo.dts === void 0) {
        track.timelineStartInfo.dts = data.dts;
      }
      if (track.minSegmentDts === void 0) {
        track.minSegmentDts = data.dts;
      } else {
        track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
      }
      if (track.maxSegmentDts === void 0) {
        track.maxSegmentDts = data.dts;
      } else {
        track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
      }
    }
  };
  var clearDtsInfo = function clearDtsInfo2(track) {
    delete track.minSegmentDts;
    delete track.maxSegmentDts;
    delete track.minSegmentPts;
    delete track.maxSegmentPts;
  };
  var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime2(track, keepOriginalTimestamps) {
    var baseMediaDecodeTime, scale, minSegmentDts = track.minSegmentDts;
    if (!keepOriginalTimestamps) {
      minSegmentDts -= track.timelineStartInfo.dts;
    }
    baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
    baseMediaDecodeTime += minSegmentDts;
    baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
    if (track.type === "audio") {
      scale = track.samplerate / ONE_SECOND_IN_TS$3;
      baseMediaDecodeTime *= scale;
      baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
    }
    return baseMediaDecodeTime;
  };
  var trackDecodeInfo = {
    clearDtsInfo,
    calculateTrackBaseMediaDecodeTime,
    collectDtsInfo
  };
  var USER_DATA_REGISTERED_ITU_T_T35 = 4, RBSP_TRAILING_BITS = 128;
  var parseSei = function parseSei2(bytes) {
    var i = 0, result = {
      payloadType: -1,
      payloadSize: 0
    }, payloadType = 0, payloadSize = 0;
    while (i < bytes.byteLength) {
      if (bytes[i] === RBSP_TRAILING_BITS) {
        break;
      }
      while (bytes[i] === 255) {
        payloadType += 255;
        i++;
      }
      payloadType += bytes[i++];
      while (bytes[i] === 255) {
        payloadSize += 255;
        i++;
      }
      payloadSize += bytes[i++];
      if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);
        if (userIdentifier === "GA94") {
          result.payloadType = payloadType;
          result.payloadSize = payloadSize;
          result.payload = bytes.subarray(i, i + payloadSize);
          break;
        } else {
          result.payload = void 0;
        }
      }
      i += payloadSize;
      payloadType = 0;
      payloadSize = 0;
    }
    return result;
  };
  var parseUserData = function parseUserData2(sei) {
    if (sei.payload[0] !== 181) {
      return null;
    }
    if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {
      return null;
    }
    if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== "GA94") {
      return null;
    }
    if (sei.payload[7] !== 3) {
      return null;
    }
    return sei.payload.subarray(8, sei.payload.length - 1);
  };
  var parseCaptionPackets = function parseCaptionPackets2(pts, userData) {
    var results = [], i, count, offset, data;
    if (!(userData[0] & 64)) {
      return results;
    }
    count = userData[0] & 31;
    for (i = 0; i < count; i++) {
      offset = i * 3;
      data = {
        type: userData[offset + 2] & 3,
        pts
      };
      if (userData[offset + 2] & 4) {
        data.ccData = userData[offset + 3] << 8 | userData[offset + 4];
        results.push(data);
      }
    }
    return results;
  };
  var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes4(data) {
    var length = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
    while (i < length - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
        emulationPreventionBytesPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }
    if (emulationPreventionBytesPositions.length === 0) {
      return data;
    }
    newLength = length - emulationPreventionBytesPositions.length;
    newData = new Uint8Array(newLength);
    var sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === emulationPreventionBytesPositions[0]) {
        sourceIndex++;
        emulationPreventionBytesPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  };
  var captionPacketParser = {
    parseSei,
    parseUserData,
    parseCaptionPackets,
    discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
    USER_DATA_REGISTERED_ITU_T_T35
  };
  var CaptionStream$1 = function CaptionStream2(options) {
    options = options || {};
    CaptionStream2.prototype.init.call(this);
    this.parse708captions_ = typeof options.parse708captions === "boolean" ? options.parse708captions : true;
    this.captionPackets_ = [];
    this.ccStreams_ = [
      new Cea608Stream(0, 0),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(0, 1),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(1, 0),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(1, 1)
      // eslint-disable-line no-use-before-define
    ];
    if (this.parse708captions_) {
      this.cc708Stream_ = new Cea708Stream({
        captionServices: options.captionServices
      });
    }
    this.reset();
    this.ccStreams_.forEach(function(cc) {
      cc.on("data", this.trigger.bind(this, "data"));
      cc.on("partialdone", this.trigger.bind(this, "partialdone"));
      cc.on("done", this.trigger.bind(this, "done"));
    }, this);
    if (this.parse708captions_) {
      this.cc708Stream_.on("data", this.trigger.bind(this, "data"));
      this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone"));
      this.cc708Stream_.on("done", this.trigger.bind(this, "done"));
    }
  };
  CaptionStream$1.prototype = new stream();
  CaptionStream$1.prototype.push = function(event) {
    var sei, userData, newCaptionPackets;
    if (event.nalUnitType !== "sei_rbsp") {
      return;
    }
    sei = captionPacketParser.parseSei(event.escapedRBSP);
    if (!sei.payload) {
      return;
    }
    if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {
      return;
    }
    userData = captionPacketParser.parseUserData(sei);
    if (!userData) {
      return;
    }
    if (event.dts < this.latestDts_) {
      this.ignoreNextEqualDts_ = true;
      return;
    } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
      this.numSameDts_--;
      if (!this.numSameDts_) {
        this.ignoreNextEqualDts_ = false;
      }
      return;
    }
    newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);
    this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
    if (this.latestDts_ !== event.dts) {
      this.numSameDts_ = 0;
    }
    this.numSameDts_++;
    this.latestDts_ = event.dts;
  };
  CaptionStream$1.prototype.flushCCStreams = function(flushType) {
    this.ccStreams_.forEach(function(cc) {
      return flushType === "flush" ? cc.flush() : cc.partialFlush();
    }, this);
  };
  CaptionStream$1.prototype.flushStream = function(flushType) {
    if (!this.captionPackets_.length) {
      this.flushCCStreams(flushType);
      return;
    }
    this.captionPackets_.forEach(function(elem, idx) {
      elem.presortIndex = idx;
    });
    this.captionPackets_.sort(function(a, b2) {
      if (a.pts === b2.pts) {
        return a.presortIndex - b2.presortIndex;
      }
      return a.pts - b2.pts;
    });
    this.captionPackets_.forEach(function(packet) {
      if (packet.type < 2) {
        this.dispatchCea608Packet(packet);
      } else {
        this.dispatchCea708Packet(packet);
      }
    }, this);
    this.captionPackets_.length = 0;
    this.flushCCStreams(flushType);
  };
  CaptionStream$1.prototype.flush = function() {
    return this.flushStream("flush");
  };
  CaptionStream$1.prototype.partialFlush = function() {
    return this.flushStream("partialFlush");
  };
  CaptionStream$1.prototype.reset = function() {
    this.latestDts_ = null;
    this.ignoreNextEqualDts_ = false;
    this.numSameDts_ = 0;
    this.activeCea608Channel_ = [null, null];
    this.ccStreams_.forEach(function(ccStream) {
      ccStream.reset();
    });
  };
  CaptionStream$1.prototype.dispatchCea608Packet = function(packet) {
    if (this.setsTextOrXDSActive(packet)) {
      this.activeCea608Channel_[packet.type] = null;
    } else if (this.setsChannel1Active(packet)) {
      this.activeCea608Channel_[packet.type] = 0;
    } else if (this.setsChannel2Active(packet)) {
      this.activeCea608Channel_[packet.type] = 1;
    }
    if (this.activeCea608Channel_[packet.type] === null) {
      return;
    }
    this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
  };
  CaptionStream$1.prototype.setsChannel1Active = function(packet) {
    return (packet.ccData & 30720) === 4096;
  };
  CaptionStream$1.prototype.setsChannel2Active = function(packet) {
    return (packet.ccData & 30720) === 6144;
  };
  CaptionStream$1.prototype.setsTextOrXDSActive = function(packet) {
    return (packet.ccData & 28928) === 256 || (packet.ccData & 30974) === 4138 || (packet.ccData & 30974) === 6186;
  };
  CaptionStream$1.prototype.dispatchCea708Packet = function(packet) {
    if (this.parse708captions_) {
      this.cc708Stream_.push(packet);
    }
  };
  var CHARACTER_TRANSLATION_708 = {
    127: 9834,
    // ♪
    4128: 32,
    // Transparent Space
    4129: 160,
    // Nob-breaking Transparent Space
    4133: 8230,
    // …
    4138: 352,
    // Š
    4140: 338,
    // Œ
    4144: 9608,
    // █
    4145: 8216,
    // ‘
    4146: 8217,
    // ’
    4147: 8220,
    // “
    4148: 8221,
    // ”
    4149: 8226,
    // •
    4153: 8482,
    // ™
    4154: 353,
    // š
    4156: 339,
    // œ
    4157: 8480,
    // ℠
    4159: 376,
    // Ÿ
    4214: 8539,
    // ⅛
    4215: 8540,
    // ⅜
    4216: 8541,
    // ⅝
    4217: 8542,
    // ⅞
    4218: 9168,
    // ⏐
    4219: 9124,
    // ⎤
    4220: 9123,
    // ⎣
    4221: 9135,
    // ⎯
    4222: 9126,
    // ⎦
    4223: 9121,
    // ⎡
    4256: 12600
    // ㄸ (CC char)
  };
  var get708CharFromCode = function get708CharFromCode2(code) {
    var newCode = CHARACTER_TRANSLATION_708[code] || code;
    if (code & 4096 && code === newCode) {
      return "";
    }
    return String.fromCharCode(newCode);
  };
  var within708TextBlock = function within708TextBlock2(b2) {
    return 32 <= b2 && b2 <= 127 || 160 <= b2 && b2 <= 255;
  };
  var Cea708Window = function Cea708Window2(windowNum) {
    this.windowNum = windowNum;
    this.reset();
  };
  Cea708Window.prototype.reset = function() {
    this.clearText();
    this.pendingNewLine = false;
    this.winAttr = {};
    this.penAttr = {};
    this.penLoc = {};
    this.penColor = {};
    this.visible = 0;
    this.rowLock = 0;
    this.columnLock = 0;
    this.priority = 0;
    this.relativePositioning = 0;
    this.anchorVertical = 0;
    this.anchorHorizontal = 0;
    this.anchorPoint = 0;
    this.rowCount = 1;
    this.virtualRowCount = this.rowCount + 1;
    this.columnCount = 41;
    this.windowStyle = 0;
    this.penStyle = 0;
  };
  Cea708Window.prototype.getText = function() {
    return this.rows.join("\n");
  };
  Cea708Window.prototype.clearText = function() {
    this.rows = [""];
    this.rowIdx = 0;
  };
  Cea708Window.prototype.newLine = function(pts) {
    if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === "function") {
      this.beforeRowOverflow(pts);
    }
    if (this.rows.length > 0) {
      this.rows.push("");
      this.rowIdx++;
    }
    while (this.rows.length > this.virtualRowCount) {
      this.rows.shift();
      this.rowIdx--;
    }
  };
  Cea708Window.prototype.isEmpty = function() {
    if (this.rows.length === 0) {
      return true;
    } else if (this.rows.length === 1) {
      return this.rows[0] === "";
    }
    return false;
  };
  Cea708Window.prototype.addText = function(text) {
    this.rows[this.rowIdx] += text;
  };
  Cea708Window.prototype.backspace = function() {
    if (!this.isEmpty()) {
      var row = this.rows[this.rowIdx];
      this.rows[this.rowIdx] = row.substr(0, row.length - 1);
    }
  };
  var Cea708Service = function Cea708Service2(serviceNum, encoding, stream2) {
    this.serviceNum = serviceNum;
    this.text = "";
    this.currentWindow = new Cea708Window(-1);
    this.windows = [];
    this.stream = stream2;
    if (typeof encoding === "string") {
      this.createTextDecoder(encoding);
    }
  };
  Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
    this.startPts = pts;
    for (var win2 = 0; win2 < 8; win2++) {
      this.windows[win2] = new Cea708Window(win2);
      if (typeof beforeRowOverflow === "function") {
        this.windows[win2].beforeRowOverflow = beforeRowOverflow;
      }
    }
  };
  Cea708Service.prototype.setCurrentWindow = function(windowNum) {
    this.currentWindow = this.windows[windowNum];
  };
  Cea708Service.prototype.createTextDecoder = function(encoding) {
    if (typeof TextDecoder === "undefined") {
      this.stream.trigger("log", {
        level: "warn",
        message: "The `encoding` option is unsupported without TextDecoder support"
      });
    } else {
      try {
        this.textDecoder_ = new TextDecoder(encoding);
      } catch (error) {
        this.stream.trigger("log", {
          level: "warn",
          message: "TextDecoder could not be created with " + encoding + " encoding. " + error
        });
      }
    }
  };
  var Cea708Stream = function Cea708Stream2(options) {
    options = options || {};
    Cea708Stream2.prototype.init.call(this);
    var self2 = this;
    var captionServices = options.captionServices || {};
    var captionServiceEncodings = {};
    var serviceProps;
    Object.keys(captionServices).forEach(function(serviceName) {
      serviceProps = captionServices[serviceName];
      if (/^SERVICE/.test(serviceName)) {
        captionServiceEncodings[serviceName] = serviceProps.encoding;
      }
    });
    this.serviceEncodings = captionServiceEncodings;
    this.current708Packet = null;
    this.services = {};
    this.push = function(packet) {
      if (packet.type === 3) {
        self2.new708Packet();
        self2.add708Bytes(packet);
      } else {
        if (self2.current708Packet === null) {
          self2.new708Packet();
        }
        self2.add708Bytes(packet);
      }
    };
  };
  Cea708Stream.prototype = new stream();
  Cea708Stream.prototype.new708Packet = function() {
    if (this.current708Packet !== null) {
      this.push708Packet();
    }
    this.current708Packet = {
      data: [],
      ptsVals: []
    };
  };
  Cea708Stream.prototype.add708Bytes = function(packet) {
    var data = packet.ccData;
    var byte0 = data >>> 8;
    var byte1 = data & 255;
    this.current708Packet.ptsVals.push(packet.pts);
    this.current708Packet.data.push(byte0);
    this.current708Packet.data.push(byte1);
  };
  Cea708Stream.prototype.push708Packet = function() {
    var packet708 = this.current708Packet;
    var packetData = packet708.data;
    var serviceNum = null;
    var blockSize = null;
    var i = 0;
    var b2 = packetData[i++];
    packet708.seq = b2 >> 6;
    packet708.sizeCode = b2 & 63;
    for (; i < packetData.length; i++) {
      b2 = packetData[i++];
      serviceNum = b2 >> 5;
      blockSize = b2 & 31;
      if (serviceNum === 7 && blockSize > 0) {
        b2 = packetData[i++];
        serviceNum = b2;
      }
      this.pushServiceBlock(serviceNum, i, blockSize);
      if (blockSize > 0) {
        i += blockSize - 1;
      }
    }
  };
  Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start2, size) {
    var b2;
    var i = start2;
    var packetData = this.current708Packet.data;
    var service = this.services[serviceNum];
    if (!service) {
      service = this.initService(serviceNum, i);
    }
    for (; i < start2 + size && i < packetData.length; i++) {
      b2 = packetData[i];
      if (within708TextBlock(b2)) {
        i = this.handleText(i, service);
      } else if (b2 === 24) {
        i = this.multiByteCharacter(i, service);
      } else if (b2 === 16) {
        i = this.extendedCommands(i, service);
      } else if (128 <= b2 && b2 <= 135) {
        i = this.setCurrentWindow(i, service);
      } else if (152 <= b2 && b2 <= 159) {
        i = this.defineWindow(i, service);
      } else if (b2 === 136) {
        i = this.clearWindows(i, service);
      } else if (b2 === 140) {
        i = this.deleteWindows(i, service);
      } else if (b2 === 137) {
        i = this.displayWindows(i, service);
      } else if (b2 === 138) {
        i = this.hideWindows(i, service);
      } else if (b2 === 139) {
        i = this.toggleWindows(i, service);
      } else if (b2 === 151) {
        i = this.setWindowAttributes(i, service);
      } else if (b2 === 144) {
        i = this.setPenAttributes(i, service);
      } else if (b2 === 145) {
        i = this.setPenColor(i, service);
      } else if (b2 === 146) {
        i = this.setPenLocation(i, service);
      } else if (b2 === 143) {
        service = this.reset(i, service);
      } else if (b2 === 8) {
        service.currentWindow.backspace();
      } else if (b2 === 12) {
        service.currentWindow.clearText();
      } else if (b2 === 13) {
        service.currentWindow.pendingNewLine = true;
      } else if (b2 === 14) {
        service.currentWindow.clearText();
      } else if (b2 === 141) {
        i++;
      } else ;
    }
  };
  Cea708Stream.prototype.extendedCommands = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    if (within708TextBlock(b2)) {
      i = this.handleText(i, service, {
        isExtended: true
      });
    }
    return i;
  };
  Cea708Stream.prototype.getPts = function(byteIndex) {
    return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
  };
  Cea708Stream.prototype.initService = function(serviceNum, i) {
    var serviceName = "SERVICE" + serviceNum;
    var self2 = this;
    var serviceName;
    var encoding;
    if (serviceName in this.serviceEncodings) {
      encoding = this.serviceEncodings[serviceName];
    }
    this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self2);
    this.services[serviceNum].init(this.getPts(i), function(pts) {
      self2.flushDisplayed(pts, self2.services[serviceNum]);
    });
    return this.services[serviceNum];
  };
  Cea708Stream.prototype.handleText = function(i, service, options) {
    var isExtended = options && options.isExtended;
    var isMultiByte = options && options.isMultiByte;
    var packetData = this.current708Packet.data;
    var extended = isExtended ? 4096 : 0;
    var currentByte = packetData[i];
    var nextByte = packetData[i + 1];
    var win2 = service.currentWindow;
    var _char;
    var charCodeArray;
    if (service.textDecoder_ && !isExtended) {
      if (isMultiByte) {
        charCodeArray = [currentByte, nextByte];
        i++;
      } else {
        charCodeArray = [currentByte];
      }
      _char = service.textDecoder_.decode(new Uint8Array(charCodeArray));
    } else {
      _char = get708CharFromCode(extended | currentByte);
    }
    if (win2.pendingNewLine && !win2.isEmpty()) {
      win2.newLine(this.getPts(i));
    }
    win2.pendingNewLine = false;
    win2.addText(_char);
    return i;
  };
  Cea708Stream.prototype.multiByteCharacter = function(i, service) {
    var packetData = this.current708Packet.data;
    var firstByte = packetData[i + 1];
    var secondByte = packetData[i + 2];
    if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {
      i = this.handleText(++i, service, {
        isMultiByte: true
      });
    }
    return i;
  };
  Cea708Stream.prototype.setCurrentWindow = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var windowNum = b2 & 7;
    service.setCurrentWindow(windowNum);
    return i;
  };
  Cea708Stream.prototype.defineWindow = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var windowNum = b2 & 7;
    service.setCurrentWindow(windowNum);
    var win2 = service.currentWindow;
    b2 = packetData[++i];
    win2.visible = (b2 & 32) >> 5;
    win2.rowLock = (b2 & 16) >> 4;
    win2.columnLock = (b2 & 8) >> 3;
    win2.priority = b2 & 7;
    b2 = packetData[++i];
    win2.relativePositioning = (b2 & 128) >> 7;
    win2.anchorVertical = b2 & 127;
    b2 = packetData[++i];
    win2.anchorHorizontal = b2;
    b2 = packetData[++i];
    win2.anchorPoint = (b2 & 240) >> 4;
    win2.rowCount = b2 & 15;
    b2 = packetData[++i];
    win2.columnCount = b2 & 63;
    b2 = packetData[++i];
    win2.windowStyle = (b2 & 56) >> 3;
    win2.penStyle = b2 & 7;
    win2.virtualRowCount = win2.rowCount + 1;
    return i;
  };
  Cea708Stream.prototype.setWindowAttributes = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var winAttr = service.currentWindow.winAttr;
    b2 = packetData[++i];
    winAttr.fillOpacity = (b2 & 192) >> 6;
    winAttr.fillRed = (b2 & 48) >> 4;
    winAttr.fillGreen = (b2 & 12) >> 2;
    winAttr.fillBlue = b2 & 3;
    b2 = packetData[++i];
    winAttr.borderType = (b2 & 192) >> 6;
    winAttr.borderRed = (b2 & 48) >> 4;
    winAttr.borderGreen = (b2 & 12) >> 2;
    winAttr.borderBlue = b2 & 3;
    b2 = packetData[++i];
    winAttr.borderType += (b2 & 128) >> 5;
    winAttr.wordWrap = (b2 & 64) >> 6;
    winAttr.printDirection = (b2 & 48) >> 4;
    winAttr.scrollDirection = (b2 & 12) >> 2;
    winAttr.justify = b2 & 3;
    b2 = packetData[++i];
    winAttr.effectSpeed = (b2 & 240) >> 4;
    winAttr.effectDirection = (b2 & 12) >> 2;
    winAttr.displayEffect = b2 & 3;
    return i;
  };
  Cea708Stream.prototype.flushDisplayed = function(pts, service) {
    var displayedText = [];
    for (var winId = 0; winId < 8; winId++) {
      if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {
        displayedText.push(service.windows[winId].getText());
      }
    }
    service.endPts = pts;
    service.text = displayedText.join("\n\n");
    this.pushCaption(service);
    service.startPts = pts;
  };
  Cea708Stream.prototype.pushCaption = function(service) {
    if (service.text !== "") {
      this.trigger("data", {
        startPts: service.startPts,
        endPts: service.endPts,
        text: service.text,
        stream: "cc708_" + service.serviceNum
      });
      service.text = "";
      service.startPts = service.endPts;
    }
  };
  Cea708Stream.prototype.displayWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].visible = 1;
      }
    }
    return i;
  };
  Cea708Stream.prototype.hideWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].visible = 0;
      }
    }
    return i;
  };
  Cea708Stream.prototype.toggleWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].visible ^= 1;
      }
    }
    return i;
  };
  Cea708Stream.prototype.clearWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].clearText();
      }
    }
    return i;
  };
  Cea708Stream.prototype.deleteWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].reset();
      }
    }
    return i;
  };
  Cea708Stream.prototype.setPenAttributes = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var penAttr = service.currentWindow.penAttr;
    b2 = packetData[++i];
    penAttr.textTag = (b2 & 240) >> 4;
    penAttr.offset = (b2 & 12) >> 2;
    penAttr.penSize = b2 & 3;
    b2 = packetData[++i];
    penAttr.italics = (b2 & 128) >> 7;
    penAttr.underline = (b2 & 64) >> 6;
    penAttr.edgeType = (b2 & 56) >> 3;
    penAttr.fontStyle = b2 & 7;
    return i;
  };
  Cea708Stream.prototype.setPenColor = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var penColor = service.currentWindow.penColor;
    b2 = packetData[++i];
    penColor.fgOpacity = (b2 & 192) >> 6;
    penColor.fgRed = (b2 & 48) >> 4;
    penColor.fgGreen = (b2 & 12) >> 2;
    penColor.fgBlue = b2 & 3;
    b2 = packetData[++i];
    penColor.bgOpacity = (b2 & 192) >> 6;
    penColor.bgRed = (b2 & 48) >> 4;
    penColor.bgGreen = (b2 & 12) >> 2;
    penColor.bgBlue = b2 & 3;
    b2 = packetData[++i];
    penColor.edgeRed = (b2 & 48) >> 4;
    penColor.edgeGreen = (b2 & 12) >> 2;
    penColor.edgeBlue = b2 & 3;
    return i;
  };
  Cea708Stream.prototype.setPenLocation = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var penLoc = service.currentWindow.penLoc;
    service.currentWindow.pendingNewLine = true;
    b2 = packetData[++i];
    penLoc.row = b2 & 15;
    b2 = packetData[++i];
    penLoc.column = b2 & 63;
    return i;
  };
  Cea708Stream.prototype.reset = function(i, service) {
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    return this.initService(service.serviceNum, i);
  };
  var CHARACTER_TRANSLATION = {
    42: 225,
    // á
    92: 233,
    // é
    94: 237,
    // í
    95: 243,
    // ó
    96: 250,
    // ú
    123: 231,
    // ç
    124: 247,
    // ÷
    125: 209,
    // Ñ
    126: 241,
    // ñ
    127: 9608,
    // █
    304: 174,
    // ®
    305: 176,
    // °
    306: 189,
    // ½
    307: 191,
    // ¿
    308: 8482,
    // ™
    309: 162,
    // ¢
    310: 163,
    // £
    311: 9834,
    // ♪
    312: 224,
    // à
    313: 160,
    //
    314: 232,
    // è
    315: 226,
    // â
    316: 234,
    // ê
    317: 238,
    // î
    318: 244,
    // ô
    319: 251,
    // û
    544: 193,
    // Á
    545: 201,
    // É
    546: 211,
    // Ó
    547: 218,
    // Ú
    548: 220,
    // Ü
    549: 252,
    // ü
    550: 8216,
    // ‘
    551: 161,
    // ¡
    552: 42,
    // *
    553: 39,
    // '
    554: 8212,
    // —
    555: 169,
    // ©
    556: 8480,
    // ℠
    557: 8226,
    // •
    558: 8220,
    // “
    559: 8221,
    // ”
    560: 192,
    // À
    561: 194,
    // Â
    562: 199,
    // Ç
    563: 200,
    // È
    564: 202,
    // Ê
    565: 203,
    // Ë
    566: 235,
    // ë
    567: 206,
    // Î
    568: 207,
    // Ï
    569: 239,
    // ï
    570: 212,
    // Ô
    571: 217,
    // Ù
    572: 249,
    // ù
    573: 219,
    // Û
    574: 171,
    // «
    575: 187,
    // »
    800: 195,
    // Ã
    801: 227,
    // ã
    802: 205,
    // Í
    803: 204,
    // Ì
    804: 236,
    // ì
    805: 210,
    // Ò
    806: 242,
    // ò
    807: 213,
    // Õ
    808: 245,
    // õ
    809: 123,
    // {
    810: 125,
    // }
    811: 92,
    // \
    812: 94,
    // ^
    813: 95,
    // _
    814: 124,
    // |
    815: 126,
    // ~
    816: 196,
    // Ä
    817: 228,
    // ä
    818: 214,
    // Ö
    819: 246,
    // ö
    820: 223,
    // ß
    821: 165,
    // ¥
    822: 164,
    // ¤
    823: 9474,
    // │
    824: 197,
    // Å
    825: 229,
    // å
    826: 216,
    // Ø
    827: 248,
    // ø
    828: 9484,
    // ┌
    829: 9488,
    // ┐
    830: 9492,
    // └
    831: 9496
    // ┘
  };
  var getCharFromCode = function getCharFromCode2(code) {
    if (code === null) {
      return "";
    }
    code = CHARACTER_TRANSLATION[code] || code;
    return String.fromCharCode(code);
  };
  var BOTTOM_ROW = 14;
  var ROWS = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152];
  var createDisplayBuffer = function createDisplayBuffer2() {
    var result = [], i = BOTTOM_ROW + 1;
    while (i--) {
      result.push("");
    }
    return result;
  };
  var Cea608Stream = function Cea608Stream2(field, dataChannel) {
    Cea608Stream2.prototype.init.call(this);
    this.field_ = field || 0;
    this.dataChannel_ = dataChannel || 0;
    this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1);
    this.setConstants();
    this.reset();
    this.push = function(packet) {
      var data, swap, char0, char1, text;
      data = packet.ccData & 32639;
      if (data === this.lastControlCode_) {
        this.lastControlCode_ = null;
        return;
      }
      if ((data & 61440) === 4096) {
        this.lastControlCode_ = data;
      } else if (data !== this.PADDING_) {
        this.lastControlCode_ = null;
      }
      char0 = data >>> 8;
      char1 = data & 255;
      if (data === this.PADDING_) {
        return;
      } else if (data === this.RESUME_CAPTION_LOADING_) {
        this.mode_ = "popOn";
      } else if (data === this.END_OF_CAPTION_) {
        this.mode_ = "popOn";
        this.clearFormatting(packet.pts);
        this.flushDisplayed(packet.pts);
        swap = this.displayed_;
        this.displayed_ = this.nonDisplayed_;
        this.nonDisplayed_ = swap;
        this.startPts_ = packet.pts;
      } else if (data === this.ROLL_UP_2_ROWS_) {
        this.rollUpRows_ = 2;
        this.setRollUp(packet.pts);
      } else if (data === this.ROLL_UP_3_ROWS_) {
        this.rollUpRows_ = 3;
        this.setRollUp(packet.pts);
      } else if (data === this.ROLL_UP_4_ROWS_) {
        this.rollUpRows_ = 4;
        this.setRollUp(packet.pts);
      } else if (data === this.CARRIAGE_RETURN_) {
        this.clearFormatting(packet.pts);
        this.flushDisplayed(packet.pts);
        this.shiftRowsUp_();
        this.startPts_ = packet.pts;
      } else if (data === this.BACKSPACE_) {
        if (this.mode_ === "popOn") {
          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
        } else {
          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
        }
      } else if (data === this.ERASE_DISPLAYED_MEMORY_) {
        this.flushDisplayed(packet.pts);
        this.displayed_ = createDisplayBuffer();
      } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {
        this.nonDisplayed_ = createDisplayBuffer();
      } else if (data === this.RESUME_DIRECT_CAPTIONING_) {
        if (this.mode_ !== "paintOn") {
          this.flushDisplayed(packet.pts);
          this.displayed_ = createDisplayBuffer();
        }
        this.mode_ = "paintOn";
        this.startPts_ = packet.pts;
      } else if (this.isSpecialCharacter(char0, char1)) {
        char0 = (char0 & 3) << 8;
        text = getCharFromCode(char0 | char1);
        this[this.mode_](packet.pts, text);
        this.column_++;
      } else if (this.isExtCharacter(char0, char1)) {
        if (this.mode_ === "popOn") {
          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
        } else {
          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
        }
        char0 = (char0 & 3) << 8;
        text = getCharFromCode(char0 | char1);
        this[this.mode_](packet.pts, text);
        this.column_++;
      } else if (this.isMidRowCode(char0, char1)) {
        this.clearFormatting(packet.pts);
        this[this.mode_](packet.pts, " ");
        this.column_++;
        if ((char1 & 14) === 14) {
          this.addFormatting(packet.pts, ["i"]);
        }
        if ((char1 & 1) === 1) {
          this.addFormatting(packet.pts, ["u"]);
        }
      } else if (this.isOffsetControlCode(char0, char1)) {
        this.column_ += char1 & 3;
      } else if (this.isPAC(char0, char1)) {
        var row = ROWS.indexOf(data & 7968);
        if (this.mode_ === "rollUp") {
          if (row - this.rollUpRows_ + 1 < 0) {
            row = this.rollUpRows_ - 1;
          }
          this.setRollUp(packet.pts, row);
        }
        if (row !== this.row_) {
          this.clearFormatting(packet.pts);
          this.row_ = row;
        }
        if (char1 & 1 && this.formatting_.indexOf("u") === -1) {
          this.addFormatting(packet.pts, ["u"]);
        }
        if ((data & 16) === 16) {
          this.column_ = ((data & 14) >> 1) * 4;
        }
        if (this.isColorPAC(char1)) {
          if ((char1 & 14) === 14) {
            this.addFormatting(packet.pts, ["i"]);
          }
        }
      } else if (this.isNormalChar(char0)) {
        if (char1 === 0) {
          char1 = null;
        }
        text = getCharFromCode(char0);
        text += getCharFromCode(char1);
        this[this.mode_](packet.pts, text);
        this.column_ += text.length;
      }
    };
  };
  Cea608Stream.prototype = new stream();
  Cea608Stream.prototype.flushDisplayed = function(pts) {
    var content = this.displayed_.map(function(row, index) {
      try {
        return row.trim();
      } catch (e) {
        this.trigger("log", {
          level: "warn",
          message: "Skipping a malformed 608 caption at index " + index + "."
        });
        return "";
      }
    }, this).join("\n").replace(/^\n+|\n+$/g, "");
    if (content.length) {
      this.trigger("data", {
        startPts: this.startPts_,
        endPts: pts,
        text: content,
        stream: this.name_
      });
    }
  };
  Cea608Stream.prototype.reset = function() {
    this.mode_ = "popOn";
    this.topRow_ = 0;
    this.startPts_ = 0;
    this.displayed_ = createDisplayBuffer();
    this.nonDisplayed_ = createDisplayBuffer();
    this.lastControlCode_ = null;
    this.column_ = 0;
    this.row_ = BOTTOM_ROW;
    this.rollUpRows_ = 2;
    this.formatting_ = [];
  };
  Cea608Stream.prototype.setConstants = function() {
    if (this.dataChannel_ === 0) {
      this.BASE_ = 16;
      this.EXT_ = 17;
      this.CONTROL_ = (20 | this.field_) << 8;
      this.OFFSET_ = 23;
    } else if (this.dataChannel_ === 1) {
      this.BASE_ = 24;
      this.EXT_ = 25;
      this.CONTROL_ = (28 | this.field_) << 8;
      this.OFFSET_ = 31;
    }
    this.PADDING_ = 0;
    this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32;
    this.END_OF_CAPTION_ = this.CONTROL_ | 47;
    this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37;
    this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38;
    this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39;
    this.CARRIAGE_RETURN_ = this.CONTROL_ | 45;
    this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41;
    this.BACKSPACE_ = this.CONTROL_ | 33;
    this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44;
    this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
  };
  Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
    return char0 === this.EXT_ && char1 >= 48 && char1 <= 63;
  };
  Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
    return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 32 && char1 <= 63;
  };
  Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
    return char0 === this.EXT_ && char1 >= 32 && char1 <= 47;
  };
  Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
    return char0 === this.OFFSET_ && char1 >= 33 && char1 <= 35;
  };
  Cea608Stream.prototype.isPAC = function(char0, char1) {
    return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 64 && char1 <= 127;
  };
  Cea608Stream.prototype.isColorPAC = function(char1) {
    return char1 >= 64 && char1 <= 79 || char1 >= 96 && char1 <= 127;
  };
  Cea608Stream.prototype.isNormalChar = function(_char2) {
    return _char2 >= 32 && _char2 <= 127;
  };
  Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
    if (this.mode_ !== "rollUp") {
      this.row_ = BOTTOM_ROW;
      this.mode_ = "rollUp";
      this.flushDisplayed(pts);
      this.nonDisplayed_ = createDisplayBuffer();
      this.displayed_ = createDisplayBuffer();
    }
    if (newBaseRow !== void 0 && newBaseRow !== this.row_) {
      for (var i = 0; i < this.rollUpRows_; i++) {
        this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];
        this.displayed_[this.row_ - i] = "";
      }
    }
    if (newBaseRow === void 0) {
      newBaseRow = this.row_;
    }
    this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
  };
  Cea608Stream.prototype.addFormatting = function(pts, format) {
    this.formatting_ = this.formatting_.concat(format);
    var text = format.reduce(function(text2, format2) {
      return text2 + "<" + format2 + ">";
    }, "");
    this[this.mode_](pts, text);
  };
  Cea608Stream.prototype.clearFormatting = function(pts) {
    if (!this.formatting_.length) {
      return;
    }
    var text = this.formatting_.reverse().reduce(function(text2, format) {
      return text2 + "</" + format + ">";
    }, "");
    this.formatting_ = [];
    this[this.mode_](pts, text);
  };
  Cea608Stream.prototype.popOn = function(pts, text) {
    var baseRow = this.nonDisplayed_[this.row_];
    baseRow += text;
    this.nonDisplayed_[this.row_] = baseRow;
  };
  Cea608Stream.prototype.rollUp = function(pts, text) {
    var baseRow = this.displayed_[this.row_];
    baseRow += text;
    this.displayed_[this.row_] = baseRow;
  };
  Cea608Stream.prototype.shiftRowsUp_ = function() {
    var i;
    for (i = 0; i < this.topRow_; i++) {
      this.displayed_[i] = "";
    }
    for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {
      this.displayed_[i] = "";
    }
    for (i = this.topRow_; i < this.row_; i++) {
      this.displayed_[i] = this.displayed_[i + 1];
    }
    this.displayed_[this.row_] = "";
  };
  Cea608Stream.prototype.paintOn = function(pts, text) {
    var baseRow = this.displayed_[this.row_];
    baseRow += text;
    this.displayed_[this.row_] = baseRow;
  };
  var captionStream = {
    CaptionStream: CaptionStream$1,
    Cea608Stream,
    Cea708Stream
  };
  var streamTypes = {
    H264_STREAM_TYPE: 27,
    ADTS_STREAM_TYPE: 15,
    METADATA_STREAM_TYPE: 21
  };
  var MAX_TS = 8589934592;
  var RO_THRESH = 4294967296;
  var TYPE_SHARED = "shared";
  var handleRollover$1 = function handleRollover2(value, reference) {
    var direction = 1;
    if (value > reference) {
      direction = -1;
    }
    while (Math.abs(reference - value) > RO_THRESH) {
      value += direction * MAX_TS;
    }
    return value;
  };
  var TimestampRolloverStream$1 = function TimestampRolloverStream2(type3) {
    var lastDTS, referenceDTS;
    TimestampRolloverStream2.prototype.init.call(this);
    this.type_ = type3 || TYPE_SHARED;
    this.push = function(data) {
      if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {
        return;
      }
      if (referenceDTS === void 0) {
        referenceDTS = data.dts;
      }
      data.dts = handleRollover$1(data.dts, referenceDTS);
      data.pts = handleRollover$1(data.pts, referenceDTS);
      lastDTS = data.dts;
      this.trigger("data", data);
    };
    this.flush = function() {
      referenceDTS = lastDTS;
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
    this.discontinuity = function() {
      referenceDTS = void 0;
      lastDTS = void 0;
    };
    this.reset = function() {
      this.discontinuity();
      this.trigger("reset");
    };
  };
  TimestampRolloverStream$1.prototype = new stream();
  var timestampRolloverStream = {
    TimestampRolloverStream: TimestampRolloverStream$1,
    handleRollover: handleRollover$1
  };
  var percentEncode$1 = function percentEncode2(bytes, start2, end) {
    var i, result = "";
    for (i = start2; i < end; i++) {
      result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
    }
    return result;
  }, parseUtf8 = function parseUtf82(bytes, start2, end) {
    return decodeURIComponent(percentEncode$1(bytes, start2, end));
  }, parseIso88591$1 = function parseIso885912(bytes, start2, end) {
    return unescape(percentEncode$1(bytes, start2, end));
  }, parseSyncSafeInteger$1 = function parseSyncSafeInteger2(data) {
    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
  }, tagParsers = {
    TXXX: function TXXX(tag) {
      var i;
      if (tag.data[0] !== 3) {
        return;
      }
      for (i = 1; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.description = parseUtf8(tag.data, 1, i);
          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\0*$/, "");
          break;
        }
      }
      tag.data = tag.value;
    },
    WXXX: function WXXX(tag) {
      var i;
      if (tag.data[0] !== 3) {
        return;
      }
      for (i = 1; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.description = parseUtf8(tag.data, 1, i);
          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);
          break;
        }
      }
    },
    PRIV: function PRIV(tag) {
      var i;
      for (i = 0; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.owner = parseIso88591$1(tag.data, 0, i);
          break;
        }
      }
      tag.privateData = tag.data.subarray(i + 1);
      tag.data = tag.privateData;
    }
  }, _MetadataStream;
  _MetadataStream = function MetadataStream(options) {
    var settings = {
      // the bytes of the program-level descriptor field in MP2T
      // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
      // program element descriptors"
      descriptor: options && options.descriptor
    }, tagSize = 0, buffer = [], bufferSize = 0, i;
    _MetadataStream.prototype.init.call(this);
    this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);
    if (settings.descriptor) {
      for (i = 0; i < settings.descriptor.length; i++) {
        this.dispatchType += ("00" + settings.descriptor[i].toString(16)).slice(-2);
      }
    }
    this.push = function(chunk) {
      var tag, frameStart, frameSize, frame, i2, frameHeader;
      if (chunk.type !== "timed-metadata") {
        return;
      }
      if (chunk.dataAlignmentIndicator) {
        bufferSize = 0;
        buffer.length = 0;
      }
      if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== "I".charCodeAt(0) || chunk.data[1] !== "D".charCodeAt(0) || chunk.data[2] !== "3".charCodeAt(0))) {
        this.trigger("log", {
          level: "warn",
          message: "Skipping unrecognized metadata packet"
        });
        return;
      }
      buffer.push(chunk);
      bufferSize += chunk.data.byteLength;
      if (buffer.length === 1) {
        tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10));
        tagSize += 10;
      }
      if (bufferSize < tagSize) {
        return;
      }
      tag = {
        data: new Uint8Array(tagSize),
        frames: [],
        pts: buffer[0].pts,
        dts: buffer[0].dts
      };
      for (i2 = 0; i2 < tagSize; ) {
        tag.data.set(buffer[0].data.subarray(0, tagSize - i2), i2);
        i2 += buffer[0].data.byteLength;
        bufferSize -= buffer[0].data.byteLength;
        buffer.shift();
      }
      frameStart = 10;
      if (tag.data[5] & 64) {
        frameStart += 4;
        frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14));
        tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));
      }
      do {
        frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));
        if (frameSize < 1) {
          this.trigger("log", {
            level: "warn",
            message: "Malformed ID3 frame encountered. Skipping metadata parsing."
          });
          return;
        }
        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
        frame = {
          id: frameHeader,
          data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
        };
        frame.key = frame.id;
        if (tagParsers[frame.id]) {
          tagParsers[frame.id](frame);
          if (frame.owner === "com.apple.streaming.transportStreamTimestamp") {
            var d3 = frame.data, size = (d3[3] & 1) << 30 | d3[4] << 22 | d3[5] << 14 | d3[6] << 6 | d3[7] >>> 2;
            size *= 4;
            size += d3[7] & 3;
            frame.timeStamp = size;
            if (tag.pts === void 0 && tag.dts === void 0) {
              tag.pts = frame.timeStamp;
              tag.dts = frame.timeStamp;
            }
            this.trigger("timestamp", frame);
          }
        }
        tag.frames.push(frame);
        frameStart += 10;
        frameStart += frameSize;
      } while (frameStart < tagSize);
      this.trigger("data", tag);
    };
  };
  _MetadataStream.prototype = new stream();
  var metadataStream = _MetadataStream;
  var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
  var _TransportPacketStream, _TransportParseStream, _ElementaryStream;
  var MP2T_PACKET_LENGTH$1 = 188, SYNC_BYTE$1 = 71;
  _TransportPacketStream = function TransportPacketStream() {
    var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1), bytesInBuffer = 0;
    _TransportPacketStream.prototype.init.call(this);
    this.push = function(bytes) {
      var startIndex = 0, endIndex = MP2T_PACKET_LENGTH$1, everything;
      if (bytesInBuffer) {
        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
        everything.set(buffer.subarray(0, bytesInBuffer));
        everything.set(bytes, bytesInBuffer);
        bytesInBuffer = 0;
      } else {
        everything = bytes;
      }
      while (endIndex < everything.byteLength) {
        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
          this.trigger("data", everything.subarray(startIndex, endIndex));
          startIndex += MP2T_PACKET_LENGTH$1;
          endIndex += MP2T_PACKET_LENGTH$1;
          continue;
        }
        startIndex++;
        endIndex++;
      }
      if (startIndex < everything.byteLength) {
        buffer.set(everything.subarray(startIndex), 0);
        bytesInBuffer = everything.byteLength - startIndex;
      }
    };
    this.flush = function() {
      if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
        this.trigger("data", buffer);
        bytesInBuffer = 0;
      }
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
    this.reset = function() {
      bytesInBuffer = 0;
      this.trigger("reset");
    };
  };
  _TransportPacketStream.prototype = new stream();
  _TransportParseStream = function TransportParseStream() {
    var parsePsi, parsePat2, parsePmt2, self2;
    _TransportParseStream.prototype.init.call(this);
    self2 = this;
    this.packetsWaitingForPmt = [];
    this.programMapTable = void 0;
    parsePsi = function parsePsi2(payload, psi) {
      var offset = 0;
      if (psi.payloadUnitStartIndicator) {
        offset += payload[offset] + 1;
      }
      if (psi.type === "pat") {
        parsePat2(payload.subarray(offset), psi);
      } else {
        parsePmt2(payload.subarray(offset), psi);
      }
    };
    parsePat2 = function parsePat3(payload, pat) {
      pat.section_number = payload[7];
      pat.last_section_number = payload[8];
      self2.pmtPid = (payload[10] & 31) << 8 | payload[11];
      pat.pmtPid = self2.pmtPid;
    };
    parsePmt2 = function parsePmt3(payload, pmt) {
      var sectionLength, tableEnd, programInfoLength, offset;
      if (!(payload[5] & 1)) {
        return;
      }
      self2.programMapTable = {
        video: null,
        audio: null,
        "timed-metadata": {}
      };
      sectionLength = (payload[1] & 15) << 8 | payload[2];
      tableEnd = 3 + sectionLength - 4;
      programInfoLength = (payload[10] & 15) << 8 | payload[11];
      offset = 12 + programInfoLength;
      while (offset < tableEnd) {
        var streamType = payload[offset];
        var pid = (payload[offset + 1] & 31) << 8 | payload[offset + 2];
        if (streamType === streamTypes.H264_STREAM_TYPE && self2.programMapTable.video === null) {
          self2.programMapTable.video = pid;
        } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self2.programMapTable.audio === null) {
          self2.programMapTable.audio = pid;
        } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {
          self2.programMapTable["timed-metadata"][pid] = streamType;
        }
        offset += ((payload[offset + 3] & 15) << 8 | payload[offset + 4]) + 5;
      }
      pmt.programMapTable = self2.programMapTable;
    };
    this.push = function(packet) {
      var result = {}, offset = 4;
      result.payloadUnitStartIndicator = !!(packet[1] & 64);
      result.pid = packet[1] & 31;
      result.pid <<= 8;
      result.pid |= packet[2];
      if ((packet[3] & 48) >>> 4 > 1) {
        offset += packet[offset] + 1;
      }
      if (result.pid === 0) {
        result.type = "pat";
        parsePsi(packet.subarray(offset), result);
        this.trigger("data", result);
      } else if (result.pid === this.pmtPid) {
        result.type = "pmt";
        parsePsi(packet.subarray(offset), result);
        this.trigger("data", result);
        while (this.packetsWaitingForPmt.length) {
          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
        }
      } else if (this.programMapTable === void 0) {
        this.packetsWaitingForPmt.push([packet, offset, result]);
      } else {
        this.processPes_(packet, offset, result);
      }
    };
    this.processPes_ = function(packet, offset, result) {
      if (result.pid === this.programMapTable.video) {
        result.streamType = streamTypes.H264_STREAM_TYPE;
      } else if (result.pid === this.programMapTable.audio) {
        result.streamType = streamTypes.ADTS_STREAM_TYPE;
      } else {
        result.streamType = this.programMapTable["timed-metadata"][result.pid];
      }
      result.type = "pes";
      result.data = packet.subarray(offset);
      this.trigger("data", result);
    };
  };
  _TransportParseStream.prototype = new stream();
  _TransportParseStream.STREAM_TYPES = {
    h264: 27,
    adts: 15
  };
  _ElementaryStream = function ElementaryStream() {
    var self2 = this, segmentHadPmt = false, video = {
      data: [],
      size: 0
    }, audio = {
      data: [],
      size: 0
    }, timedMetadata = {
      data: [],
      size: 0
    }, programMapTable, parsePes = function parsePes2(payload, pes) {
      var ptsDtsFlags;
      var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
      pes.data = new Uint8Array();
      if (startPrefix !== 1) {
        return;
      }
      pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
      pes.dataAlignmentIndicator = (payload[6] & 4) !== 0;
      ptsDtsFlags = payload[7];
      if (ptsDtsFlags & 192) {
        pes.pts = (payload[9] & 14) << 27 | (payload[10] & 255) << 20 | (payload[11] & 254) << 12 | (payload[12] & 255) << 5 | (payload[13] & 254) >>> 3;
        pes.pts *= 4;
        pes.pts += (payload[13] & 6) >>> 1;
        pes.dts = pes.pts;
        if (ptsDtsFlags & 64) {
          pes.dts = (payload[14] & 14) << 27 | (payload[15] & 255) << 20 | (payload[16] & 254) << 12 | (payload[17] & 255) << 5 | (payload[18] & 254) >>> 3;
          pes.dts *= 4;
          pes.dts += (payload[18] & 6) >>> 1;
        }
      }
      pes.data = payload.subarray(9 + payload[8]);
    }, flushStream = function flushStream2(stream2, type3, forceFlush) {
      var packetData = new Uint8Array(stream2.size), event = {
        type: type3
      }, i = 0, offset = 0, packetFlushable = false, fragment;
      if (!stream2.data.length || stream2.size < 9) {
        return;
      }
      event.trackId = stream2.data[0].pid;
      for (i = 0; i < stream2.data.length; i++) {
        fragment = stream2.data[i];
        packetData.set(fragment.data, offset);
        offset += fragment.data.byteLength;
      }
      parsePes(packetData, event);
      packetFlushable = type3 === "video" || event.packetLength <= stream2.size;
      if (forceFlush || packetFlushable) {
        stream2.size = 0;
        stream2.data.length = 0;
      }
      if (packetFlushable) {
        self2.trigger("data", event);
      }
    };
    _ElementaryStream.prototype.init.call(this);
    this.push = function(data) {
      ({
        pat: function pat() {
        },
        pes: function pes() {
          var stream2, streamType;
          switch (data.streamType) {
            case streamTypes.H264_STREAM_TYPE:
              stream2 = video;
              streamType = "video";
              break;
            case streamTypes.ADTS_STREAM_TYPE:
              stream2 = audio;
              streamType = "audio";
              break;
            case streamTypes.METADATA_STREAM_TYPE:
              stream2 = timedMetadata;
              streamType = "timed-metadata";
              break;
            default:
              return;
          }
          if (data.payloadUnitStartIndicator) {
            flushStream(stream2, streamType, true);
          }
          stream2.data.push(data);
          stream2.size += data.data.byteLength;
        },
        pmt: function pmt() {
          var event = {
            type: "metadata",
            tracks: []
          };
          programMapTable = data.programMapTable;
          if (programMapTable.video !== null) {
            event.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.video,
              codec: "avc",
              type: "video"
            });
          }
          if (programMapTable.audio !== null) {
            event.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.audio,
              codec: "adts",
              type: "audio"
            });
          }
          segmentHadPmt = true;
          self2.trigger("data", event);
        }
      })[data.type]();
    };
    this.reset = function() {
      video.size = 0;
      video.data.length = 0;
      audio.size = 0;
      audio.data.length = 0;
      this.trigger("reset");
    };
    this.flushStreams_ = function() {
      flushStream(video, "video");
      flushStream(audio, "audio");
      flushStream(timedMetadata, "timed-metadata");
    };
    this.flush = function() {
      if (!segmentHadPmt && programMapTable) {
        var pmt = {
          type: "metadata",
          tracks: []
        };
        if (programMapTable.video !== null) {
          pmt.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +programMapTable.video,
            codec: "avc",
            type: "video"
          });
        }
        if (programMapTable.audio !== null) {
          pmt.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +programMapTable.audio,
            codec: "adts",
            type: "audio"
          });
        }
        self2.trigger("data", pmt);
      }
      segmentHadPmt = false;
      this.flushStreams_();
      this.trigger("done");
    };
  };
  _ElementaryStream.prototype = new stream();
  var m2ts = {
    PAT_PID: 0,
    MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
    TransportPacketStream: _TransportPacketStream,
    TransportParseStream: _TransportParseStream,
    ElementaryStream: _ElementaryStream,
    TimestampRolloverStream,
    CaptionStream: captionStream.CaptionStream,
    Cea608Stream: captionStream.Cea608Stream,
    Cea708Stream: captionStream.Cea708Stream,
    MetadataStream: metadataStream
  };
  for (var type2 in streamTypes) {
    if (streamTypes.hasOwnProperty(type2)) {
      m2ts[type2] = streamTypes[type2];
    }
  }
  var m2ts_1 = m2ts;
  var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS;
  var _AdtsStream;
  var ADTS_SAMPLING_FREQUENCIES$1 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  _AdtsStream = function AdtsStream(handlePartialSegments) {
    var buffer, frameNum = 0;
    _AdtsStream.prototype.init.call(this);
    this.skipWarn_ = function(start2, end) {
      this.trigger("log", {
        level: "warn",
        message: "adts skiping bytes " + start2 + " to " + end + " in frame " + frameNum + " outside syncword"
      });
    };
    this.push = function(packet) {
      var i = 0, frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration;
      if (!handlePartialSegments) {
        frameNum = 0;
      }
      if (packet.type !== "audio") {
        return;
      }
      if (buffer && buffer.length) {
        oldBuffer = buffer;
        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
        buffer.set(oldBuffer);
        buffer.set(packet.data, oldBuffer.byteLength);
      } else {
        buffer = packet.data;
      }
      var skip;
      while (i + 7 < buffer.length) {
        if (buffer[i] !== 255 || (buffer[i + 1] & 246) !== 240) {
          if (typeof skip !== "number") {
            skip = i;
          }
          i++;
          continue;
        }
        if (typeof skip === "number") {
          this.skipWarn_(skip, i);
          skip = null;
        }
        protectionSkipBytes = (~buffer[i + 1] & 1) * 2;
        frameLength = (buffer[i + 3] & 3) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 224) >> 5;
        sampleCount = ((buffer[i + 6] & 3) + 1) * 1024;
        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2];
        if (buffer.byteLength - i < frameLength) {
          break;
        }
        this.trigger("data", {
          pts: packet.pts + frameNum * adtsFrameDuration,
          dts: packet.dts + frameNum * adtsFrameDuration,
          sampleCount,
          audioobjecttype: (buffer[i + 2] >>> 6 & 3) + 1,
          channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 192) >>> 6,
          samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2],
          samplingfrequencyindex: (buffer[i + 2] & 60) >>> 2,
          // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
          samplesize: 16,
          // data is the frame without it's header
          data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
        });
        frameNum++;
        i += frameLength;
      }
      if (typeof skip === "number") {
        this.skipWarn_(skip, i);
        skip = null;
      }
      buffer = buffer.subarray(i);
    };
    this.flush = function() {
      frameNum = 0;
      this.trigger("done");
    };
    this.reset = function() {
      buffer = void 0;
      this.trigger("reset");
    };
    this.endTimeline = function() {
      buffer = void 0;
      this.trigger("endedtimeline");
    };
  };
  _AdtsStream.prototype = new stream();
  var adts = _AdtsStream;
  var ExpGolomb;
  ExpGolomb = function ExpGolomb2(workingData) {
    var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
    this.length = function() {
      return 8 * workingBytesAvailable;
    };
    this.bitsAvailable = function() {
      return 8 * workingBytesAvailable + workingBitsAvailable;
    };
    this.loadWord = function() {
      var position = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
      if (availableBytes === 0) {
        throw new Error("no bytes available");
      }
      workingBytes.set(workingData.subarray(position, position + availableBytes));
      workingWord = new DataView(workingBytes.buffer).getUint32(0);
      workingBitsAvailable = availableBytes * 8;
      workingBytesAvailable -= availableBytes;
    };
    this.skipBits = function(count) {
      var skipBytes;
      if (workingBitsAvailable > count) {
        workingWord <<= count;
        workingBitsAvailable -= count;
      } else {
        count -= workingBitsAvailable;
        skipBytes = Math.floor(count / 8);
        count -= skipBytes * 8;
        workingBytesAvailable -= skipBytes;
        this.loadWord();
        workingWord <<= count;
        workingBitsAvailable -= count;
      }
    };
    this.readBits = function(size) {
      var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
      workingBitsAvailable -= bits;
      if (workingBitsAvailable > 0) {
        workingWord <<= bits;
      } else if (workingBytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0) {
        return valu << bits | this.readBits(bits);
      }
      return valu;
    };
    this.skipLeadingZeros = function() {
      var leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {
        if ((workingWord & 2147483648 >>> leadingZeroCount) !== 0) {
          workingWord <<= leadingZeroCount;
          workingBitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this.loadWord();
      return leadingZeroCount + this.skipLeadingZeros();
    };
    this.skipUnsignedExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    };
    this.skipExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    };
    this.readUnsignedExpGolomb = function() {
      var clz = this.skipLeadingZeros();
      return this.readBits(clz + 1) - 1;
    };
    this.readExpGolomb = function() {
      var valu = this.readUnsignedExpGolomb();
      if (1 & valu) {
        return 1 + valu >>> 1;
      }
      return -1 * (valu >>> 1);
    };
    this.readBoolean = function() {
      return this.readBits(1) === 1;
    };
    this.readUnsignedByte = function() {
      return this.readBits(8);
    };
    this.loadWord();
  };
  var expGolomb = ExpGolomb;
  var _H264Stream, _NalByteStream;
  var PROFILES_WITH_OPTIONAL_SPS_DATA;
  _NalByteStream = function NalByteStream() {
    var syncPoint = 0, i, buffer;
    _NalByteStream.prototype.init.call(this);
    this.push = function(data) {
      var swapBuffer;
      if (!buffer) {
        buffer = data.data;
      } else {
        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
        swapBuffer.set(buffer);
        swapBuffer.set(data.data, buffer.byteLength);
        buffer = swapBuffer;
      }
      var len = buffer.byteLength;
      for (; syncPoint < len - 3; syncPoint++) {
        if (buffer[syncPoint + 2] === 1) {
          i = syncPoint + 5;
          break;
        }
      }
      while (i < len) {
        switch (buffer[i]) {
          case 0:
            if (buffer[i - 1] !== 0) {
              i += 2;
              break;
            } else if (buffer[i - 2] !== 0) {
              i++;
              break;
            }
            if (syncPoint + 3 !== i - 2) {
              this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
            }
            do {
              i++;
            } while (buffer[i] !== 1 && i < len);
            syncPoint = i - 2;
            i += 3;
            break;
          case 1:
            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
              i += 3;
              break;
            }
            this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
            syncPoint = i - 2;
            i += 3;
            break;
          default:
            i += 3;
            break;
        }
      }
      buffer = buffer.subarray(syncPoint);
      i -= syncPoint;
      syncPoint = 0;
    };
    this.reset = function() {
      buffer = null;
      syncPoint = 0;
      this.trigger("reset");
    };
    this.flush = function() {
      if (buffer && buffer.byteLength > 3) {
        this.trigger("data", buffer.subarray(syncPoint + 3));
      }
      buffer = null;
      syncPoint = 0;
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
  };
  _NalByteStream.prototype = new stream();
  PROFILES_WITH_OPTIONAL_SPS_DATA = {
    100: true,
    110: true,
    122: true,
    244: true,
    44: true,
    83: true,
    86: true,
    118: true,
    128: true,
    // TODO: the three profiles below don't
    // appear to have sps data in the specificiation anymore?
    138: true,
    139: true,
    134: true
  };
  _H264Stream = function H264Stream2() {
    var nalByteStream = new _NalByteStream(), self2, trackId, currentPts, currentDts, discardEmulationPreventionBytes4, readSequenceParameterSet, skipScalingList;
    _H264Stream.prototype.init.call(this);
    self2 = this;
    this.push = function(packet) {
      if (packet.type !== "video") {
        return;
      }
      trackId = packet.trackId;
      currentPts = packet.pts;
      currentDts = packet.dts;
      nalByteStream.push(packet);
    };
    nalByteStream.on("data", function(data) {
      var event = {
        trackId,
        pts: currentPts,
        dts: currentDts,
        data,
        nalUnitTypeCode: data[0] & 31
      };
      switch (event.nalUnitTypeCode) {
        case 5:
          event.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
          break;
        case 6:
          event.nalUnitType = "sei_rbsp";
          event.escapedRBSP = discardEmulationPreventionBytes4(data.subarray(1));
          break;
        case 7:
          event.nalUnitType = "seq_parameter_set_rbsp";
          event.escapedRBSP = discardEmulationPreventionBytes4(data.subarray(1));
          event.config = readSequenceParameterSet(event.escapedRBSP);
          break;
        case 8:
          event.nalUnitType = "pic_parameter_set_rbsp";
          break;
        case 9:
          event.nalUnitType = "access_unit_delimiter_rbsp";
          break;
      }
      self2.trigger("data", event);
    });
    nalByteStream.on("done", function() {
      self2.trigger("done");
    });
    nalByteStream.on("partialdone", function() {
      self2.trigger("partialdone");
    });
    nalByteStream.on("reset", function() {
      self2.trigger("reset");
    });
    nalByteStream.on("endedtimeline", function() {
      self2.trigger("endedtimeline");
    });
    this.flush = function() {
      nalByteStream.flush();
    };
    this.partialFlush = function() {
      nalByteStream.partialFlush();
    };
    this.reset = function() {
      nalByteStream.reset();
    };
    this.endTimeline = function() {
      nalByteStream.endTimeline();
    };
    skipScalingList = function skipScalingList2(count, expGolombDecoder) {
      var lastScale = 8, nextScale = 8, j2, deltaScale;
      for (j2 = 0; j2 < count; j2++) {
        if (nextScale !== 0) {
          deltaScale = expGolombDecoder.readExpGolomb();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    };
    discardEmulationPreventionBytes4 = function discardEmulationPreventionBytes5(data) {
      var length = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (emulationPreventionBytesPositions.length === 0) {
        return data;
      }
      newLength = length - emulationPreventionBytesPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    };
    readSequenceParameterSet = function readSequenceParameterSet2(data) {
      var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, sarRatio = [1, 1], aspectRatioIdc, i;
      expGolombDecoder = new expGolomb(data);
      profileIdc = expGolombDecoder.readUnsignedByte();
      profileCompatibility = expGolombDecoder.readUnsignedByte();
      levelIdc = expGolombDecoder.readUnsignedByte();
      expGolombDecoder.skipUnsignedExpGolomb();
      if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
        if (chromaFormatIdc === 3) {
          expGolombDecoder.skipBits(1);
        }
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipBits(1);
        if (expGolombDecoder.readBoolean()) {
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (expGolombDecoder.readBoolean()) {
              if (i < 6) {
                skipScalingList(16, expGolombDecoder);
              } else {
                skipScalingList(64, expGolombDecoder);
              }
            }
          }
        }
      }
      expGolombDecoder.skipUnsignedExpGolomb();
      picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
      if (picOrderCntType === 0) {
        expGolombDecoder.readUnsignedExpGolomb();
      } else if (picOrderCntType === 1) {
        expGolombDecoder.skipBits(1);
        expGolombDecoder.skipExpGolomb();
        expGolombDecoder.skipExpGolomb();
        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          expGolombDecoder.skipExpGolomb();
        }
      }
      expGolombDecoder.skipUnsignedExpGolomb();
      expGolombDecoder.skipBits(1);
      picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
      picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
      frameMbsOnlyFlag = expGolombDecoder.readBits(1);
      if (frameMbsOnlyFlag === 0) {
        expGolombDecoder.skipBits(1);
      }
      expGolombDecoder.skipBits(1);
      if (expGolombDecoder.readBoolean()) {
        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
      }
      if (expGolombDecoder.readBoolean()) {
        if (expGolombDecoder.readBoolean()) {
          aspectRatioIdc = expGolombDecoder.readUnsignedByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];
              break;
            case 2:
              sarRatio = [12, 11];
              break;
            case 3:
              sarRatio = [10, 11];
              break;
            case 4:
              sarRatio = [16, 11];
              break;
            case 5:
              sarRatio = [40, 33];
              break;
            case 6:
              sarRatio = [24, 11];
              break;
            case 7:
              sarRatio = [20, 11];
              break;
            case 8:
              sarRatio = [32, 11];
              break;
            case 9:
              sarRatio = [80, 33];
              break;
            case 10:
              sarRatio = [18, 11];
              break;
            case 11:
              sarRatio = [15, 11];
              break;
            case 12:
              sarRatio = [64, 33];
              break;
            case 13:
              sarRatio = [160, 99];
              break;
            case 14:
              sarRatio = [4, 3];
              break;
            case 15:
              sarRatio = [3, 2];
              break;
            case 16:
              sarRatio = [2, 1];
              break;
            case 255: {
              sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];
              break;
            }
          }
          if (sarRatio) {
            sarRatio[0] / sarRatio[1];
          }
        }
      }
      return {
        profileIdc,
        levelIdc,
        profileCompatibility,
        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
        // sar is sample aspect ratio
        sarRatio
      };
    };
  };
  _H264Stream.prototype = new stream();
  var h2642 = {
    H264Stream: _H264Stream,
    NalByteStream: _NalByteStream
  };
  var ADTS_SAMPLING_FREQUENCIES = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  var parseId3TagSize = function parseId3TagSize2(header, byteIndex) {
    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9], flags = header[byteIndex + 5], footerPresent = (flags & 16) >> 4;
    returnSize = returnSize >= 0 ? returnSize : 0;
    if (footerPresent) {
      return returnSize + 20;
    }
    return returnSize + 10;
  };
  var getId3Offset3 = function getId3Offset4(data, offset) {
    if (data.length - offset < 10 || data[offset] !== "I".charCodeAt(0) || data[offset + 1] !== "D".charCodeAt(0) || data[offset + 2] !== "3".charCodeAt(0)) {
      return offset;
    }
    offset += parseId3TagSize(data, offset);
    return getId3Offset4(data, offset);
  };
  var isLikelyAacData$1 = function isLikelyAacData2(data) {
    var offset = getId3Offset3(data, 0);
    return data.length >= offset + 2 && (data[offset] & 255) === 255 && (data[offset + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
    // is not mp3 data but aac data.
    (data[offset + 1] & 22) === 16;
  };
  var parseSyncSafeInteger = function parseSyncSafeInteger2(data) {
    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
  };
  var percentEncode = function percentEncode2(bytes, start2, end) {
    var i, result = "";
    for (i = start2; i < end; i++) {
      result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
    }
    return result;
  };
  var parseIso88591 = function parseIso885912(bytes, start2, end) {
    return unescape(percentEncode(bytes, start2, end));
  };
  var parseAdtsSize = function parseAdtsSize2(header, byteIndex) {
    var lowThree = (header[byteIndex + 5] & 224) >> 5, middle = header[byteIndex + 4] << 3, highTwo = header[byteIndex + 3] & 3 << 11;
    return highTwo | middle | lowThree;
  };
  var parseType$2 = function parseType2(header, byteIndex) {
    if (header[byteIndex] === "I".charCodeAt(0) && header[byteIndex + 1] === "D".charCodeAt(0) && header[byteIndex + 2] === "3".charCodeAt(0)) {
      return "timed-metadata";
    } else if (header[byteIndex] & true && (header[byteIndex + 1] & 240) === 240) {
      return "audio";
    }
    return null;
  };
  var parseSampleRate = function parseSampleRate2(packet) {
    var i = 0;
    while (i + 5 < packet.length) {
      if (packet[i] !== 255 || (packet[i + 1] & 246) !== 240) {
        i++;
        continue;
      }
      return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 60) >>> 2];
    }
    return null;
  };
  var parseAacTimestamp = function parseAacTimestamp2(packet) {
    var frameStart, frameSize, frame, frameHeader;
    frameStart = 10;
    if (packet[5] & 64) {
      frameStart += 4;
      frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
    }
    do {
      frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
      if (frameSize < 1) {
        return null;
      }
      frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
      if (frameHeader === "PRIV") {
        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
        for (var i = 0; i < frame.byteLength; i++) {
          if (frame[i] === 0) {
            var owner = parseIso88591(frame, 0, i);
            if (owner === "com.apple.streaming.transportStreamTimestamp") {
              var d3 = frame.subarray(i + 1);
              var size = (d3[3] & 1) << 30 | d3[4] << 22 | d3[5] << 14 | d3[6] << 6 | d3[7] >>> 2;
              size *= 4;
              size += d3[7] & 3;
              return size;
            }
            break;
          }
        }
      }
      frameStart += 10;
      frameStart += frameSize;
    } while (frameStart < packet.byteLength);
    return null;
  };
  var utils2 = {
    isLikelyAacData: isLikelyAacData$1,
    parseId3TagSize,
    parseAdtsSize,
    parseType: parseType$2,
    parseSampleRate,
    parseAacTimestamp
  };
  var _AacStream;
  _AacStream = function AacStream() {
    var everything = new Uint8Array(), timeStamp = 0;
    _AacStream.prototype.init.call(this);
    this.setTimestamp = function(timestamp) {
      timeStamp = timestamp;
    };
    this.push = function(bytes) {
      var frameSize = 0, byteIndex = 0, bytesLeft, chunk, packet, tempLength;
      if (everything.length) {
        tempLength = everything.length;
        everything = new Uint8Array(bytes.byteLength + tempLength);
        everything.set(everything.subarray(0, tempLength));
        everything.set(bytes, tempLength);
      } else {
        everything = bytes;
      }
      while (everything.length - byteIndex >= 3) {
        if (everything[byteIndex] === "I".charCodeAt(0) && everything[byteIndex + 1] === "D".charCodeAt(0) && everything[byteIndex + 2] === "3".charCodeAt(0)) {
          if (everything.length - byteIndex < 10) {
            break;
          }
          frameSize = utils2.parseId3TagSize(everything, byteIndex);
          if (byteIndex + frameSize > everything.length) {
            break;
          }
          chunk = {
            type: "timed-metadata",
            data: everything.subarray(byteIndex, byteIndex + frameSize)
          };
          this.trigger("data", chunk);
          byteIndex += frameSize;
          continue;
        } else if ((everything[byteIndex] & 255) === 255 && (everything[byteIndex + 1] & 240) === 240) {
          if (everything.length - byteIndex < 7) {
            break;
          }
          frameSize = utils2.parseAdtsSize(everything, byteIndex);
          if (byteIndex + frameSize > everything.length) {
            break;
          }
          packet = {
            type: "audio",
            data: everything.subarray(byteIndex, byteIndex + frameSize),
            pts: timeStamp,
            dts: timeStamp
          };
          this.trigger("data", packet);
          byteIndex += frameSize;
          continue;
        }
        byteIndex++;
      }
      bytesLeft = everything.length - byteIndex;
      if (bytesLeft > 0) {
        everything = everything.subarray(byteIndex);
      } else {
        everything = new Uint8Array();
      }
    };
    this.reset = function() {
      everything = new Uint8Array();
      this.trigger("reset");
    };
    this.endTimeline = function() {
      everything = new Uint8Array();
      this.trigger("endedtimeline");
    };
  };
  _AacStream.prototype = new stream();
  var aac2 = _AacStream;
  var AUDIO_PROPERTIES = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"];
  var audioProperties = AUDIO_PROPERTIES;
  var VIDEO_PROPERTIES = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"];
  var videoProperties = VIDEO_PROPERTIES;
  var H264Stream = h2642.H264Stream;
  var isLikelyAacData = utils2.isLikelyAacData;
  var ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS;
  var _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;
  var retriggerForStream = function retriggerForStream2(key, event) {
    event.stream = key;
    this.trigger("log", event);
  };
  var addPipelineLogRetriggers = function addPipelineLogRetriggers2(transmuxer2, pipeline) {
    var keys3 = Object.keys(pipeline);
    for (var i = 0; i < keys3.length; i++) {
      var key = keys3[i];
      if (key === "headOfPipeline" || !pipeline[key].on) {
        continue;
      }
      pipeline[key].on("log", retriggerForStream.bind(transmuxer2, key));
    }
  };
  var arrayEquals = function arrayEquals2(a, b2) {
    var i;
    if (a.length !== b2.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b2[i]) {
        return false;
      }
    }
    return true;
  };
  var generateSegmentTimingInfo = function generateSegmentTimingInfo2(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
    var ptsOffsetFromDts = startPts - startDts, decodeDuration = endDts - startDts, presentationDuration = endPts - startPts;
    return {
      start: {
        dts: baseMediaDecodeTime,
        pts: baseMediaDecodeTime + ptsOffsetFromDts
      },
      end: {
        dts: baseMediaDecodeTime + decodeDuration,
        pts: baseMediaDecodeTime + presentationDuration
      },
      prependedContentDuration,
      baseMediaDecodeTime
    };
  };
  _AudioSegmentStream = function AudioSegmentStream(track, options) {
    var adtsFrames = [], sequenceNumber, earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = Infinity;
    options = options || {};
    sequenceNumber = options.firstSequenceNumber || 0;
    _AudioSegmentStream.prototype.init.call(this);
    this.push = function(data) {
      trackDecodeInfo.collectDtsInfo(track, data);
      if (track) {
        audioProperties.forEach(function(prop) {
          track[prop] = data[prop];
        });
      }
      adtsFrames.push(data);
    };
    this.setEarliestDts = function(earliestDts) {
      earliestAllowedDts = earliestDts;
    };
    this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
      videoBaseMediaDecodeTime = baseMediaDecodeTime;
    };
    this.setAudioAppendStart = function(timestamp) {
      audioAppendStartTs = timestamp;
    };
    this.flush = function() {
      var frames, moof2, mdat2, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
      if (adtsFrames.length === 0) {
        this.trigger("done", "AudioSegmentStream");
        return;
      }
      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
      videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
      track.samples = audioFrameUtils.generateSampleTable(frames);
      mdat2 = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));
      adtsFrames = [];
      moof2 = mp4Generator.moof(sequenceNumber, [track]);
      boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
      sequenceNumber++;
      boxes.set(moof2);
      boxes.set(mdat2, moof2.byteLength);
      trackDecodeInfo.clearDtsInfo(track);
      frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
      if (frames.length) {
        segmentDuration = frames.length * frameDuration;
        this.trigger("segmentTimingInfo", generateSegmentTimingInfo(
          // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
          // frame info is in video clock cycles. Convert to match expectation of
          // listeners (that all timestamps will be based on video clock cycles).
          clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),
          // frame times are already in video clock, as is segment duration
          frames[0].dts,
          frames[0].pts,
          frames[0].dts + segmentDuration,
          frames[0].pts + segmentDuration,
          videoClockCyclesOfSilencePrefixed || 0
        ));
        this.trigger("timingInfo", {
          start: frames[0].pts,
          end: frames[0].pts + segmentDuration
        });
      }
      this.trigger("data", {
        track,
        boxes
      });
      this.trigger("done", "AudioSegmentStream");
    };
    this.reset = function() {
      trackDecodeInfo.clearDtsInfo(track);
      adtsFrames = [];
      this.trigger("reset");
    };
  };
  _AudioSegmentStream.prototype = new stream();
  _VideoSegmentStream = function VideoSegmentStream(track, options) {
    var sequenceNumber, nalUnits = [], gopsToAlignWith = [], config, pps;
    options = options || {};
    sequenceNumber = options.firstSequenceNumber || 0;
    _VideoSegmentStream.prototype.init.call(this);
    delete track.minPTS;
    this.gopCache_ = [];
    this.push = function(nalUnit) {
      trackDecodeInfo.collectDtsInfo(track, nalUnit);
      if (nalUnit.nalUnitType === "seq_parameter_set_rbsp" && !config) {
        config = nalUnit.config;
        track.sps = [nalUnit.data];
        videoProperties.forEach(function(prop) {
          track[prop] = config[prop];
        }, this);
      }
      if (nalUnit.nalUnitType === "pic_parameter_set_rbsp" && !pps) {
        pps = nalUnit.data;
        track.pps = [nalUnit.data];
      }
      nalUnits.push(nalUnit);
    };
    this.flush = function() {
      var frames, gopForFusion, gops, moof2, mdat2, boxes, prependedContentDuration = 0, firstGop, lastGop;
      while (nalUnits.length) {
        if (nalUnits[0].nalUnitType === "access_unit_delimiter_rbsp") {
          break;
        }
        nalUnits.shift();
      }
      if (nalUnits.length === 0) {
        this.resetStream_();
        this.trigger("done", "VideoSegmentStream");
        return;
      }
      frames = frameUtils.groupNalsIntoFrames(nalUnits);
      gops = frameUtils.groupFramesIntoGops(frames);
      if (!gops[0][0].keyFrame) {
        gopForFusion = this.getGopForFusion_(nalUnits[0], track);
        if (gopForFusion) {
          prependedContentDuration = gopForFusion.duration;
          gops.unshift(gopForFusion);
          gops.byteLength += gopForFusion.byteLength;
          gops.nalCount += gopForFusion.nalCount;
          gops.pts = gopForFusion.pts;
          gops.dts = gopForFusion.dts;
          gops.duration += gopForFusion.duration;
        } else {
          gops = frameUtils.extendFirstKeyFrame(gops);
        }
      }
      if (gopsToAlignWith.length) {
        var alignedGops;
        if (options.alignGopsAtEnd) {
          alignedGops = this.alignGopsAtEnd_(gops);
        } else {
          alignedGops = this.alignGopsAtStart_(gops);
        }
        if (!alignedGops) {
          this.gopCache_.unshift({
            gop: gops.pop(),
            pps: track.pps,
            sps: track.sps
          });
          this.gopCache_.length = Math.min(6, this.gopCache_.length);
          nalUnits = [];
          this.resetStream_();
          this.trigger("done", "VideoSegmentStream");
          return;
        }
        trackDecodeInfo.clearDtsInfo(track);
        gops = alignedGops;
      }
      trackDecodeInfo.collectDtsInfo(track, gops);
      track.samples = frameUtils.generateSampleTable(gops);
      mdat2 = mp4Generator.mdat(frameUtils.concatenateNalData(gops));
      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
      this.trigger("processedGopsInfo", gops.map(function(gop) {
        return {
          pts: gop.pts,
          dts: gop.dts,
          byteLength: gop.byteLength
        };
      }));
      firstGop = gops[0];
      lastGop = gops[gops.length - 1];
      this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
      this.trigger("timingInfo", {
        start: gops[0].pts,
        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
      });
      this.gopCache_.unshift({
        gop: gops.pop(),
        pps: track.pps,
        sps: track.sps
      });
      this.gopCache_.length = Math.min(6, this.gopCache_.length);
      nalUnits = [];
      this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime);
      this.trigger("timelineStartInfo", track.timelineStartInfo);
      moof2 = mp4Generator.moof(sequenceNumber, [track]);
      boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
      sequenceNumber++;
      boxes.set(moof2);
      boxes.set(mdat2, moof2.byteLength);
      this.trigger("data", {
        track,
        boxes
      });
      this.resetStream_();
      this.trigger("done", "VideoSegmentStream");
    };
    this.reset = function() {
      this.resetStream_();
      nalUnits = [];
      this.gopCache_.length = 0;
      gopsToAlignWith.length = 0;
      this.trigger("reset");
    };
    this.resetStream_ = function() {
      trackDecodeInfo.clearDtsInfo(track);
      config = void 0;
      pps = void 0;
    };
    this.getGopForFusion_ = function(nalUnit) {
      var halfSecond = 45e3, allowableOverlap = 1e4, nearestDistance = Infinity, dtsDistance, nearestGopObj, currentGop, currentGopObj, i;
      for (i = 0; i < this.gopCache_.length; i++) {
        currentGopObj = this.gopCache_[i];
        currentGop = currentGopObj.gop;
        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {
          continue;
        }
        if (currentGop.dts < track.timelineStartInfo.dts) {
          continue;
        }
        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {
          if (!nearestGopObj || nearestDistance > dtsDistance) {
            nearestGopObj = currentGopObj;
            nearestDistance = dtsDistance;
          }
        }
      }
      if (nearestGopObj) {
        return nearestGopObj.gop;
      }
      return null;
    };
    this.alignGopsAtStart_ = function(gops) {
      var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration5, alignedGops;
      byteLength = gops.byteLength;
      nalCount = gops.nalCount;
      duration5 = gops.duration;
      alignIndex = gopIndex = 0;
      while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
        align = gopsToAlignWith[alignIndex];
        gop = gops[gopIndex];
        if (align.pts === gop.pts) {
          break;
        }
        if (gop.pts > align.pts) {
          alignIndex++;
          continue;
        }
        gopIndex++;
        byteLength -= gop.byteLength;
        nalCount -= gop.nalCount;
        duration5 -= gop.duration;
      }
      if (gopIndex === 0) {
        return gops;
      }
      if (gopIndex === gops.length) {
        return null;
      }
      alignedGops = gops.slice(gopIndex);
      alignedGops.byteLength = byteLength;
      alignedGops.duration = duration5;
      alignedGops.nalCount = nalCount;
      alignedGops.pts = alignedGops[0].pts;
      alignedGops.dts = alignedGops[0].dts;
      return alignedGops;
    };
    this.alignGopsAtEnd_ = function(gops) {
      var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
      alignIndex = gopsToAlignWith.length - 1;
      gopIndex = gops.length - 1;
      alignEndIndex = null;
      matchFound = false;
      while (alignIndex >= 0 && gopIndex >= 0) {
        align = gopsToAlignWith[alignIndex];
        gop = gops[gopIndex];
        if (align.pts === gop.pts) {
          matchFound = true;
          break;
        }
        if (align.pts > gop.pts) {
          alignIndex--;
          continue;
        }
        if (alignIndex === gopsToAlignWith.length - 1) {
          alignEndIndex = gopIndex;
        }
        gopIndex--;
      }
      if (!matchFound && alignEndIndex === null) {
        return null;
      }
      var trimIndex;
      if (matchFound) {
        trimIndex = gopIndex;
      } else {
        trimIndex = alignEndIndex;
      }
      if (trimIndex === 0) {
        return gops;
      }
      var alignedGops = gops.slice(trimIndex);
      var metadata = alignedGops.reduce(function(total, gop2) {
        total.byteLength += gop2.byteLength;
        total.duration += gop2.duration;
        total.nalCount += gop2.nalCount;
        return total;
      }, {
        byteLength: 0,
        duration: 0,
        nalCount: 0
      });
      alignedGops.byteLength = metadata.byteLength;
      alignedGops.duration = metadata.duration;
      alignedGops.nalCount = metadata.nalCount;
      alignedGops.pts = alignedGops[0].pts;
      alignedGops.dts = alignedGops[0].dts;
      return alignedGops;
    };
    this.alignGopsWith = function(newGopsToAlignWith) {
      gopsToAlignWith = newGopsToAlignWith;
    };
  };
  _VideoSegmentStream.prototype = new stream();
  _CoalesceStream = function CoalesceStream(options, metadataStream2) {
    this.numberOfTracks = 0;
    this.metadataStream = metadataStream2;
    options = options || {};
    if (typeof options.remux !== "undefined") {
      this.remuxTracks = !!options.remux;
    } else {
      this.remuxTracks = true;
    }
    if (typeof options.keepOriginalTimestamps === "boolean") {
      this.keepOriginalTimestamps = options.keepOriginalTimestamps;
    } else {
      this.keepOriginalTimestamps = false;
    }
    this.pendingTracks = [];
    this.videoTrack = null;
    this.pendingBoxes = [];
    this.pendingCaptions = [];
    this.pendingMetadata = [];
    this.pendingBytes = 0;
    this.emittedTracks = 0;
    _CoalesceStream.prototype.init.call(this);
    this.push = function(output) {
      if (output.text) {
        return this.pendingCaptions.push(output);
      }
      if (output.frames) {
        return this.pendingMetadata.push(output);
      }
      this.pendingTracks.push(output.track);
      this.pendingBytes += output.boxes.byteLength;
      if (output.track.type === "video") {
        this.videoTrack = output.track;
        this.pendingBoxes.push(output.boxes);
      }
      if (output.track.type === "audio") {
        this.audioTrack = output.track;
        this.pendingBoxes.unshift(output.boxes);
      }
    };
  };
  _CoalesceStream.prototype = new stream();
  _CoalesceStream.prototype.flush = function(flushSource) {
    var offset = 0, event = {
      captions: [],
      captionStreams: {},
      metadata: [],
      info: {}
    }, caption, id3, initSegment, timelineStartPts = 0, i;
    if (this.pendingTracks.length < this.numberOfTracks) {
      if (flushSource !== "VideoSegmentStream" && flushSource !== "AudioSegmentStream") {
        return;
      } else if (this.remuxTracks) {
        return;
      } else if (this.pendingTracks.length === 0) {
        this.emittedTracks++;
        if (this.emittedTracks >= this.numberOfTracks) {
          this.trigger("done");
          this.emittedTracks = 0;
        }
        return;
      }
    }
    if (this.videoTrack) {
      timelineStartPts = this.videoTrack.timelineStartInfo.pts;
      videoProperties.forEach(function(prop) {
        event.info[prop] = this.videoTrack[prop];
      }, this);
    } else if (this.audioTrack) {
      timelineStartPts = this.audioTrack.timelineStartInfo.pts;
      audioProperties.forEach(function(prop) {
        event.info[prop] = this.audioTrack[prop];
      }, this);
    }
    if (this.videoTrack || this.audioTrack) {
      if (this.pendingTracks.length === 1) {
        event.type = this.pendingTracks[0].type;
      } else {
        event.type = "combined";
      }
      this.emittedTracks += this.pendingTracks.length;
      initSegment = mp4Generator.initSegment(this.pendingTracks);
      event.initSegment = new Uint8Array(initSegment.byteLength);
      event.initSegment.set(initSegment);
      event.data = new Uint8Array(this.pendingBytes);
      for (i = 0; i < this.pendingBoxes.length; i++) {
        event.data.set(this.pendingBoxes[i], offset);
        offset += this.pendingBoxes[i].byteLength;
      }
      for (i = 0; i < this.pendingCaptions.length; i++) {
        caption = this.pendingCaptions[i];
        caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
        caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
        event.captionStreams[caption.stream] = true;
        event.captions.push(caption);
      }
      for (i = 0; i < this.pendingMetadata.length; i++) {
        id3 = this.pendingMetadata[i];
        id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);
        event.metadata.push(id3);
      }
      event.metadata.dispatchType = this.metadataStream.dispatchType;
      this.pendingTracks.length = 0;
      this.videoTrack = null;
      this.pendingBoxes.length = 0;
      this.pendingCaptions.length = 0;
      this.pendingBytes = 0;
      this.pendingMetadata.length = 0;
      this.trigger("data", event);
      for (i = 0; i < event.captions.length; i++) {
        caption = event.captions[i];
        this.trigger("caption", caption);
      }
      for (i = 0; i < event.metadata.length; i++) {
        id3 = event.metadata[i];
        this.trigger("id3Frame", id3);
      }
    }
    if (this.emittedTracks >= this.numberOfTracks) {
      this.trigger("done");
      this.emittedTracks = 0;
    }
  };
  _CoalesceStream.prototype.setRemux = function(val) {
    this.remuxTracks = val;
  };
  _Transmuxer = function Transmuxer(options) {
    var self2 = this, hasFlushed = true, videoTrack, audioTrack;
    _Transmuxer.prototype.init.call(this);
    options = options || {};
    this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
    this.transmuxPipeline_ = {};
    this.setupAacPipeline = function() {
      var pipeline = {};
      this.transmuxPipeline_ = pipeline;
      pipeline.type = "aac";
      pipeline.metadataStream = new m2ts_1.MetadataStream();
      pipeline.aacStream = new aac2();
      pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream("audio");
      pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream("timed-metadata");
      pipeline.adtsStream = new adts();
      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
      pipeline.headOfPipeline = pipeline.aacStream;
      pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
      pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
      pipeline.metadataStream.on("timestamp", function(frame) {
        pipeline.aacStream.setTimestamp(frame.timeStamp);
      });
      pipeline.aacStream.on("data", function(data) {
        if (data.type !== "timed-metadata" && data.type !== "audio" || pipeline.audioSegmentStream) {
          return;
        }
        audioTrack = audioTrack || {
          timelineStartInfo: {
            baseMediaDecodeTime: self2.baseMediaDecodeTime
          },
          codec: "adts",
          type: "audio"
        };
        pipeline.coalesceStream.numberOfTracks++;
        pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
        pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
        pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
        self2.trigger("trackinfo", {
          hasAudio: !!audioTrack,
          hasVideo: !!videoTrack
        });
      });
      pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
      pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
      addPipelineLogRetriggers(this, pipeline);
    };
    this.setupTsPipeline = function() {
      var pipeline = {};
      this.transmuxPipeline_ = pipeline;
      pipeline.type = "ts";
      pipeline.metadataStream = new m2ts_1.MetadataStream();
      pipeline.packetStream = new m2ts_1.TransportPacketStream();
      pipeline.parseStream = new m2ts_1.TransportParseStream();
      pipeline.elementaryStream = new m2ts_1.ElementaryStream();
      pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();
      pipeline.adtsStream = new adts();
      pipeline.h264Stream = new H264Stream();
      pipeline.captionStream = new m2ts_1.CaptionStream(options);
      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
      pipeline.headOfPipeline = pipeline.packetStream;
      pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
      pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
      pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
      pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
      pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
      pipeline.elementaryStream.on("data", function(data) {
        var i;
        if (data.type === "metadata") {
          i = data.tracks.length;
          while (i--) {
            if (!videoTrack && data.tracks[i].type === "video") {
              videoTrack = data.tracks[i];
              videoTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
            } else if (!audioTrack && data.tracks[i].type === "audio") {
              audioTrack = data.tracks[i];
              audioTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
            }
          }
          if (videoTrack && !pipeline.videoSegmentStream) {
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);
            pipeline.videoSegmentStream.on("log", self2.getLogTrigger_("videoSegmentStream"));
            pipeline.videoSegmentStream.on("timelineStartInfo", function(timelineStartInfo) {
              if (audioTrack && !options.keepOriginalTimestamps) {
                audioTrack.timelineStartInfo = timelineStartInfo;
                pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self2.baseMediaDecodeTime);
              }
            });
            pipeline.videoSegmentStream.on("processedGopsInfo", self2.trigger.bind(self2, "gopInfo"));
            pipeline.videoSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "videoSegmentTimingInfo"));
            pipeline.videoSegmentStream.on("baseMediaDecodeTime", function(baseMediaDecodeTime) {
              if (audioTrack) {
                pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
              }
            });
            pipeline.videoSegmentStream.on("timingInfo", self2.trigger.bind(self2, "videoTimingInfo"));
            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
          }
          if (audioTrack && !pipeline.audioSegmentStream) {
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
            pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
            pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
            pipeline.audioSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "audioSegmentTimingInfo"));
            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
          }
          self2.trigger("trackinfo", {
            hasAudio: !!audioTrack,
            hasVideo: !!videoTrack
          });
        }
      });
      pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
      pipeline.coalesceStream.on("id3Frame", function(id3Frame) {
        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
        self2.trigger("id3Frame", id3Frame);
      });
      pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption"));
      pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
      addPipelineLogRetriggers(this, pipeline);
    };
    this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
      var pipeline = this.transmuxPipeline_;
      if (!options.keepOriginalTimestamps) {
        this.baseMediaDecodeTime = baseMediaDecodeTime;
      }
      if (audioTrack) {
        audioTrack.timelineStartInfo.dts = void 0;
        audioTrack.timelineStartInfo.pts = void 0;
        trackDecodeInfo.clearDtsInfo(audioTrack);
        if (pipeline.audioTimestampRolloverStream) {
          pipeline.audioTimestampRolloverStream.discontinuity();
        }
      }
      if (videoTrack) {
        if (pipeline.videoSegmentStream) {
          pipeline.videoSegmentStream.gopCache_ = [];
        }
        videoTrack.timelineStartInfo.dts = void 0;
        videoTrack.timelineStartInfo.pts = void 0;
        trackDecodeInfo.clearDtsInfo(videoTrack);
        pipeline.captionStream.reset();
      }
      if (pipeline.timestampRolloverStream) {
        pipeline.timestampRolloverStream.discontinuity();
      }
    };
    this.setAudioAppendStart = function(timestamp) {
      if (audioTrack) {
        this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
      }
    };
    this.setRemux = function(val) {
      var pipeline = this.transmuxPipeline_;
      options.remux = val;
      if (pipeline && pipeline.coalesceStream) {
        pipeline.coalesceStream.setRemux(val);
      }
    };
    this.alignGopsWith = function(gopsToAlignWith) {
      if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {
        this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
      }
    };
    this.getLogTrigger_ = function(key) {
      var self3 = this;
      return function(event) {
        event.stream = key;
        self3.trigger("log", event);
      };
    };
    this.push = function(data) {
      if (hasFlushed) {
        var isAac = isLikelyAacData(data);
        if (isAac && this.transmuxPipeline_.type !== "aac") {
          this.setupAacPipeline();
        } else if (!isAac && this.transmuxPipeline_.type !== "ts") {
          this.setupTsPipeline();
        }
        hasFlushed = false;
      }
      this.transmuxPipeline_.headOfPipeline.push(data);
    };
    this.flush = function() {
      hasFlushed = true;
      this.transmuxPipeline_.headOfPipeline.flush();
    };
    this.endTimeline = function() {
      this.transmuxPipeline_.headOfPipeline.endTimeline();
    };
    this.reset = function() {
      if (this.transmuxPipeline_.headOfPipeline) {
        this.transmuxPipeline_.headOfPipeline.reset();
      }
    };
    this.resetCaptions = function() {
      if (this.transmuxPipeline_.captionStream) {
        this.transmuxPipeline_.captionStream.reset();
      }
    };
  };
  _Transmuxer.prototype = new stream();
  var transmuxer = {
    Transmuxer: _Transmuxer,
    VideoSegmentStream: _VideoSegmentStream,
    AudioSegmentStream: _AudioSegmentStream,
    AUDIO_PROPERTIES: audioProperties,
    VIDEO_PROPERTIES: videoProperties,
    // exported for testing
    generateSegmentTimingInfo
  };
  var toUnsigned$3 = function toUnsigned2(value) {
    return value >>> 0;
  };
  var toHexString$1 = function toHexString3(value) {
    return ("00" + value.toString(16)).slice(-2);
  };
  var bin = {
    toUnsigned: toUnsigned$3,
    toHexString: toHexString$1
  };
  var parseType$1 = function parseType2(buffer) {
    var result = "";
    result += String.fromCharCode(buffer[0]);
    result += String.fromCharCode(buffer[1]);
    result += String.fromCharCode(buffer[2]);
    result += String.fromCharCode(buffer[3]);
    return result;
  };
  var parseType_1 = parseType$1;
  var toUnsigned$2 = bin.toUnsigned;
  var findBox3 = function findBox4(data, path) {
    var results = [], i, size, type3, end, subresults;
    if (!path.length) {
      return null;
    }
    for (i = 0; i < data.byteLength; ) {
      size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);
      type3 = parseType_1(data.subarray(i + 4, i + 8));
      end = size > 1 ? i + size : data.byteLength;
      if (type3 === path[0]) {
        if (path.length === 1) {
          results.push(data.subarray(i + 8, end));
        } else {
          subresults = findBox4(data.subarray(i + 8, end), path.slice(1));
          if (subresults.length) {
            results = results.concat(subresults);
          }
        }
      }
      i = end;
    }
    return results;
  };
  var findBox_1 = findBox3;
  var toUnsigned$1 = bin.toUnsigned;
  var getUint64$1 = numbers.getUint64;
  var tfdt = function tfdt2(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4))
    };
    if (result.version === 1) {
      result.baseMediaDecodeTime = getUint64$1(data.subarray(4));
    } else {
      result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
    }
    return result;
  };
  var parseTfdt = tfdt;
  var parseSampleFlags = function parseSampleFlags2(flags) {
    return {
      isLeading: (flags[0] & 12) >>> 2,
      dependsOn: flags[0] & 3,
      isDependedOn: (flags[1] & 192) >>> 6,
      hasRedundancy: (flags[1] & 48) >>> 4,
      paddingValue: (flags[1] & 14) >>> 1,
      isNonSyncSample: flags[1] & 1,
      degradationPriority: flags[2] << 8 | flags[3]
    };
  };
  var parseSampleFlags_1 = parseSampleFlags;
  var trun = function trun2(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      samples: []
    }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = result.flags[2] & 1, firstSampleFlagsPresent = result.flags[2] & 4, sampleDurationPresent = result.flags[1] & 1, sampleSizePresent = result.flags[1] & 2, sampleFlagsPresent = result.flags[1] & 4, sampleCompositionTimeOffsetPresent = result.flags[1] & 8, sampleCount = view.getUint32(4), offset = 8, sample;
    if (dataOffsetPresent) {
      result.dataOffset = view.getInt32(offset);
      offset += 4;
    }
    if (firstSampleFlagsPresent && sampleCount) {
      sample = {
        flags: parseSampleFlags_1(data.subarray(offset, offset + 4))
      };
      offset += 4;
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset);
        offset += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset);
        offset += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        if (result.version === 1) {
          sample.compositionTimeOffset = view.getInt32(offset);
        } else {
          sample.compositionTimeOffset = view.getUint32(offset);
        }
        offset += 4;
      }
      result.samples.push(sample);
      sampleCount--;
    }
    while (sampleCount--) {
      sample = {};
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset);
        offset += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset);
        offset += 4;
      }
      if (sampleFlagsPresent) {
        sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));
        offset += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        if (result.version === 1) {
          sample.compositionTimeOffset = view.getInt32(offset);
        } else {
          sample.compositionTimeOffset = view.getUint32(offset);
        }
        offset += 4;
      }
      result.samples.push(sample);
    }
    return result;
  };
  var parseTrun = trun;
  var tfhd = function tfhd2(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      trackId: view.getUint32(4)
    }, baseDataOffsetPresent = result.flags[2] & 1, sampleDescriptionIndexPresent = result.flags[2] & 2, defaultSampleDurationPresent = result.flags[2] & 8, defaultSampleSizePresent = result.flags[2] & 16, defaultSampleFlagsPresent = result.flags[2] & 32, durationIsEmpty = result.flags[0] & 65536, defaultBaseIsMoof = result.flags[0] & 131072, i;
    i = 8;
    if (baseDataOffsetPresent) {
      i += 4;
      result.baseDataOffset = view.getUint32(12);
      i += 4;
    }
    if (sampleDescriptionIndexPresent) {
      result.sampleDescriptionIndex = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleDurationPresent) {
      result.defaultSampleDuration = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleSizePresent) {
      result.defaultSampleSize = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleFlagsPresent) {
      result.defaultSampleFlags = view.getUint32(i);
    }
    if (durationIsEmpty) {
      result.durationIsEmpty = true;
    }
    if (!baseDataOffsetPresent && defaultBaseIsMoof) {
      result.baseDataOffsetIsMoof = true;
    }
    return result;
  };
  var parseTfhd = tfhd;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  var window_1 = win;
  var discardEmulationPreventionBytes3 = captionPacketParser.discardEmulationPreventionBytes;
  var CaptionStream = captionStream.CaptionStream;
  var mapToSample = function mapToSample2(offset, samples) {
    var approximateOffset = offset;
    for (var i = 0; i < samples.length; i++) {
      var sample = samples[i];
      if (approximateOffset < sample.size) {
        return sample;
      }
      approximateOffset -= sample.size;
    }
    return null;
  };
  var findSeiNals = function findSeiNals2(avcStream, samples, trackId) {
    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
      logs: [],
      seiNals: []
    }, seiNal, i, length, lastMatchedSample;
    for (i = 0; i + 4 < avcStream.length; i += length) {
      length = avcView.getUint32(i);
      i += 4;
      if (length <= 0) {
        continue;
      }
      switch (avcStream[i] & 31) {
        case 6:
          var data = avcStream.subarray(i + 1, i + 1 + length);
          var matchingSample = mapToSample(i, samples);
          seiNal = {
            nalUnitType: "sei_rbsp",
            size: length,
            data,
            escapedRBSP: discardEmulationPreventionBytes3(data),
            trackId
          };
          if (matchingSample) {
            seiNal.pts = matchingSample.pts;
            seiNal.dts = matchingSample.dts;
            lastMatchedSample = matchingSample;
          } else if (lastMatchedSample) {
            seiNal.pts = lastMatchedSample.pts;
            seiNal.dts = lastMatchedSample.dts;
          } else {
            result.logs.push({
              level: "warn",
              message: "We've encountered a nal unit without data at " + i + " for trackId " + trackId + ". See mux.js#223."
            });
            break;
          }
          result.seiNals.push(seiNal);
          break;
      }
    }
    return result;
  };
  var parseSamples = function parseSamples2(truns, baseMediaDecodeTime, tfhd2) {
    var currentDts = baseMediaDecodeTime;
    var defaultSampleDuration = tfhd2.defaultSampleDuration || 0;
    var defaultSampleSize = tfhd2.defaultSampleSize || 0;
    var trackId = tfhd2.trackId;
    var allSamples = [];
    truns.forEach(function(trun2) {
      var trackRun = parseTrun(trun2);
      var samples = trackRun.samples;
      samples.forEach(function(sample) {
        if (sample.duration === void 0) {
          sample.duration = defaultSampleDuration;
        }
        if (sample.size === void 0) {
          sample.size = defaultSampleSize;
        }
        sample.trackId = trackId;
        sample.dts = currentDts;
        if (sample.compositionTimeOffset === void 0) {
          sample.compositionTimeOffset = 0;
        }
        if (typeof currentDts === "bigint") {
          sample.pts = currentDts + window_1.BigInt(sample.compositionTimeOffset);
          currentDts += window_1.BigInt(sample.duration);
        } else {
          sample.pts = currentDts + sample.compositionTimeOffset;
          currentDts += sample.duration;
        }
      });
      allSamples = allSamples.concat(samples);
    });
    return allSamples;
  };
  var parseCaptionNals = function parseCaptionNals2(segment, videoTrackId) {
    var trafs = findBox_1(segment, ["moof", "traf"]);
    var mdats = findBox_1(segment, ["mdat"]);
    var captionNals = {};
    var mdatTrafPairs = [];
    mdats.forEach(function(mdat2, index) {
      var matchingTraf = trafs[index];
      mdatTrafPairs.push({
        mdat: mdat2,
        traf: matchingTraf
      });
    });
    mdatTrafPairs.forEach(function(pair) {
      var mdat2 = pair.mdat;
      var traf2 = pair.traf;
      var tfhd2 = findBox_1(traf2, ["tfhd"]);
      var headerInfo = parseTfhd(tfhd2[0]);
      var trackId = headerInfo.trackId;
      var tfdt2 = findBox_1(traf2, ["tfdt"]);
      var baseMediaDecodeTime = tfdt2.length > 0 ? parseTfdt(tfdt2[0]).baseMediaDecodeTime : 0;
      var truns = findBox_1(traf2, ["trun"]);
      var samples;
      var result;
      if (videoTrackId === trackId && truns.length > 0) {
        samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);
        result = findSeiNals(mdat2, samples, trackId);
        if (!captionNals[trackId]) {
          captionNals[trackId] = {
            seiNals: [],
            logs: []
          };
        }
        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
      }
    });
    return captionNals;
  };
  var parseEmbeddedCaptions = function parseEmbeddedCaptions2(segment, trackId, timescale3) {
    var captionNals;
    if (trackId === null) {
      return null;
    }
    captionNals = parseCaptionNals(segment, trackId);
    var trackNals = captionNals[trackId] || {};
    return {
      seiNals: trackNals.seiNals,
      logs: trackNals.logs,
      timescale: timescale3
    };
  };
  var CaptionParser = function CaptionParser2() {
    var isInitialized = false;
    var captionStream2;
    var segmentCache;
    var trackId;
    var timescale3;
    var parsedCaptions;
    var parsingPartial;
    this.isInitialized = function() {
      return isInitialized;
    };
    this.init = function(options) {
      captionStream2 = new CaptionStream();
      isInitialized = true;
      parsingPartial = options ? options.isPartial : false;
      captionStream2.on("data", function(event) {
        event.startTime = event.startPts / timescale3;
        event.endTime = event.endPts / timescale3;
        parsedCaptions.captions.push(event);
        parsedCaptions.captionStreams[event.stream] = true;
      });
      captionStream2.on("log", function(log2) {
        parsedCaptions.logs.push(log2);
      });
    };
    this.isNewInit = function(videoTrackIds, timescales) {
      if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === "object" && Object.keys(timescales).length === 0) {
        return false;
      }
      return trackId !== videoTrackIds[0] || timescale3 !== timescales[trackId];
    };
    this.parse = function(segment, videoTrackIds, timescales) {
      var parsedData;
      if (!this.isInitialized()) {
        return null;
      } else if (!videoTrackIds || !timescales) {
        return null;
      } else if (this.isNewInit(videoTrackIds, timescales)) {
        trackId = videoTrackIds[0];
        timescale3 = timescales[trackId];
      } else if (trackId === null || !timescale3) {
        segmentCache.push(segment);
        return null;
      }
      while (segmentCache.length > 0) {
        var cachedSegment = segmentCache.shift();
        this.parse(cachedSegment, videoTrackIds, timescales);
      }
      parsedData = parseEmbeddedCaptions(segment, trackId, timescale3);
      if (parsedData && parsedData.logs) {
        parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
      }
      if (parsedData === null || !parsedData.seiNals) {
        if (parsedCaptions.logs.length) {
          return {
            logs: parsedCaptions.logs,
            captions: [],
            captionStreams: []
          };
        }
        return null;
      }
      this.pushNals(parsedData.seiNals);
      this.flushStream();
      return parsedCaptions;
    };
    this.pushNals = function(nals) {
      if (!this.isInitialized() || !nals || nals.length === 0) {
        return null;
      }
      nals.forEach(function(nal) {
        captionStream2.push(nal);
      });
    };
    this.flushStream = function() {
      if (!this.isInitialized()) {
        return null;
      }
      if (!parsingPartial) {
        captionStream2.flush();
      } else {
        captionStream2.partialFlush();
      }
    };
    this.clearParsedCaptions = function() {
      parsedCaptions.captions = [];
      parsedCaptions.captionStreams = {};
      parsedCaptions.logs = [];
    };
    this.resetCaptionStream = function() {
      if (!this.isInitialized()) {
        return null;
      }
      captionStream2.reset();
    };
    this.clearAllCaptions = function() {
      this.clearParsedCaptions();
      this.resetCaptionStream();
    };
    this.reset = function() {
      segmentCache = [];
      trackId = null;
      timescale3 = null;
      if (!parsedCaptions) {
        parsedCaptions = {
          captions: [],
          // CC1, CC2, CC3, CC4
          captionStreams: {},
          logs: []
        };
      } else {
        this.clearParsedCaptions();
      }
      this.resetCaptionStream();
    };
    this.reset();
  };
  var captionParser = CaptionParser;
  var toUnsigned = bin.toUnsigned;
  var toHexString2 = bin.toHexString;
  var getUint64 = numbers.getUint64;
  var timescale2, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;
  timescale2 = function timescale3(init) {
    var result = {}, traks = findBox_1(init, ["moov", "trak"]);
    return traks.reduce(function(result2, trak2) {
      var tkhd2, version2, index, id, mdhd2;
      tkhd2 = findBox_1(trak2, ["tkhd"])[0];
      if (!tkhd2) {
        return null;
      }
      version2 = tkhd2[0];
      index = version2 === 0 ? 12 : 20;
      id = toUnsigned(tkhd2[index] << 24 | tkhd2[index + 1] << 16 | tkhd2[index + 2] << 8 | tkhd2[index + 3]);
      mdhd2 = findBox_1(trak2, ["mdia", "mdhd"])[0];
      if (!mdhd2) {
        return null;
      }
      version2 = mdhd2[0];
      index = version2 === 0 ? 12 : 20;
      result2[id] = toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
      return result2;
    }, result);
  };
  startTime = function startTime2(timescale3, fragment) {
    var trafs;
    trafs = findBox_1(fragment, ["moof", "traf"]);
    var lowestTime = trafs.reduce(function(acc, traf2) {
      var tfhd2 = findBox_1(traf2, ["tfhd"])[0];
      var id = toUnsigned(tfhd2[4] << 24 | tfhd2[5] << 16 | tfhd2[6] << 8 | tfhd2[7]);
      var scale = timescale3[id] || 9e4;
      var tfdt2 = findBox_1(traf2, ["tfdt"])[0];
      var dv = new DataView(tfdt2.buffer, tfdt2.byteOffset, tfdt2.byteLength);
      var baseTime;
      if (tfdt2[0] === 1) {
        baseTime = getUint64(tfdt2.subarray(4, 12));
      } else {
        baseTime = dv.getUint32(4);
      }
      var seconds;
      if (typeof baseTime === "bigint") {
        seconds = baseTime / window_1.BigInt(scale);
      } else if (typeof baseTime === "number" && !isNaN(baseTime)) {
        seconds = baseTime / scale;
      }
      if (seconds < Number.MAX_SAFE_INTEGER) {
        seconds = Number(seconds);
      }
      if (seconds < acc) {
        acc = seconds;
      }
      return acc;
    }, Infinity);
    return typeof lowestTime === "bigint" || isFinite(lowestTime) ? lowestTime : 0;
  };
  compositionStartTime = function compositionStartTime2(timescales, fragment) {
    var trafBoxes = findBox_1(fragment, ["moof", "traf"]);
    var baseMediaDecodeTime = 0;
    var compositionTimeOffset = 0;
    var trackId;
    if (trafBoxes && trafBoxes.length) {
      var tfhd2 = findBox_1(trafBoxes[0], ["tfhd"])[0];
      var trun2 = findBox_1(trafBoxes[0], ["trun"])[0];
      var tfdt2 = findBox_1(trafBoxes[0], ["tfdt"])[0];
      if (tfhd2) {
        var parsedTfhd = parseTfhd(tfhd2);
        trackId = parsedTfhd.trackId;
      }
      if (tfdt2) {
        var parsedTfdt = parseTfdt(tfdt2);
        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
      }
      if (trun2) {
        var parsedTrun = parseTrun(trun2);
        if (parsedTrun.samples && parsedTrun.samples.length) {
          compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
        }
      }
    }
    var timescale3 = timescales[trackId] || 9e4;
    if (typeof baseMediaDecodeTime === "bigint") {
      compositionTimeOffset = window_1.BigInt(compositionTimeOffset);
      timescale3 = window_1.BigInt(timescale3);
    }
    var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale3;
    if (typeof result === "bigint" && result < Number.MAX_SAFE_INTEGER) {
      result = Number(result);
    }
    return result;
  };
  getVideoTrackIds = function getVideoTrackIds2(init) {
    var traks = findBox_1(init, ["moov", "trak"]);
    var videoTrackIds = [];
    traks.forEach(function(trak2) {
      var hdlrs = findBox_1(trak2, ["mdia", "hdlr"]);
      var tkhds = findBox_1(trak2, ["tkhd"]);
      hdlrs.forEach(function(hdlr2, index) {
        var handlerType = parseType_1(hdlr2.subarray(8, 12));
        var tkhd2 = tkhds[index];
        var view;
        var version2;
        var trackId;
        if (handlerType === "vide") {
          view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
          version2 = view.getUint8(0);
          trackId = version2 === 0 ? view.getUint32(12) : view.getUint32(20);
          videoTrackIds.push(trackId);
        }
      });
    });
    return videoTrackIds;
  };
  getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader2(mdhd2) {
    var version2 = mdhd2[0];
    var index = version2 === 0 ? 12 : 20;
    return toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
  };
  getTracks = function getTracks2(init) {
    var traks = findBox_1(init, ["moov", "trak"]);
    var tracks = [];
    traks.forEach(function(trak2) {
      var track = {};
      var tkhd2 = findBox_1(trak2, ["tkhd"])[0];
      var view, tkhdVersion;
      if (tkhd2) {
        view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
        tkhdVersion = view.getUint8(0);
        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
      }
      var hdlr2 = findBox_1(trak2, ["mdia", "hdlr"])[0];
      if (hdlr2) {
        var type3 = parseType_1(hdlr2.subarray(8, 12));
        if (type3 === "vide") {
          track.type = "video";
        } else if (type3 === "soun") {
          track.type = "audio";
        } else {
          track.type = type3;
        }
      }
      var stsd2 = findBox_1(trak2, ["mdia", "minf", "stbl", "stsd"])[0];
      if (stsd2) {
        var sampleDescriptions = stsd2.subarray(8);
        track.codec = parseType_1(sampleDescriptions.subarray(4, 8));
        var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];
        var codecConfig, codecConfigType;
        if (codecBox) {
          if (/^[asm]vc[1-9]$/i.test(track.codec)) {
            codecConfig = codecBox.subarray(78);
            codecConfigType = parseType_1(codecConfig.subarray(4, 8));
            if (codecConfigType === "avcC" && codecConfig.length > 11) {
              track.codec += ".";
              track.codec += toHexString2(codecConfig[9]);
              track.codec += toHexString2(codecConfig[10]);
              track.codec += toHexString2(codecConfig[11]);
            } else {
              track.codec = "avc1.4d400d";
            }
          } else if (/^mp4[a,v]$/i.test(track.codec)) {
            codecConfig = codecBox.subarray(28);
            codecConfigType = parseType_1(codecConfig.subarray(4, 8));
            if (codecConfigType === "esds" && codecConfig.length > 20 && codecConfig[19] !== 0) {
              track.codec += "." + toHexString2(codecConfig[19]);
              track.codec += "." + toHexString2(codecConfig[20] >>> 2 & 63).replace(/^0/, "");
            } else {
              track.codec = "mp4a.40.2";
            }
          } else {
            track.codec = track.codec.toLowerCase();
          }
        }
      }
      var mdhd2 = findBox_1(trak2, ["mdia", "mdhd"])[0];
      if (mdhd2) {
        track.timescale = getTimescaleFromMediaHeader(mdhd2);
      }
      tracks.push(track);
    });
    return tracks;
  };
  var probe$2 = {
    // export mp4 inspector's findBox and parseType for backwards compatibility
    findBox: findBox_1,
    parseType: parseType_1,
    timescale: timescale2,
    startTime,
    compositionStartTime,
    videoTrackIds: getVideoTrackIds,
    tracks: getTracks,
    getTimescaleFromMediaHeader
  };
  var parsePid = function parsePid2(packet) {
    var pid = packet[1] & 31;
    pid <<= 8;
    pid |= packet[2];
    return pid;
  };
  var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator2(packet) {
    return !!(packet[1] & 64);
  };
  var parseAdaptionField = function parseAdaptionField2(packet) {
    var offset = 0;
    if ((packet[3] & 48) >>> 4 > 1) {
      offset += packet[4] + 1;
    }
    return offset;
  };
  var parseType = function parseType2(packet, pmtPid) {
    var pid = parsePid(packet);
    if (pid === 0) {
      return "pat";
    } else if (pid === pmtPid) {
      return "pmt";
    } else if (pmtPid) {
      return "pes";
    }
    return null;
  };
  var parsePat = function parsePat2(packet) {
    var pusi = parsePayloadUnitStartIndicator(packet);
    var offset = 4 + parseAdaptionField(packet);
    if (pusi) {
      offset += packet[offset] + 1;
    }
    return (packet[offset + 10] & 31) << 8 | packet[offset + 11];
  };
  var parsePmt = function parsePmt2(packet) {
    var programMapTable = {};
    var pusi = parsePayloadUnitStartIndicator(packet);
    var payloadOffset = 4 + parseAdaptionField(packet);
    if (pusi) {
      payloadOffset += packet[payloadOffset] + 1;
    }
    if (!(packet[payloadOffset + 5] & 1)) {
      return;
    }
    var sectionLength, tableEnd, programInfoLength;
    sectionLength = (packet[payloadOffset + 1] & 15) << 8 | packet[payloadOffset + 2];
    tableEnd = 3 + sectionLength - 4;
    programInfoLength = (packet[payloadOffset + 10] & 15) << 8 | packet[payloadOffset + 11];
    var offset = 12 + programInfoLength;
    while (offset < tableEnd) {
      var i = payloadOffset + offset;
      programMapTable[(packet[i + 1] & 31) << 8 | packet[i + 2]] = packet[i];
      offset += ((packet[i + 3] & 15) << 8 | packet[i + 4]) + 5;
    }
    return programMapTable;
  };
  var parsePesType = function parsePesType2(packet, programMapTable) {
    var pid = parsePid(packet);
    var type3 = programMapTable[pid];
    switch (type3) {
      case streamTypes.H264_STREAM_TYPE:
        return "video";
      case streamTypes.ADTS_STREAM_TYPE:
        return "audio";
      case streamTypes.METADATA_STREAM_TYPE:
        return "timed-metadata";
      default:
        return null;
    }
  };
  var parsePesTime = function parsePesTime2(packet) {
    var pusi = parsePayloadUnitStartIndicator(packet);
    if (!pusi) {
      return null;
    }
    var offset = 4 + parseAdaptionField(packet);
    if (offset >= packet.byteLength) {
      return null;
    }
    var pes = null;
    var ptsDtsFlags;
    ptsDtsFlags = packet[offset + 7];
    if (ptsDtsFlags & 192) {
      pes = {};
      pes.pts = (packet[offset + 9] & 14) << 27 | (packet[offset + 10] & 255) << 20 | (packet[offset + 11] & 254) << 12 | (packet[offset + 12] & 255) << 5 | (packet[offset + 13] & 254) >>> 3;
      pes.pts *= 4;
      pes.pts += (packet[offset + 13] & 6) >>> 1;
      pes.dts = pes.pts;
      if (ptsDtsFlags & 64) {
        pes.dts = (packet[offset + 14] & 14) << 27 | (packet[offset + 15] & 255) << 20 | (packet[offset + 16] & 254) << 12 | (packet[offset + 17] & 255) << 5 | (packet[offset + 18] & 254) >>> 3;
        pes.dts *= 4;
        pes.dts += (packet[offset + 18] & 6) >>> 1;
      }
    }
    return pes;
  };
  var parseNalUnitType = function parseNalUnitType2(type3) {
    switch (type3) {
      case 5:
        return "slice_layer_without_partitioning_rbsp_idr";
      case 6:
        return "sei_rbsp";
      case 7:
        return "seq_parameter_set_rbsp";
      case 8:
        return "pic_parameter_set_rbsp";
      case 9:
        return "access_unit_delimiter_rbsp";
      default:
        return null;
    }
  };
  var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame2(packet) {
    var offset = 4 + parseAdaptionField(packet);
    var frameBuffer = packet.subarray(offset);
    var frameI = 0;
    var frameSyncPoint = 0;
    var foundKeyFrame = false;
    var nalType;
    for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {
      if (frameBuffer[frameSyncPoint + 2] === 1) {
        frameI = frameSyncPoint + 5;
        break;
      }
    }
    while (frameI < frameBuffer.byteLength) {
      switch (frameBuffer[frameI]) {
        case 0:
          if (frameBuffer[frameI - 1] !== 0) {
            frameI += 2;
            break;
          } else if (frameBuffer[frameI - 2] !== 0) {
            frameI++;
            break;
          }
          if (frameSyncPoint + 3 !== frameI - 2) {
            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
            if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
              foundKeyFrame = true;
            }
          }
          do {
            frameI++;
          } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
          frameSyncPoint = frameI - 2;
          frameI += 3;
          break;
        case 1:
          if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
            frameI += 3;
            break;
          }
          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
          if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
            foundKeyFrame = true;
          }
          frameSyncPoint = frameI - 2;
          frameI += 3;
          break;
        default:
          frameI += 3;
          break;
      }
    }
    frameBuffer = frameBuffer.subarray(frameSyncPoint);
    frameI -= frameSyncPoint;
    frameSyncPoint = 0;
    if (frameBuffer && frameBuffer.byteLength > 3) {
      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
      if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
        foundKeyFrame = true;
      }
    }
    return foundKeyFrame;
  };
  var probe$1 = {
    parseType,
    parsePat,
    parsePmt,
    parsePayloadUnitStartIndicator,
    parsePesType,
    parsePesTime,
    videoPacketContainsKeyFrame
  };
  var handleRollover = timestampRolloverStream.handleRollover;
  var probe = {};
  probe.ts = probe$1;
  probe.aac = utils2;
  var ONE_SECOND_IN_TS2 = clock.ONE_SECOND_IN_TS;
  var MP2T_PACKET_LENGTH = 188, SYNC_BYTE = 71;
  var parsePsi_ = function parsePsi_2(bytes, pmt) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3;
    while (endIndex < bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pat":
            pmt.pid = probe.ts.parsePat(packet);
            break;
          case "pmt":
            var table = probe.ts.parsePmt(packet);
            pmt.table = pmt.table || {};
            Object.keys(table).forEach(function(key) {
              pmt.table[key] = table[key];
            });
            break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
  };
  var parseAudioPes_ = function parseAudioPes_2(bytes, pmt, result) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3, pesType, pusi, parsed;
    var endLoop = false;
    while (endIndex <= bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "audio" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "audio";
                result.audio.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
    endIndex = bytes.byteLength;
    startIndex = endIndex - MP2T_PACKET_LENGTH;
    endLoop = false;
    while (startIndex >= 0) {
      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "audio" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "audio";
                result.audio.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex -= MP2T_PACKET_LENGTH;
        endIndex -= MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex--;
      endIndex--;
    }
  };
  var parseVideoPes_ = function parseVideoPes_2(bytes, pmt, result) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3, pesType, pusi, parsed, frame, i, pes;
    var endLoop = false;
    var currentFrame = {
      data: [],
      size: 0
    };
    while (endIndex < bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "video") {
              if (pusi && !endLoop) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = "video";
                  result.video.push(parsed);
                  endLoop = true;
                }
              }
              if (!result.firstKeyFrame) {
                if (pusi) {
                  if (currentFrame.size !== 0) {
                    frame = new Uint8Array(currentFrame.size);
                    i = 0;
                    while (currentFrame.data.length) {
                      pes = currentFrame.data.shift();
                      frame.set(pes, i);
                      i += pes.byteLength;
                    }
                    if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                      var firstKeyFrame = probe.ts.parsePesTime(frame);
                      if (firstKeyFrame) {
                        result.firstKeyFrame = firstKeyFrame;
                        result.firstKeyFrame.type = "video";
                      } else {
                        console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                      }
                    }
                    currentFrame.size = 0;
                  }
                }
                currentFrame.data.push(packet);
                currentFrame.size += packet.byteLength;
              }
            }
            break;
        }
        if (endLoop && result.firstKeyFrame) {
          break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
    endIndex = bytes.byteLength;
    startIndex = endIndex - MP2T_PACKET_LENGTH;
    endLoop = false;
    while (startIndex >= 0) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "video" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "video";
                result.video.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex -= MP2T_PACKET_LENGTH;
        endIndex -= MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex--;
      endIndex--;
    }
  };
  var adjustTimestamp_ = function adjustTimestamp_2(segmentInfo, baseTimestamp) {
    if (segmentInfo.audio && segmentInfo.audio.length) {
      var audioBaseTimestamp = baseTimestamp;
      if (typeof audioBaseTimestamp === "undefined" || isNaN(audioBaseTimestamp)) {
        audioBaseTimestamp = segmentInfo.audio[0].dts;
      }
      segmentInfo.audio.forEach(function(info) {
        info.dts = handleRollover(info.dts, audioBaseTimestamp);
        info.pts = handleRollover(info.pts, audioBaseTimestamp);
        info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
        info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
      });
    }
    if (segmentInfo.video && segmentInfo.video.length) {
      var videoBaseTimestamp = baseTimestamp;
      if (typeof videoBaseTimestamp === "undefined" || isNaN(videoBaseTimestamp)) {
        videoBaseTimestamp = segmentInfo.video[0].dts;
      }
      segmentInfo.video.forEach(function(info) {
        info.dts = handleRollover(info.dts, videoBaseTimestamp);
        info.pts = handleRollover(info.pts, videoBaseTimestamp);
        info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
        info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
      });
      if (segmentInfo.firstKeyFrame) {
        var frame = segmentInfo.firstKeyFrame;
        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
        frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS2;
        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS2;
      }
    }
  };
  var inspectAac_ = function inspectAac_2(bytes) {
    var endLoop = false, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0, packet;
    while (bytes.length - byteIndex >= 3) {
      var type3 = probe.aac.parseType(bytes, byteIndex);
      switch (type3) {
        case "timed-metadata":
          if (bytes.length - byteIndex < 10) {
            endLoop = true;
            break;
          }
          frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);
          if (frameSize > bytes.length) {
            endLoop = true;
            break;
          }
          if (timestamp === null) {
            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
            timestamp = probe.aac.parseAacTimestamp(packet);
          }
          byteIndex += frameSize;
          break;
        case "audio":
          if (bytes.length - byteIndex < 7) {
            endLoop = true;
            break;
          }
          frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);
          if (frameSize > bytes.length) {
            endLoop = true;
            break;
          }
          if (sampleRate === null) {
            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
            sampleRate = probe.aac.parseSampleRate(packet);
          }
          audioCount++;
          byteIndex += frameSize;
          break;
        default:
          byteIndex++;
          break;
      }
      if (endLoop) {
        return null;
      }
    }
    if (sampleRate === null || timestamp === null) {
      return null;
    }
    var audioTimescale = ONE_SECOND_IN_TS2 / sampleRate;
    var result = {
      audio: [{
        type: "audio",
        dts: timestamp,
        pts: timestamp
      }, {
        type: "audio",
        dts: timestamp + audioCount * 1024 * audioTimescale,
        pts: timestamp + audioCount * 1024 * audioTimescale
      }]
    };
    return result;
  };
  var inspectTs_ = function inspectTs_2(bytes) {
    var pmt = {
      pid: null,
      table: null
    };
    var result = {};
    parsePsi_(bytes, pmt);
    for (var pid in pmt.table) {
      if (pmt.table.hasOwnProperty(pid)) {
        var type3 = pmt.table[pid];
        switch (type3) {
          case streamTypes.H264_STREAM_TYPE:
            result.video = [];
            parseVideoPes_(bytes, pmt, result);
            if (result.video.length === 0) {
              delete result.video;
            }
            break;
          case streamTypes.ADTS_STREAM_TYPE:
            result.audio = [];
            parseAudioPes_(bytes, pmt, result);
            if (result.audio.length === 0) {
              delete result.audio;
            }
            break;
        }
      }
    }
    return result;
  };
  var inspect = function inspect2(bytes, baseTimestamp) {
    var isAacData = probe.aac.isLikelyAacData(bytes);
    var result;
    if (isAacData) {
      result = inspectAac_(bytes);
    } else {
      result = inspectTs_(bytes);
    }
    if (!result || !result.audio && !result.video) {
      return null;
    }
    adjustTimestamp_(result, baseTimestamp);
    return result;
  };
  var tsInspector = {
    inspect,
    parseAudioPes_
  };
  var wireTransmuxerEvents = function wireTransmuxerEvents2(self2, transmuxer2) {
    transmuxer2.on("data", function(segment) {
      var initArray = segment.initSegment;
      segment.initSegment = {
        data: initArray.buffer,
        byteOffset: initArray.byteOffset,
        byteLength: initArray.byteLength
      };
      var typedArray = segment.data;
      segment.data = typedArray.buffer;
      self2.postMessage({
        action: "data",
        segment,
        byteOffset: typedArray.byteOffset,
        byteLength: typedArray.byteLength
      }, [segment.data]);
    });
    transmuxer2.on("done", function(data) {
      self2.postMessage({
        action: "done"
      });
    });
    transmuxer2.on("gopInfo", function(gopInfo) {
      self2.postMessage({
        action: "gopInfo",
        gopInfo
      });
    });
    transmuxer2.on("videoSegmentTimingInfo", function(timingInfo) {
      var videoSegmentTimingInfo = {
        start: {
          decode: clock.videoTsToSeconds(timingInfo.start.dts),
          presentation: clock.videoTsToSeconds(timingInfo.start.pts)
        },
        end: {
          decode: clock.videoTsToSeconds(timingInfo.end.dts),
          presentation: clock.videoTsToSeconds(timingInfo.end.pts)
        },
        baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
      };
      if (timingInfo.prependedContentDuration) {
        videoSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration);
      }
      self2.postMessage({
        action: "videoSegmentTimingInfo",
        videoSegmentTimingInfo
      });
    });
    transmuxer2.on("audioSegmentTimingInfo", function(timingInfo) {
      var audioSegmentTimingInfo = {
        start: {
          decode: clock.videoTsToSeconds(timingInfo.start.dts),
          presentation: clock.videoTsToSeconds(timingInfo.start.pts)
        },
        end: {
          decode: clock.videoTsToSeconds(timingInfo.end.dts),
          presentation: clock.videoTsToSeconds(timingInfo.end.pts)
        },
        baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
      };
      if (timingInfo.prependedContentDuration) {
        audioSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration);
      }
      self2.postMessage({
        action: "audioSegmentTimingInfo",
        audioSegmentTimingInfo
      });
    });
    transmuxer2.on("id3Frame", function(id3Frame) {
      self2.postMessage({
        action: "id3Frame",
        id3Frame
      });
    });
    transmuxer2.on("caption", function(caption) {
      self2.postMessage({
        action: "caption",
        caption
      });
    });
    transmuxer2.on("trackinfo", function(trackInfo) {
      self2.postMessage({
        action: "trackinfo",
        trackInfo
      });
    });
    transmuxer2.on("audioTimingInfo", function(audioTimingInfo) {
      self2.postMessage({
        action: "audioTimingInfo",
        audioTimingInfo: {
          start: clock.videoTsToSeconds(audioTimingInfo.start),
          end: clock.videoTsToSeconds(audioTimingInfo.end)
        }
      });
    });
    transmuxer2.on("videoTimingInfo", function(videoTimingInfo) {
      self2.postMessage({
        action: "videoTimingInfo",
        videoTimingInfo: {
          start: clock.videoTsToSeconds(videoTimingInfo.start),
          end: clock.videoTsToSeconds(videoTimingInfo.end)
        }
      });
    });
    transmuxer2.on("log", function(log2) {
      self2.postMessage({
        action: "log",
        log: log2
      });
    });
  };
  var MessageHandlers = function() {
    function MessageHandlers2(self2, options) {
      this.options = options || {};
      this.self = self2;
      this.init();
    }
    var _proto = MessageHandlers2.prototype;
    _proto.init = function init() {
      if (this.transmuxer) {
        this.transmuxer.dispose();
      }
      this.transmuxer = new transmuxer.Transmuxer(this.options);
      wireTransmuxerEvents(this.self, this.transmuxer);
    };
    _proto.pushMp4Captions = function pushMp4Captions(data) {
      if (!this.captionParser) {
        this.captionParser = new captionParser();
        this.captionParser.init();
      }
      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
      var parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
      this.self.postMessage({
        action: "mp4Captions",
        captions: parsed && parsed.captions || [],
        logs: parsed && parsed.logs || [],
        data: segment.buffer
      }, [segment.buffer]);
    };
    _proto.probeMp4StartTime = function probeMp4StartTime(_ref) {
      var timescales = _ref.timescales, data = _ref.data;
      var startTime2 = probe$2.startTime(timescales, data);
      this.self.postMessage({
        action: "probeMp4StartTime",
        startTime: startTime2,
        data
      }, [data.buffer]);
    };
    _proto.probeMp4Tracks = function probeMp4Tracks(_ref2) {
      var data = _ref2.data;
      var tracks = probe$2.tracks(data);
      this.self.postMessage({
        action: "probeMp4Tracks",
        tracks,
        data
      }, [data.buffer]);
    };
    _proto.probeTs = function probeTs(_ref3) {
      var data = _ref3.data, baseStartTime = _ref3.baseStartTime;
      var tsStartTime = typeof baseStartTime === "number" && !isNaN(baseStartTime) ? baseStartTime * clock.ONE_SECOND_IN_TS : void 0;
      var timeInfo = tsInspector.inspect(data, tsStartTime);
      var result = null;
      if (timeInfo) {
        result = {
          // each type's time info comes back as an array of 2 times, start and end
          hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
          hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
        };
        if (result.hasVideo) {
          result.videoStart = timeInfo.video[0].ptsTime;
        }
        if (result.hasAudio) {
          result.audioStart = timeInfo.audio[0].ptsTime;
        }
      }
      this.self.postMessage({
        action: "probeTs",
        result,
        data
      }, [data.buffer]);
    };
    _proto.clearAllMp4Captions = function clearAllMp4Captions() {
      if (this.captionParser) {
        this.captionParser.clearAllCaptions();
      }
    };
    _proto.clearParsedMp4Captions = function clearParsedMp4Captions() {
      if (this.captionParser) {
        this.captionParser.clearParsedCaptions();
      }
    };
    _proto.push = function push(data) {
      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
      this.transmuxer.push(segment);
    };
    _proto.reset = function reset3() {
      this.transmuxer.reset();
    };
    _proto.setTimestampOffset = function setTimestampOffset(data) {
      var timestampOffset2 = data.timestampOffset || 0;
      this.transmuxer.setBaseMediaDecodeTime(Math.round(clock.secondsToVideoTs(timestampOffset2)));
    };
    _proto.setAudioAppendStart = function setAudioAppendStart(data) {
      this.transmuxer.setAudioAppendStart(Math.ceil(clock.secondsToVideoTs(data.appendStart)));
    };
    _proto.setRemux = function setRemux(data) {
      this.transmuxer.setRemux(data.remux);
    };
    _proto.flush = function flush(data) {
      this.transmuxer.flush();
      self.postMessage({
        action: "done",
        type: "transmuxed"
      });
    };
    _proto.endTimeline = function endTimeline3() {
      this.transmuxer.endTimeline();
      self.postMessage({
        action: "endedtimeline",
        type: "transmuxed"
      });
    };
    _proto.alignGopsWith = function alignGopsWith(data) {
      this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
    };
    return MessageHandlers2;
  }();
  self.onmessage = function(event) {
    if (event.data.action === "init" && event.data.options) {
      this.messageHandlers = new MessageHandlers(self, event.data.options);
      return;
    }
    if (!this.messageHandlers) {
      this.messageHandlers = new MessageHandlers(self);
    }
    if (event.data && event.data.action && event.data.action !== "init") {
      if (this.messageHandlers[event.data.action]) {
        this.messageHandlers[event.data.action](event.data);
      }
    }
  };
}));
var TransmuxWorker = factory(workerCode$1);
var handleData_ = function handleData_2(event, transmuxedData, callback2) {
  var _event$data$segment = event.data.segment, type2 = _event$data$segment.type, initSegment = _event$data$segment.initSegment, captions = _event$data$segment.captions, captionStreams = _event$data$segment.captionStreams, metadata = _event$data$segment.metadata, videoFrameDtsTime = _event$data$segment.videoFrameDtsTime, videoFramePtsTime = _event$data$segment.videoFramePtsTime;
  transmuxedData.buffer.push({
    captions,
    captionStreams,
    metadata
  });
  var boxes = event.data.segment.boxes || {
    data: event.data.segment.data
  };
  var result = {
    type: type2,
    // cast ArrayBuffer to TypedArray
    data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
    initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
  };
  if (typeof videoFrameDtsTime !== "undefined") {
    result.videoFrameDtsTime = videoFrameDtsTime;
  }
  if (typeof videoFramePtsTime !== "undefined") {
    result.videoFramePtsTime = videoFramePtsTime;
  }
  callback2(result);
};
var handleDone_ = function handleDone_2(_ref) {
  var transmuxedData = _ref.transmuxedData, callback2 = _ref.callback;
  transmuxedData.buffer = [];
  callback2(transmuxedData);
};
var handleGopInfo_ = function handleGopInfo_2(event, transmuxedData) {
  transmuxedData.gopInfo = event.data.gopInfo;
};
var processTransmux = function processTransmux2(options) {
  var transmuxer = options.transmuxer, bytes = options.bytes, audioAppendStart = options.audioAppendStart, gopsToAlignWith = options.gopsToAlignWith, remux = options.remux, onData = options.onData, onTrackInfo = options.onTrackInfo, onAudioTimingInfo = options.onAudioTimingInfo, onVideoTimingInfo = options.onVideoTimingInfo, onVideoSegmentTimingInfo = options.onVideoSegmentTimingInfo, onAudioSegmentTimingInfo = options.onAudioSegmentTimingInfo, onId3 = options.onId3, onCaptions = options.onCaptions, onDone = options.onDone, onEndedTimeline = options.onEndedTimeline, onTransmuxerLog = options.onTransmuxerLog, isEndOfTimeline = options.isEndOfTimeline;
  var transmuxedData = {
    buffer: []
  };
  var waitForEndedTimelineEvent = isEndOfTimeline;
  var handleMessage = function handleMessage2(event) {
    if (transmuxer.currentTransmux !== options) {
      return;
    }
    if (event.data.action === "data") {
      handleData_(event, transmuxedData, onData);
    }
    if (event.data.action === "trackinfo") {
      onTrackInfo(event.data.trackInfo);
    }
    if (event.data.action === "gopInfo") {
      handleGopInfo_(event, transmuxedData);
    }
    if (event.data.action === "audioTimingInfo") {
      onAudioTimingInfo(event.data.audioTimingInfo);
    }
    if (event.data.action === "videoTimingInfo") {
      onVideoTimingInfo(event.data.videoTimingInfo);
    }
    if (event.data.action === "videoSegmentTimingInfo") {
      onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);
    }
    if (event.data.action === "audioSegmentTimingInfo") {
      onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);
    }
    if (event.data.action === "id3Frame") {
      onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);
    }
    if (event.data.action === "caption") {
      onCaptions(event.data.caption);
    }
    if (event.data.action === "endedtimeline") {
      waitForEndedTimelineEvent = false;
      onEndedTimeline();
    }
    if (event.data.action === "log") {
      onTransmuxerLog(event.data.log);
    }
    if (event.data.type !== "transmuxed") {
      return;
    }
    if (waitForEndedTimelineEvent) {
      return;
    }
    transmuxer.onmessage = null;
    handleDone_({
      transmuxedData,
      callback: onDone
    });
    dequeue(transmuxer);
  };
  transmuxer.onmessage = handleMessage;
  if (audioAppendStart) {
    transmuxer.postMessage({
      action: "setAudioAppendStart",
      appendStart: audioAppendStart
    });
  }
  if (Array.isArray(gopsToAlignWith)) {
    transmuxer.postMessage({
      action: "alignGopsWith",
      gopsToAlignWith
    });
  }
  if (typeof remux !== "undefined") {
    transmuxer.postMessage({
      action: "setRemux",
      remux
    });
  }
  if (bytes.byteLength) {
    var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
    var byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
    transmuxer.postMessage({
      action: "push",
      // Send the typed-array of data as an ArrayBuffer so that
      // it can be sent as a "Transferable" and avoid the costly
      // memory copy
      data: buffer,
      // To recreate the original typed-array, we need information
      // about what portion of the ArrayBuffer it was a view into
      byteOffset,
      byteLength: bytes.byteLength
    }, [buffer]);
  }
  if (isEndOfTimeline) {
    transmuxer.postMessage({
      action: "endTimeline"
    });
  }
  transmuxer.postMessage({
    action: "flush"
  });
};
var dequeue = function dequeue2(transmuxer) {
  transmuxer.currentTransmux = null;
  if (transmuxer.transmuxQueue.length) {
    transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
    if (typeof transmuxer.currentTransmux === "function") {
      transmuxer.currentTransmux();
    } else {
      processTransmux(transmuxer.currentTransmux);
    }
  }
};
var processAction = function processAction2(transmuxer, action) {
  transmuxer.postMessage({
    action
  });
  dequeue(transmuxer);
};
var enqueueAction = function enqueueAction2(action, transmuxer) {
  if (!transmuxer.currentTransmux) {
    transmuxer.currentTransmux = action;
    processAction(transmuxer, action);
    return;
  }
  transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
};
var reset = function reset2(transmuxer) {
  enqueueAction("reset", transmuxer);
};
var endTimeline = function endTimeline2(transmuxer) {
  enqueueAction("endTimeline", transmuxer);
};
var transmux = function transmux2(options) {
  if (!options.transmuxer.currentTransmux) {
    options.transmuxer.currentTransmux = options;
    processTransmux(options);
    return;
  }
  options.transmuxer.transmuxQueue.push(options);
};
var createTransmuxer = function createTransmuxer2(options) {
  var transmuxer = new TransmuxWorker();
  transmuxer.currentTransmux = null;
  transmuxer.transmuxQueue = [];
  var term = transmuxer.terminate;
  transmuxer.terminate = function() {
    transmuxer.currentTransmux = null;
    transmuxer.transmuxQueue.length = 0;
    return term.call(transmuxer);
  };
  transmuxer.postMessage({
    action: "init",
    options
  });
  return transmuxer;
};
var segmentTransmuxer = {
  reset,
  endTimeline,
  transmux,
  createTransmuxer
};
var workerCallback = function workerCallback2(options) {
  var transmuxer = options.transmuxer;
  var endAction = options.endAction || options.action;
  var callback2 = options.callback;
  var message = _extends({}, options, {
    endAction: null,
    transmuxer: null,
    callback: null
  });
  var listenForEndEvent = function listenForEndEvent2(event) {
    if (event.data.action !== endAction) {
      return;
    }
    transmuxer.removeEventListener("message", listenForEndEvent2);
    if (event.data.data) {
      event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);
      if (options.data) {
        options.data = event.data.data;
      }
    }
    callback2(event.data);
  };
  transmuxer.addEventListener("message", listenForEndEvent);
  if (options.data) {
    var isArrayBuffer = options.data instanceof ArrayBuffer;
    message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;
    message.byteLength = options.data.byteLength;
    var transfers = [isArrayBuffer ? options.data : options.data.buffer];
    transmuxer.postMessage(message, transfers);
  } else {
    transmuxer.postMessage(message);
  }
};
var REQUEST_ERRORS = {
  FAILURE: 2,
  TIMEOUT: -101,
  ABORTED: -102
};
var abortAll = function abortAll2(activeXhrs) {
  activeXhrs.forEach(function(xhr) {
    xhr.abort();
  });
};
var getRequestStats = function getRequestStats2(request) {
  return {
    bandwidth: request.bandwidth,
    bytesReceived: request.bytesReceived || 0,
    roundTripTime: request.roundTripTime || 0
  };
};
var getProgressStats = function getProgressStats2(progressEvent) {
  var request = progressEvent.target;
  var roundTripTime = Date.now() - request.requestTime;
  var stats = {
    bandwidth: Infinity,
    bytesReceived: 0,
    roundTripTime: roundTripTime || 0
  };
  stats.bytesReceived = progressEvent.loaded;
  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1e3);
  return stats;
};
var handleErrors = function handleErrors2(error, request) {
  if (request.timedout) {
    return {
      status: request.status,
      message: "HLS request timed-out at URL: " + request.uri,
      code: REQUEST_ERRORS.TIMEOUT,
      xhr: request
    };
  }
  if (request.aborted) {
    return {
      status: request.status,
      message: "HLS request aborted at URL: " + request.uri,
      code: REQUEST_ERRORS.ABORTED,
      xhr: request
    };
  }
  if (error) {
    return {
      status: request.status,
      message: "HLS request errored at URL: " + request.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request
    };
  }
  if (request.responseType === "arraybuffer" && request.response.byteLength === 0) {
    return {
      status: request.status,
      message: "Empty HLS response at URL: " + request.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request
    };
  }
  return null;
};
var handleKeyResponse = function handleKeyResponse2(segment, objects, finishProcessingFn) {
  return function(error, request) {
    var response = request.response;
    var errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    if (response.byteLength !== 16) {
      return finishProcessingFn({
        status: request.status,
        message: "Invalid HLS key at URL: " + request.uri,
        code: REQUEST_ERRORS.FAILURE,
        xhr: request
      }, segment);
    }
    var view = new DataView(response);
    var bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);
    for (var i = 0; i < objects.length; i++) {
      objects[i].bytes = bytes;
    }
    return finishProcessingFn(null, segment);
  };
};
var parseInitSegment = function parseInitSegment2(segment, _callback) {
  var type2 = detectContainerForBytes(segment.map.bytes);
  if (type2 !== "mp4") {
    var uri = segment.map.resolvedUri || segment.map.uri;
    return _callback({
      internal: true,
      message: "Found unsupported " + (type2 || "unknown") + " container for initialization segment at URL: " + uri,
      code: REQUEST_ERRORS.FAILURE
    });
  }
  workerCallback({
    action: "probeMp4Tracks",
    data: segment.map.bytes,
    transmuxer: segment.transmuxer,
    callback: function callback2(_ref) {
      var tracks = _ref.tracks, data = _ref.data;
      segment.map.bytes = data;
      tracks.forEach(function(track) {
        segment.map.tracks = segment.map.tracks || {};
        if (segment.map.tracks[track.type]) {
          return;
        }
        segment.map.tracks[track.type] = track;
        if (typeof track.id === "number" && track.timescale) {
          segment.map.timescales = segment.map.timescales || {};
          segment.map.timescales[track.id] = track.timescale;
        }
      });
      return _callback(null);
    }
  });
};
var handleInitSegmentResponse = function handleInitSegmentResponse2(_ref2) {
  var segment = _ref2.segment, finishProcessingFn = _ref2.finishProcessingFn;
  return function(error, request) {
    var errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    var bytes = new Uint8Array(request.response);
    if (segment.map.key) {
      segment.map.encryptedBytes = bytes;
      return finishProcessingFn(null, segment);
    }
    segment.map.bytes = bytes;
    parseInitSegment(segment, function(parseError) {
      if (parseError) {
        parseError.xhr = request;
        parseError.status = request.status;
        return finishProcessingFn(parseError, segment);
      }
      finishProcessingFn(null, segment);
    });
  };
};
var handleSegmentResponse = function handleSegmentResponse2(_ref3) {
  var segment = _ref3.segment, finishProcessingFn = _ref3.finishProcessingFn, responseType = _ref3.responseType;
  return function(error, request) {
    var errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    var newBytes = (
      // although responseText "should" exist, this guard serves to prevent an error being
      // thrown for two primary cases:
      // 1. the mime type override stops working, or is not implemented for a specific
      //    browser
      // 2. when using mock XHR libraries like sinon that do not allow the override behavior
      responseType === "arraybuffer" || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0))
    );
    segment.stats = getRequestStats(request);
    if (segment.key) {
      segment.encryptedBytes = new Uint8Array(newBytes);
    } else {
      segment.bytes = new Uint8Array(newBytes);
    }
    return finishProcessingFn(null, segment);
  };
};
var transmuxAndNotify = function transmuxAndNotify2(_ref4) {
  var segment = _ref4.segment, bytes = _ref4.bytes, trackInfoFn = _ref4.trackInfoFn, timingInfoFn = _ref4.timingInfoFn, videoSegmentTimingInfoFn = _ref4.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref4.audioSegmentTimingInfoFn, id3Fn = _ref4.id3Fn, captionsFn = _ref4.captionsFn, isEndOfTimeline = _ref4.isEndOfTimeline, endedTimelineFn = _ref4.endedTimelineFn, dataFn = _ref4.dataFn, doneFn = _ref4.doneFn, onTransmuxerLog = _ref4.onTransmuxerLog;
  var fmp4Tracks = segment.map && segment.map.tracks || {};
  var isMuxed3 = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
  var audioStartFn = timingInfoFn.bind(null, segment, "audio", "start");
  var audioEndFn = timingInfoFn.bind(null, segment, "audio", "end");
  var videoStartFn = timingInfoFn.bind(null, segment, "video", "start");
  var videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
  var finish = function finish2() {
    return transmux({
      bytes,
      transmuxer: segment.transmuxer,
      audioAppendStart: segment.audioAppendStart,
      gopsToAlignWith: segment.gopsToAlignWith,
      remux: isMuxed3,
      onData: function onData(result) {
        result.type = result.type === "combined" ? "video" : result.type;
        dataFn(segment, result);
      },
      onTrackInfo: function onTrackInfo(trackInfo) {
        if (trackInfoFn) {
          if (isMuxed3) {
            trackInfo.isMuxed = true;
          }
          trackInfoFn(segment, trackInfo);
        }
      },
      onAudioTimingInfo: function onAudioTimingInfo(audioTimingInfo) {
        if (audioStartFn && typeof audioTimingInfo.start !== "undefined") {
          audioStartFn(audioTimingInfo.start);
          audioStartFn = null;
        }
        if (audioEndFn && typeof audioTimingInfo.end !== "undefined") {
          audioEndFn(audioTimingInfo.end);
        }
      },
      onVideoTimingInfo: function onVideoTimingInfo(videoTimingInfo) {
        if (videoStartFn && typeof videoTimingInfo.start !== "undefined") {
          videoStartFn(videoTimingInfo.start);
          videoStartFn = null;
        }
        if (videoEndFn && typeof videoTimingInfo.end !== "undefined") {
          videoEndFn(videoTimingInfo.end);
        }
      },
      onVideoSegmentTimingInfo: function onVideoSegmentTimingInfo(videoSegmentTimingInfo) {
        videoSegmentTimingInfoFn(videoSegmentTimingInfo);
      },
      onAudioSegmentTimingInfo: function onAudioSegmentTimingInfo(audioSegmentTimingInfo) {
        audioSegmentTimingInfoFn(audioSegmentTimingInfo);
      },
      onId3: function onId3(id3Frames, dispatchType) {
        id3Fn(segment, id3Frames, dispatchType);
      },
      onCaptions: function onCaptions(captions) {
        captionsFn(segment, [captions]);
      },
      isEndOfTimeline,
      onEndedTimeline: function onEndedTimeline() {
        endedTimelineFn();
      },
      onTransmuxerLog,
      onDone: function onDone(result) {
        if (!doneFn) {
          return;
        }
        result.type = result.type === "combined" ? "video" : result.type;
        doneFn(null, segment, result);
      }
    });
  };
  workerCallback({
    action: "probeTs",
    transmuxer: segment.transmuxer,
    data: bytes,
    baseStartTime: segment.baseStartTime,
    callback: function callback2(data) {
      segment.bytes = bytes = data.data;
      var probeResult = data.result;
      if (probeResult) {
        trackInfoFn(segment, {
          hasAudio: probeResult.hasAudio,
          hasVideo: probeResult.hasVideo,
          isMuxed: isMuxed3
        });
        trackInfoFn = null;
        if (probeResult.hasAudio && !isMuxed3) {
          audioStartFn(probeResult.audioStart);
        }
        if (probeResult.hasVideo) {
          videoStartFn(probeResult.videoStart);
        }
        audioStartFn = null;
        videoStartFn = null;
      }
      finish();
    }
  });
};
var handleSegmentBytes = function handleSegmentBytes2(_ref5) {
  var segment = _ref5.segment, bytes = _ref5.bytes, trackInfoFn = _ref5.trackInfoFn, timingInfoFn = _ref5.timingInfoFn, videoSegmentTimingInfoFn = _ref5.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref5.audioSegmentTimingInfoFn, id3Fn = _ref5.id3Fn, captionsFn = _ref5.captionsFn, isEndOfTimeline = _ref5.isEndOfTimeline, endedTimelineFn = _ref5.endedTimelineFn, dataFn = _ref5.dataFn, doneFn = _ref5.doneFn, onTransmuxerLog = _ref5.onTransmuxerLog;
  var bytesAsUint8Array = new Uint8Array(bytes);
  if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
    segment.isFmp4 = true;
    var tracks = segment.map.tracks;
    var trackInfo = {
      isFmp4: true,
      hasVideo: !!tracks.video,
      hasAudio: !!tracks.audio
    };
    if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== "enca") {
      trackInfo.audioCodec = tracks.audio.codec;
    }
    if (tracks.video && tracks.video.codec && tracks.video.codec !== "encv") {
      trackInfo.videoCodec = tracks.video.codec;
    }
    if (tracks.video && tracks.audio) {
      trackInfo.isMuxed = true;
    }
    trackInfoFn(segment, trackInfo);
    var finishLoading = function finishLoading2(captions) {
      dataFn(segment, {
        data: bytesAsUint8Array,
        type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
      });
      if (captions && captions.length) {
        captionsFn(segment, captions);
      }
      doneFn(null, segment, {});
    };
    workerCallback({
      action: "probeMp4StartTime",
      timescales: segment.map.timescales,
      data: bytesAsUint8Array,
      transmuxer: segment.transmuxer,
      callback: function callback2(_ref6) {
        var data = _ref6.data, startTime = _ref6.startTime;
        bytes = data.buffer;
        segment.bytes = bytesAsUint8Array = data;
        if (trackInfo.hasAudio && !trackInfo.isMuxed) {
          timingInfoFn(segment, "audio", "start", startTime);
        }
        if (trackInfo.hasVideo) {
          timingInfoFn(segment, "video", "start", startTime);
        }
        if (!tracks.video || !data.byteLength || !segment.transmuxer) {
          finishLoading();
          return;
        }
        workerCallback({
          action: "pushMp4Captions",
          endAction: "mp4Captions",
          transmuxer: segment.transmuxer,
          data: bytesAsUint8Array,
          timescales: segment.map.timescales,
          trackIds: [tracks.video.id],
          callback: function callback3(message) {
            bytes = message.data.buffer;
            segment.bytes = bytesAsUint8Array = message.data;
            message.logs.forEach(function(log2) {
              onTransmuxerLog(videojs.mergeOptions(log2, {
                stream: "mp4CaptionParser"
              }));
            });
            finishLoading(message.captions);
          }
        });
      }
    });
    return;
  }
  if (!segment.transmuxer) {
    doneFn(null, segment, {});
    return;
  }
  if (typeof segment.container === "undefined") {
    segment.container = detectContainerForBytes(bytesAsUint8Array);
  }
  if (segment.container !== "ts" && segment.container !== "aac") {
    trackInfoFn(segment, {
      hasAudio: false,
      hasVideo: false
    });
    doneFn(null, segment, {});
    return;
  }
  transmuxAndNotify({
    segment,
    bytes,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  });
};
var decrypt = function decrypt2(_ref7, callback2) {
  var id = _ref7.id, key = _ref7.key, encryptedBytes = _ref7.encryptedBytes, decryptionWorker = _ref7.decryptionWorker;
  var decryptionHandler = function decryptionHandler2(event) {
    if (event.data.source === id) {
      decryptionWorker.removeEventListener("message", decryptionHandler2);
      var decrypted = event.data.decrypted;
      callback2(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
    }
  };
  decryptionWorker.addEventListener("message", decryptionHandler);
  var keyBytes;
  if (key.bytes.slice) {
    keyBytes = key.bytes.slice();
  } else {
    keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
  }
  decryptionWorker.postMessage(createTransferableMessage({
    source: id,
    encrypted: encryptedBytes,
    key: keyBytes,
    iv: key.iv
  }), [encryptedBytes.buffer, keyBytes.buffer]);
};
var decryptSegment = function decryptSegment2(_ref8) {
  var decryptionWorker = _ref8.decryptionWorker, segment = _ref8.segment, trackInfoFn = _ref8.trackInfoFn, timingInfoFn = _ref8.timingInfoFn, videoSegmentTimingInfoFn = _ref8.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref8.audioSegmentTimingInfoFn, id3Fn = _ref8.id3Fn, captionsFn = _ref8.captionsFn, isEndOfTimeline = _ref8.isEndOfTimeline, endedTimelineFn = _ref8.endedTimelineFn, dataFn = _ref8.dataFn, doneFn = _ref8.doneFn, onTransmuxerLog = _ref8.onTransmuxerLog;
  decrypt({
    id: segment.requestId,
    key: segment.key,
    encryptedBytes: segment.encryptedBytes,
    decryptionWorker
  }, function(decryptedBytes) {
    segment.bytes = decryptedBytes;
    handleSegmentBytes({
      segment,
      bytes: segment.bytes,
      trackInfoFn,
      timingInfoFn,
      videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn,
      id3Fn,
      captionsFn,
      isEndOfTimeline,
      endedTimelineFn,
      dataFn,
      doneFn,
      onTransmuxerLog
    });
  });
};
var waitForCompletion = function waitForCompletion2(_ref9) {
  var activeXhrs = _ref9.activeXhrs, decryptionWorker = _ref9.decryptionWorker, trackInfoFn = _ref9.trackInfoFn, timingInfoFn = _ref9.timingInfoFn, videoSegmentTimingInfoFn = _ref9.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref9.audioSegmentTimingInfoFn, id3Fn = _ref9.id3Fn, captionsFn = _ref9.captionsFn, isEndOfTimeline = _ref9.isEndOfTimeline, endedTimelineFn = _ref9.endedTimelineFn, dataFn = _ref9.dataFn, doneFn = _ref9.doneFn, onTransmuxerLog = _ref9.onTransmuxerLog;
  var count = 0;
  var didError = false;
  return function(error, segment) {
    if (didError) {
      return;
    }
    if (error) {
      didError = true;
      abortAll(activeXhrs);
      return doneFn(error, segment);
    }
    count += 1;
    if (count === activeXhrs.length) {
      var segmentFinish = function segmentFinish2() {
        if (segment.encryptedBytes) {
          return decryptSegment({
            decryptionWorker,
            segment,
            trackInfoFn,
            timingInfoFn,
            videoSegmentTimingInfoFn,
            audioSegmentTimingInfoFn,
            id3Fn,
            captionsFn,
            isEndOfTimeline,
            endedTimelineFn,
            dataFn,
            doneFn,
            onTransmuxerLog
          });
        }
        handleSegmentBytes({
          segment,
          bytes: segment.bytes,
          trackInfoFn,
          timingInfoFn,
          videoSegmentTimingInfoFn,
          audioSegmentTimingInfoFn,
          id3Fn,
          captionsFn,
          isEndOfTimeline,
          endedTimelineFn,
          dataFn,
          doneFn,
          onTransmuxerLog
        });
      };
      segment.endOfAllRequests = Date.now();
      if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {
        return decrypt({
          decryptionWorker,
          // add -init to the "id" to differentiate between segment
          // and init segment decryption, just in case they happen
          // at the same time at some point in the future.
          id: segment.requestId + "-init",
          encryptedBytes: segment.map.encryptedBytes,
          key: segment.map.key
        }, function(decryptedBytes) {
          segment.map.bytes = decryptedBytes;
          parseInitSegment(segment, function(parseError) {
            if (parseError) {
              abortAll(activeXhrs);
              return doneFn(parseError, segment);
            }
            segmentFinish();
          });
        });
      }
      segmentFinish();
    }
  };
};
var handleLoadEnd = function handleLoadEnd2(_ref10) {
  var loadendState = _ref10.loadendState, abortFn = _ref10.abortFn;
  return function(event) {
    var request = event.target;
    if (request.aborted && abortFn && !loadendState.calledAbortFn) {
      abortFn();
      loadendState.calledAbortFn = true;
    }
  };
};
var handleProgress = function handleProgress2(_ref11) {
  var segment = _ref11.segment, progressFn = _ref11.progressFn;
  _ref11.trackInfoFn;
  _ref11.timingInfoFn;
  _ref11.videoSegmentTimingInfoFn;
  _ref11.audioSegmentTimingInfoFn;
  _ref11.id3Fn;
  _ref11.captionsFn;
  _ref11.isEndOfTimeline;
  _ref11.endedTimelineFn;
  _ref11.dataFn;
  return function(event) {
    var request = event.target;
    if (request.aborted) {
      return;
    }
    segment.stats = videojs.mergeOptions(segment.stats, getProgressStats(event));
    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {
      segment.stats.firstBytesReceivedAt = Date.now();
    }
    return progressFn(event, segment);
  };
};
var mediaSegmentRequest = function mediaSegmentRequest2(_ref12) {
  var xhr = _ref12.xhr, xhrOptions = _ref12.xhrOptions, decryptionWorker = _ref12.decryptionWorker, segment = _ref12.segment, abortFn = _ref12.abortFn, progressFn = _ref12.progressFn, trackInfoFn = _ref12.trackInfoFn, timingInfoFn = _ref12.timingInfoFn, videoSegmentTimingInfoFn = _ref12.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref12.audioSegmentTimingInfoFn, id3Fn = _ref12.id3Fn, captionsFn = _ref12.captionsFn, isEndOfTimeline = _ref12.isEndOfTimeline, endedTimelineFn = _ref12.endedTimelineFn, dataFn = _ref12.dataFn, doneFn = _ref12.doneFn, onTransmuxerLog = _ref12.onTransmuxerLog;
  var activeXhrs = [];
  var finishProcessingFn = waitForCompletion({
    activeXhrs,
    decryptionWorker,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  });
  if (segment.key && !segment.key.bytes) {
    var objects = [segment.key];
    if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {
      objects.push(segment.map.key);
    }
    var keyRequestOptions = videojs.mergeOptions(xhrOptions, {
      uri: segment.key.resolvedUri,
      responseType: "arraybuffer"
    });
    var keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);
    var keyXhr = xhr(keyRequestOptions, keyRequestCallback);
    activeXhrs.push(keyXhr);
  }
  if (segment.map && !segment.map.bytes) {
    var differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
    if (differentMapKey) {
      var mapKeyRequestOptions = videojs.mergeOptions(xhrOptions, {
        uri: segment.map.key.resolvedUri,
        responseType: "arraybuffer"
      });
      var mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);
      var mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
      activeXhrs.push(mapKeyXhr);
    }
    var initSegmentOptions = videojs.mergeOptions(xhrOptions, {
      uri: segment.map.resolvedUri,
      responseType: "arraybuffer",
      headers: segmentXhrHeaders(segment.map)
    });
    var initSegmentRequestCallback = handleInitSegmentResponse({
      segment,
      finishProcessingFn
    });
    var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
    activeXhrs.push(initSegmentXhr);
  }
  var segmentRequestOptions = videojs.mergeOptions(xhrOptions, {
    uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
    responseType: "arraybuffer",
    headers: segmentXhrHeaders(segment)
  });
  var segmentRequestCallback = handleSegmentResponse({
    segment,
    finishProcessingFn,
    responseType: segmentRequestOptions.responseType
  });
  var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
  segmentXhr.addEventListener("progress", handleProgress({
    segment,
    progressFn,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn
  }));
  activeXhrs.push(segmentXhr);
  var loadendState = {};
  activeXhrs.forEach(function(activeXhr) {
    activeXhr.addEventListener("loadend", handleLoadEnd({
      loadendState,
      abortFn
    }));
  });
  return function() {
    return abortAll(activeXhrs);
  };
};
var logFn$1 = logger("CodecUtils");
var getCodecs = function getCodecs2(media) {
  var mediaAttributes = media.attributes || {};
  if (mediaAttributes.CODECS) {
    return parseCodecs(mediaAttributes.CODECS);
  }
};
var isMaat = function isMaat2(master, media) {
  var mediaAttributes = media.attributes || {};
  return master && master.mediaGroups && master.mediaGroups.AUDIO && mediaAttributes.AUDIO && master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
};
var isMuxed = function isMuxed2(master, media) {
  if (!isMaat(master, media)) {
    return true;
  }
  var mediaAttributes = media.attributes || {};
  var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
  for (var groupId in audioGroup) {
    if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {
      return true;
    }
  }
  return false;
};
var unwrapCodecList = function unwrapCodecList2(codecList) {
  var codecs = {};
  codecList.forEach(function(_ref) {
    var mediaType = _ref.mediaType, type2 = _ref.type, details = _ref.details;
    codecs[mediaType] = codecs[mediaType] || [];
    codecs[mediaType].push(translateLegacyCodec("" + type2 + details));
  });
  Object.keys(codecs).forEach(function(mediaType) {
    if (codecs[mediaType].length > 1) {
      logFn$1("multiple " + mediaType + " codecs found as attributes: " + codecs[mediaType].join(", ") + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.");
      codecs[mediaType] = null;
      return;
    }
    codecs[mediaType] = codecs[mediaType][0];
  });
  return codecs;
};
var codecCount = function codecCount2(codecObj) {
  var count = 0;
  if (codecObj.audio) {
    count++;
  }
  if (codecObj.video) {
    count++;
  }
  return count;
};
var codecsForPlaylist = function codecsForPlaylist2(master, media) {
  var mediaAttributes = media.attributes || {};
  var codecInfo = unwrapCodecList(getCodecs(media) || []);
  if (isMaat(master, media) && !codecInfo.audio) {
    if (!isMuxed(master, media)) {
      var defaultCodecs = unwrapCodecList(codecsFromDefault(master, mediaAttributes.AUDIO) || []);
      if (defaultCodecs.audio) {
        codecInfo.audio = defaultCodecs.audio;
      }
    }
  }
  return codecInfo;
};
var logFn = logger("PlaylistSelector");
var representationToString = function representationToString2(representation) {
  if (!representation || !representation.playlist) {
    return;
  }
  var playlist = representation.playlist;
  return JSON.stringify({
    id: playlist.id,
    bandwidth: representation.bandwidth,
    width: representation.width,
    height: representation.height,
    codecs: playlist.attributes && playlist.attributes.CODECS || ""
  });
};
var safeGetComputedStyle = function safeGetComputedStyle2(el, property) {
  if (!el) {
    return "";
  }
  var result = import_window6.default.getComputedStyle(el);
  if (!result) {
    return "";
  }
  return result[property];
};
var stableSort = function stableSort2(array, sortFn) {
  var newArray = array.slice();
  array.sort(function(left, right) {
    var cmp = sortFn(left, right);
    if (cmp === 0) {
      return newArray.indexOf(left) - newArray.indexOf(right);
    }
    return cmp;
  });
};
var comparePlaylistBandwidth = function comparePlaylistBandwidth2(left, right) {
  var leftBandwidth;
  var rightBandwidth;
  if (left.attributes.BANDWIDTH) {
    leftBandwidth = left.attributes.BANDWIDTH;
  }
  leftBandwidth = leftBandwidth || import_window6.default.Number.MAX_VALUE;
  if (right.attributes.BANDWIDTH) {
    rightBandwidth = right.attributes.BANDWIDTH;
  }
  rightBandwidth = rightBandwidth || import_window6.default.Number.MAX_VALUE;
  return leftBandwidth - rightBandwidth;
};
var comparePlaylistResolution = function comparePlaylistResolution2(left, right) {
  var leftWidth;
  var rightWidth;
  if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {
    leftWidth = left.attributes.RESOLUTION.width;
  }
  leftWidth = leftWidth || import_window6.default.Number.MAX_VALUE;
  if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {
    rightWidth = right.attributes.RESOLUTION.width;
  }
  rightWidth = rightWidth || import_window6.default.Number.MAX_VALUE;
  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {
    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;
  }
  return leftWidth - rightWidth;
};
var simpleSelector = function simpleSelector2(master, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, masterPlaylistController) {
  if (!master) {
    return;
  }
  var options = {
    bandwidth: playerBandwidth,
    width: playerWidth,
    height: playerHeight,
    limitRenditionByPlayerDimensions
  };
  var playlists = master.playlists;
  if (Playlist.isAudioOnly(master)) {
    playlists = masterPlaylistController.getAudioTrackPlaylists_();
    options.audioOnly = true;
  }
  var sortedPlaylistReps = playlists.map(function(playlist) {
    var bandwidth2;
    var width2 = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
    var height2 = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
    bandwidth2 = playlist.attributes && playlist.attributes.BANDWIDTH;
    bandwidth2 = bandwidth2 || import_window6.default.Number.MAX_VALUE;
    return {
      bandwidth: bandwidth2,
      width: width2,
      height: height2,
      playlist
    };
  });
  stableSort(sortedPlaylistReps, function(left, right) {
    return left.bandwidth - right.bandwidth;
  });
  sortedPlaylistReps = sortedPlaylistReps.filter(function(rep) {
    return !Playlist.isIncompatible(rep.playlist);
  });
  var enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
    return Playlist.isEnabled(rep.playlist);
  });
  if (!enabledPlaylistReps.length) {
    enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
      return !Playlist.isDisabled(rep.playlist);
    });
  }
  var bandwidthPlaylistReps = enabledPlaylistReps.filter(function(rep) {
    return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;
  });
  var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
  var bandwidthBestRep = bandwidthPlaylistReps.filter(function(rep) {
    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
  })[0];
  if (limitRenditionByPlayerDimensions === false) {
    var _chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
    if (_chosenRep && _chosenRep.playlist) {
      var type2 = "sortedPlaylistReps";
      if (bandwidthBestRep) {
        type2 = "bandwidthBestRep";
      }
      if (enabledPlaylistReps[0]) {
        type2 = "enabledPlaylistReps";
      }
      logFn("choosing " + representationToString(_chosenRep) + " using " + type2 + " with options", options);
      return _chosenRep.playlist;
    }
    logFn("could not choose a playlist with options", options);
    return null;
  }
  var haveResolution = bandwidthPlaylistReps.filter(function(rep) {
    return rep.width && rep.height;
  });
  stableSort(haveResolution, function(left, right) {
    return left.width - right.width;
  });
  var resolutionBestRepList = haveResolution.filter(function(rep) {
    return rep.width === playerWidth && rep.height === playerHeight;
  });
  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
  var resolutionBestRep = resolutionBestRepList.filter(function(rep) {
    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
  })[0];
  var resolutionPlusOneList;
  var resolutionPlusOneSmallest;
  var resolutionPlusOneRep;
  if (!resolutionBestRep) {
    resolutionPlusOneList = haveResolution.filter(function(rep) {
      return rep.width > playerWidth || rep.height > playerHeight;
    });
    resolutionPlusOneSmallest = resolutionPlusOneList.filter(function(rep) {
      return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;
    });
    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
    resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function(rep) {
      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
    })[0];
  }
  var leastPixelDiffRep;
  if (masterPlaylistController.experimentalLeastPixelDiffSelector) {
    var leastPixelDiffList = haveResolution.map(function(rep) {
      rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
      return rep;
    });
    stableSort(leastPixelDiffList, function(left, right) {
      if (left.pixelDiff === right.pixelDiff) {
        return right.bandwidth - left.bandwidth;
      }
      return left.pixelDiff - right.pixelDiff;
    });
    leastPixelDiffRep = leastPixelDiffList[0];
  }
  var chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
  if (chosenRep && chosenRep.playlist) {
    var _type = "sortedPlaylistReps";
    if (leastPixelDiffRep) {
      _type = "leastPixelDiffRep";
    } else if (resolutionPlusOneRep) {
      _type = "resolutionPlusOneRep";
    } else if (resolutionBestRep) {
      _type = "resolutionBestRep";
    } else if (bandwidthBestRep) {
      _type = "bandwidthBestRep";
    } else if (enabledPlaylistReps[0]) {
      _type = "enabledPlaylistReps";
    }
    logFn("choosing " + representationToString(chosenRep) + " using " + _type + " with options", options);
    return chosenRep.playlist;
  }
  logFn("could not choose a playlist with options", options);
  return null;
};
var lastBandwidthSelector = function lastBandwidthSelector2() {
  var pixelRatio = this.useDevicePixelRatio ? import_window6.default.devicePixelRatio || 1 : 1;
  return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
};
var movingAverageBandwidthSelector = function movingAverageBandwidthSelector2(decay) {
  var average = -1;
  var lastSystemBandwidth = -1;
  if (decay < 0 || decay > 1) {
    throw new Error("Moving average bandwidth decay must be between 0 and 1.");
  }
  return function() {
    var pixelRatio = this.useDevicePixelRatio ? import_window6.default.devicePixelRatio || 1 : 1;
    if (average < 0) {
      average = this.systemBandwidth;
      lastSystemBandwidth = this.systemBandwidth;
    }
    if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
      average = decay * this.systemBandwidth + (1 - decay) * average;
      lastSystemBandwidth = this.systemBandwidth;
    }
    return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
  };
};
var minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector2(settings) {
  var master = settings.master, currentTime = settings.currentTime, bandwidth2 = settings.bandwidth, duration5 = settings.duration, segmentDuration = settings.segmentDuration, timeUntilRebuffer3 = settings.timeUntilRebuffer, currentTimeline = settings.currentTimeline, syncController = settings.syncController;
  var compatiblePlaylists = master.playlists.filter(function(playlist) {
    return !Playlist.isIncompatible(playlist);
  });
  var enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);
  if (!enabledPlaylists.length) {
    enabledPlaylists = compatiblePlaylists.filter(function(playlist) {
      return !Playlist.isDisabled(playlist);
    });
  }
  var bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, "BANDWIDTH"));
  var rebufferingEstimates = bandwidthPlaylists.map(function(playlist) {
    var syncPoint = syncController.getSyncPoint(playlist, duration5, currentTimeline, currentTime);
    var numRequests = syncPoint ? 1 : 2;
    var requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth2, playlist);
    var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer3;
    return {
      playlist,
      rebufferingImpact
    };
  });
  var noRebufferingPlaylists = rebufferingEstimates.filter(function(estimate) {
    return estimate.rebufferingImpact <= 0;
  });
  stableSort(noRebufferingPlaylists, function(a, b2) {
    return comparePlaylistBandwidth(b2.playlist, a.playlist);
  });
  if (noRebufferingPlaylists.length) {
    return noRebufferingPlaylists[0];
  }
  stableSort(rebufferingEstimates, function(a, b2) {
    return a.rebufferingImpact - b2.rebufferingImpact;
  });
  return rebufferingEstimates[0] || null;
};
var lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector2() {
  var _this = this;
  var playlists = this.playlists.master.playlists.filter(Playlist.isEnabled);
  stableSort(playlists, function(a, b2) {
    return comparePlaylistBandwidth(a, b2);
  });
  var playlistsWithVideo = playlists.filter(function(playlist) {
    return !!codecsForPlaylist(_this.playlists.master, playlist).video;
  });
  return playlistsWithVideo[0] || null;
};
var concatSegments = function concatSegments2(segmentObj) {
  var offset = 0;
  var tempBuffer;
  if (segmentObj.bytes) {
    tempBuffer = new Uint8Array(segmentObj.bytes);
    segmentObj.segments.forEach(function(segment) {
      tempBuffer.set(segment, offset);
      offset += segment.byteLength;
    });
  }
  return tempBuffer;
};
var createCaptionsTrackIfNotExists = function createCaptionsTrackIfNotExists2(inbandTextTracks, tech, captionStream) {
  if (!inbandTextTracks[captionStream]) {
    tech.trigger({
      type: "usage",
      name: "vhs-608"
    });
    tech.trigger({
      type: "usage",
      name: "hls-608"
    });
    var instreamId = captionStream;
    if (/^cc708_/.test(captionStream)) {
      instreamId = "SERVICE" + captionStream.split("_")[1];
    }
    var track = tech.textTracks().getTrackById(instreamId);
    if (track) {
      inbandTextTracks[captionStream] = track;
    } else {
      var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
      var label = captionStream;
      var language = captionStream;
      var def = false;
      var captionService = captionServices[instreamId];
      if (captionService) {
        label = captionService.label;
        language = captionService.language;
        def = captionService["default"];
      }
      inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
        kind: "captions",
        id: instreamId,
        // TODO: investigate why this doesn't seem to turn the caption on by default
        "default": def,
        label,
        language
      }, false).track;
    }
  }
};
var addCaptionData = function addCaptionData2(_ref) {
  var inbandTextTracks = _ref.inbandTextTracks, captionArray = _ref.captionArray, timestampOffset2 = _ref.timestampOffset;
  if (!captionArray) {
    return;
  }
  var Cue = import_window6.default.WebKitDataCue || import_window6.default.VTTCue;
  captionArray.forEach(function(caption) {
    var track = caption.stream;
    inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset2, caption.endTime + timestampOffset2, caption.text));
  });
};
var deprecateOldCue = function deprecateOldCue2(cue) {
  Object.defineProperties(cue.frame, {
    id: {
      get: function get7() {
        videojs.log.warn("cue.frame.id is deprecated. Use cue.value.key instead.");
        return cue.value.key;
      }
    },
    value: {
      get: function get7() {
        videojs.log.warn("cue.frame.value is deprecated. Use cue.value.data instead.");
        return cue.value.data;
      }
    },
    privateData: {
      get: function get7() {
        videojs.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead.");
        return cue.value.data;
      }
    }
  });
};
var addMetadata = function addMetadata2(_ref2) {
  var inbandTextTracks = _ref2.inbandTextTracks, metadataArray = _ref2.metadataArray, timestampOffset2 = _ref2.timestampOffset, videoDuration = _ref2.videoDuration;
  if (!metadataArray) {
    return;
  }
  var Cue = import_window6.default.WebKitDataCue || import_window6.default.VTTCue;
  var metadataTrack = inbandTextTracks.metadataTrack_;
  if (!metadataTrack) {
    return;
  }
  metadataArray.forEach(function(metadata) {
    var time = metadata.cueTime + timestampOffset2;
    if (typeof time !== "number" || import_window6.default.isNaN(time) || time < 0 || !(time < Infinity)) {
      return;
    }
    metadata.frames.forEach(function(frame) {
      var cue = new Cue(time, time, frame.value || frame.url || frame.data || "");
      cue.frame = frame;
      cue.value = frame;
      deprecateOldCue(cue);
      metadataTrack.addCue(cue);
    });
  });
  if (!metadataTrack.cues || !metadataTrack.cues.length) {
    return;
  }
  var cues = metadataTrack.cues;
  var cuesArray = [];
  for (var i = 0; i < cues.length; i++) {
    if (cues[i]) {
      cuesArray.push(cues[i]);
    }
  }
  var cuesGroupedByStartTime = cuesArray.reduce(function(obj, cue) {
    var timeSlot = obj[cue.startTime] || [];
    timeSlot.push(cue);
    obj[cue.startTime] = timeSlot;
    return obj;
  }, {});
  var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function(a, b2) {
    return Number(a) - Number(b2);
  });
  sortedStartTimes.forEach(function(startTime, idx) {
    var cueGroup = cuesGroupedByStartTime[startTime];
    var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;
    cueGroup.forEach(function(cue) {
      cue.endTime = nextTime;
    });
  });
};
var createMetadataTrackIfNotExists = function createMetadataTrackIfNotExists2(inbandTextTracks, dispatchType, tech) {
  if (inbandTextTracks.metadataTrack_) {
    return;
  }
  inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
    kind: "metadata",
    label: "Timed Metadata"
  }, false).track;
  inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
};
var removeCuesFromTrack = function removeCuesFromTrack2(start2, end, track) {
  var i;
  var cue;
  if (!track) {
    return;
  }
  if (!track.cues) {
    return;
  }
  i = track.cues.length;
  while (i--) {
    cue = track.cues[i];
    if (cue.startTime >= start2 && cue.endTime <= end) {
      track.removeCue(cue);
    }
  }
};
var removeDuplicateCuesFromTrack = function removeDuplicateCuesFromTrack2(track) {
  var cues = track.cues;
  if (!cues) {
    return;
  }
  for (var i = 0; i < cues.length; i++) {
    var duplicates = [];
    var occurrences = 0;
    for (var j2 = 0; j2 < cues.length; j2++) {
      if (cues[i].startTime === cues[j2].startTime && cues[i].endTime === cues[j2].endTime && cues[i].text === cues[j2].text) {
        occurrences++;
        if (occurrences > 1) {
          duplicates.push(cues[j2]);
        }
      }
    }
    if (duplicates.length) {
      duplicates.forEach(function(dupe) {
        return track.removeCue(dupe);
      });
    }
  }
};
var gopsSafeToAlignWith = function gopsSafeToAlignWith2(buffer, currentTime, mapping) {
  if (typeof currentTime === "undefined" || currentTime === null || !buffer.length) {
    return [];
  }
  var currentTimePts = Math.ceil((currentTime - mapping + 3) * import_clock.ONE_SECOND_IN_TS);
  var i;
  for (i = 0; i < buffer.length; i++) {
    if (buffer[i].pts > currentTimePts) {
      break;
    }
  }
  return buffer.slice(i);
};
var updateGopBuffer = function updateGopBuffer2(buffer, gops, replace) {
  if (!gops.length) {
    return buffer;
  }
  if (replace) {
    return gops.slice();
  }
  var start2 = gops[0].pts;
  var i = 0;
  for (i; i < buffer.length; i++) {
    if (buffer[i].pts >= start2) {
      break;
    }
  }
  return buffer.slice(0, i).concat(gops);
};
var removeGopBuffer = function removeGopBuffer2(buffer, start2, end, mapping) {
  var startPts = Math.ceil((start2 - mapping) * import_clock.ONE_SECOND_IN_TS);
  var endPts = Math.ceil((end - mapping) * import_clock.ONE_SECOND_IN_TS);
  var updatedBuffer = buffer.slice();
  var i = buffer.length;
  while (i--) {
    if (buffer[i].pts <= endPts) {
      break;
    }
  }
  if (i === -1) {
    return updatedBuffer;
  }
  var j2 = i + 1;
  while (j2--) {
    if (buffer[j2].pts <= startPts) {
      break;
    }
  }
  j2 = Math.max(j2, 0);
  updatedBuffer.splice(j2, i - j2 + 1);
  return updatedBuffer;
};
var shallowEqual = function shallowEqual2(a, b2) {
  if (!a && !b2 || !a && b2 || a && !b2) {
    return false;
  }
  if (a === b2) {
    return true;
  }
  var akeys = Object.keys(a).sort();
  var bkeys = Object.keys(b2).sort();
  if (akeys.length !== bkeys.length) {
    return false;
  }
  for (var i = 0; i < akeys.length; i++) {
    var key = akeys[i];
    if (key !== bkeys[i]) {
      return false;
    }
    if (a[key] !== b2[key]) {
      return false;
    }
  }
  return true;
};
var QUOTA_EXCEEDED_ERR = 22;
var getSyncSegmentCandidate = function getSyncSegmentCandidate2(currentTimeline, segments, targetTime) {
  segments = segments || [];
  var timelineSegments = [];
  var time = 0;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (currentTimeline === segment.timeline) {
      timelineSegments.push(i);
      time += segment.duration;
      if (time > targetTime) {
        return i;
      }
    }
  }
  if (timelineSegments.length === 0) {
    return 0;
  }
  return timelineSegments[timelineSegments.length - 1];
};
var MIN_BACK_BUFFER = 1;
var CHECK_BUFFER_DELAY = 500;
var finite = function finite2(num) {
  return typeof num === "number" && isFinite(num);
};
var MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
var illegalMediaSwitch = function illegalMediaSwitch2(loaderType, startingMedia, trackInfo) {
  if (loaderType !== "main" || !startingMedia || !trackInfo) {
    return null;
  }
  if (!trackInfo.hasAudio && !trackInfo.hasVideo) {
    return "Neither audio nor video found in segment.";
  }
  if (startingMedia.hasVideo && !trackInfo.hasVideo) {
    return "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest.";
  }
  if (!startingMedia.hasVideo && trackInfo.hasVideo) {
    return "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest.";
  }
  return null;
};
var safeBackBufferTrimTime = function safeBackBufferTrimTime2(seekable3, currentTime, targetDuration) {
  var trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
  if (seekable3.length) {
    trimTime = Math.max(trimTime, seekable3.start(0));
  }
  var maxTrimTime = currentTime - targetDuration;
  return Math.min(maxTrimTime, trimTime);
};
var segmentInfoString = function segmentInfoString2(segmentInfo) {
  var startOfSegment = segmentInfo.startOfSegment, duration5 = segmentInfo.duration, segment = segmentInfo.segment, part = segmentInfo.part, _segmentInfo$playlist = segmentInfo.playlist, seq = _segmentInfo$playlist.mediaSequence, id = _segmentInfo$playlist.id, _segmentInfo$playlist2 = _segmentInfo$playlist.segments, segments = _segmentInfo$playlist2 === void 0 ? [] : _segmentInfo$playlist2, index = segmentInfo.mediaIndex, partIndex = segmentInfo.partIndex, timeline = segmentInfo.timeline;
  var segmentLen = segments.length - 1;
  var selection = "mediaIndex/partIndex increment";
  if (segmentInfo.getMediaInfoForTime) {
    selection = "getMediaInfoForTime (" + segmentInfo.getMediaInfoForTime + ")";
  } else if (segmentInfo.isSyncRequest) {
    selection = "getSyncSegmentCandidate (isSyncRequest)";
  }
  if (segmentInfo.independent) {
    selection += " with independent " + segmentInfo.independent;
  }
  var hasPartIndex = typeof partIndex === "number";
  var name = segmentInfo.segment.uri ? "segment" : "pre-segment";
  var zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
    preloadSegment: segment
  }) - 1 : 0;
  return name + " [" + (seq + index) + "/" + (seq + segmentLen) + "]" + (hasPartIndex ? " part [" + partIndex + "/" + zeroBasedPartCount + "]" : "") + (" segment start/end [" + segment.start + " => " + segment.end + "]") + (hasPartIndex ? " part start/end [" + part.start + " => " + part.end + "]" : "") + (" startOfSegment [" + startOfSegment + "]") + (" duration [" + duration5 + "]") + (" timeline [" + timeline + "]") + (" selected by [" + selection + "]") + (" playlist [" + id + "]");
};
var timingInfoPropertyForMedia = function timingInfoPropertyForMedia2(mediaType) {
  return mediaType + "TimingInfo";
};
var timestampOffsetForSegment = function timestampOffsetForSegment2(_ref) {
  var segmentTimeline = _ref.segmentTimeline, currentTimeline = _ref.currentTimeline, startOfSegment = _ref.startOfSegment, buffered = _ref.buffered, overrideCheck = _ref.overrideCheck;
  if (!overrideCheck && segmentTimeline === currentTimeline) {
    return null;
  }
  if (segmentTimeline < currentTimeline) {
    return startOfSegment;
  }
  return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
};
var shouldWaitForTimelineChange = function shouldWaitForTimelineChange2(_ref2) {
  var timelineChangeController = _ref2.timelineChangeController, currentTimeline = _ref2.currentTimeline, segmentTimeline = _ref2.segmentTimeline, loaderType = _ref2.loaderType, audioDisabled = _ref2.audioDisabled;
  if (currentTimeline === segmentTimeline) {
    return false;
  }
  if (loaderType === "audio") {
    var lastMainTimelineChange = timelineChangeController.lastTimelineChange({
      type: "main"
    });
    return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
  }
  if (loaderType === "main" && audioDisabled) {
    var pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
      type: "audio"
    });
    if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {
      return false;
    }
    return true;
  }
  return false;
};
var mediaDuration = function mediaDuration2(timingInfos) {
  var maxDuration = 0;
  ["video", "audio"].forEach(function(type2) {
    var typeTimingInfo = timingInfos[type2 + "TimingInfo"];
    if (!typeTimingInfo) {
      return;
    }
    var start2 = typeTimingInfo.start, end = typeTimingInfo.end;
    var duration5;
    if (typeof start2 === "bigint" || typeof end === "bigint") {
      duration5 = import_window6.default.BigInt(end) - import_window6.default.BigInt(start2);
    } else if (typeof start2 === "number" && typeof end === "number") {
      duration5 = end - start2;
    }
    if (typeof duration5 !== "undefined" && duration5 > maxDuration) {
      maxDuration = duration5;
    }
  });
  if (typeof maxDuration === "bigint" && maxDuration < Number.MAX_SAFE_INTEGER) {
    maxDuration = Number(maxDuration);
  }
  return maxDuration;
};
var segmentTooLong = function segmentTooLong2(_ref3) {
  var segmentDuration = _ref3.segmentDuration, maxDuration = _ref3.maxDuration;
  if (!segmentDuration) {
    return false;
  }
  return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
};
var getTroublesomeSegmentDurationMessage = function getTroublesomeSegmentDurationMessage2(segmentInfo, sourceType) {
  if (sourceType !== "hls") {
    return null;
  }
  var segmentDuration = mediaDuration({
    audioTimingInfo: segmentInfo.audioTimingInfo,
    videoTimingInfo: segmentInfo.videoTimingInfo
  });
  if (!segmentDuration) {
    return null;
  }
  var targetDuration = segmentInfo.playlist.targetDuration;
  var isSegmentWayTooLong = segmentTooLong({
    segmentDuration,
    maxDuration: targetDuration * 2
  });
  var isSegmentSlightlyTooLong = segmentTooLong({
    segmentDuration,
    maxDuration: targetDuration
  });
  var segmentTooLongMessage = "Segment with index " + segmentInfo.mediaIndex + " " + ("from playlist " + segmentInfo.playlist.id + " ") + ("has a duration of " + segmentDuration + " ") + ("when the reported duration is " + segmentInfo.duration + " ") + ("and the target duration is " + targetDuration + ". ") + "For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
  if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {
    return {
      severity: isSegmentWayTooLong ? "warn" : "info",
      message: segmentTooLongMessage
    };
  }
  return null;
};
var SegmentLoader = function(_videojs$EventTarget) {
  _inheritsLoose(SegmentLoader2, _videojs$EventTarget);
  function SegmentLoader2(settings, options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    if (!settings) {
      throw new TypeError("Initialization settings are required");
    }
    if (typeof settings.currentTime !== "function") {
      throw new TypeError("No currentTime getter specified");
    }
    if (!settings.mediaSource) {
      throw new TypeError("No MediaSource specified");
    }
    _this.bandwidth = settings.bandwidth;
    _this.throughput = {
      rate: 0,
      count: 0
    };
    _this.roundTrip = NaN;
    _this.resetStats_();
    _this.mediaIndex = null;
    _this.partIndex = null;
    _this.hasPlayed_ = settings.hasPlayed;
    _this.currentTime_ = settings.currentTime;
    _this.seekable_ = settings.seekable;
    _this.seeking_ = settings.seeking;
    _this.duration_ = settings.duration;
    _this.mediaSource_ = settings.mediaSource;
    _this.vhs_ = settings.vhs;
    _this.loaderType_ = settings.loaderType;
    _this.currentMediaInfo_ = void 0;
    _this.startingMediaInfo_ = void 0;
    _this.segmentMetadataTrack_ = settings.segmentMetadataTrack;
    _this.goalBufferLength_ = settings.goalBufferLength;
    _this.sourceType_ = settings.sourceType;
    _this.sourceUpdater_ = settings.sourceUpdater;
    _this.inbandTextTracks_ = settings.inbandTextTracks;
    _this.state_ = "INIT";
    _this.timelineChangeController_ = settings.timelineChangeController;
    _this.shouldSaveSegmentTimingInfo_ = true;
    _this.parse708captions_ = settings.parse708captions;
    _this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;
    _this.captionServices_ = settings.captionServices;
    _this.experimentalExactManifestTimings = settings.experimentalExactManifestTimings;
    _this.checkBufferTimeout_ = null;
    _this.error_ = void 0;
    _this.currentTimeline_ = -1;
    _this.pendingSegment_ = null;
    _this.xhrOptions_ = null;
    _this.pendingSegments_ = [];
    _this.audioDisabled_ = false;
    _this.isPendingTimestampOffset_ = false;
    _this.gopBuffer_ = [];
    _this.timeMapping_ = 0;
    _this.safeAppend_ = videojs.browser.IE_VERSION >= 11;
    _this.appendInitSegment_ = {
      audio: true,
      video: true
    };
    _this.playlistOfLastInitSegment_ = {
      audio: null,
      video: null
    };
    _this.callQueue_ = [];
    _this.loadQueue_ = [];
    _this.metadataQueue_ = {
      id3: [],
      caption: []
    };
    _this.waitingOnRemove_ = false;
    _this.quotaExceededErrorRetryTimeout_ = null;
    _this.activeInitSegmentId_ = null;
    _this.initSegments_ = {};
    _this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;
    _this.keyCache_ = {};
    _this.decrypter_ = settings.decrypter;
    _this.syncController_ = settings.syncController;
    _this.syncPoint_ = {
      segmentIndex: 0,
      time: 0
    };
    _this.transmuxer_ = _this.createTransmuxer_();
    _this.triggerSyncInfoUpdate_ = function() {
      return _this.trigger("syncinfoupdate");
    };
    _this.syncController_.on("syncinfoupdate", _this.triggerSyncInfoUpdate_);
    _this.mediaSource_.addEventListener("sourceopen", function() {
      if (!_this.isEndOfStream_()) {
        _this.ended_ = false;
      }
    });
    _this.fetchAtBuffer_ = false;
    _this.logger_ = logger("SegmentLoader[" + _this.loaderType_ + "]");
    Object.defineProperty(_assertThisInitialized(_this), "state", {
      get: function get7() {
        return this.state_;
      },
      set: function set4(newState) {
        if (newState !== this.state_) {
          this.logger_(this.state_ + " -> " + newState);
          this.state_ = newState;
          this.trigger("statechange");
        }
      }
    });
    _this.sourceUpdater_.on("ready", function() {
      if (_this.hasEnoughInfoToAppend_()) {
        _this.processCallQueue_();
      }
    });
    if (_this.loaderType_ === "main") {
      _this.timelineChangeController_.on("pendingtimelinechange", function() {
        if (_this.hasEnoughInfoToAppend_()) {
          _this.processCallQueue_();
        }
      });
    }
    if (_this.loaderType_ === "audio") {
      _this.timelineChangeController_.on("timelinechange", function() {
        if (_this.hasEnoughInfoToLoad_()) {
          _this.processLoadQueue_();
        }
        if (_this.hasEnoughInfoToAppend_()) {
          _this.processCallQueue_();
        }
      });
    }
    return _this;
  }
  var _proto = SegmentLoader2.prototype;
  _proto.createTransmuxer_ = function createTransmuxer_() {
    return segmentTransmuxer.createTransmuxer({
      remux: false,
      alignGopsAtEnd: this.safeAppend_,
      keepOriginalTimestamps: true,
      parse708captions: this.parse708captions_,
      captionServices: this.captionServices_
    });
  };
  _proto.resetStats_ = function resetStats_() {
    this.mediaBytesTransferred = 0;
    this.mediaRequests = 0;
    this.mediaRequestsAborted = 0;
    this.mediaRequestsTimedout = 0;
    this.mediaRequestsErrored = 0;
    this.mediaTransferDuration = 0;
    this.mediaSecondsLoaded = 0;
    this.mediaAppends = 0;
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.state = "DISPOSED";
    this.pause();
    this.abort_();
    if (this.transmuxer_) {
      this.transmuxer_.terminate();
    }
    this.resetStats_();
    if (this.checkBufferTimeout_) {
      import_window6.default.clearTimeout(this.checkBufferTimeout_);
    }
    if (this.syncController_ && this.triggerSyncInfoUpdate_) {
      this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_);
    }
    this.off();
  };
  _proto.setAudio = function setAudio(enable) {
    this.audioDisabled_ = !enable;
    if (enable) {
      this.appendInitSegment_.audio = true;
    } else {
      this.sourceUpdater_.removeAudio(0, this.duration_());
    }
  };
  _proto.abort = function abort2() {
    if (this.state !== "WAITING") {
      if (this.pendingSegment_) {
        this.pendingSegment_ = null;
      }
      return;
    }
    this.abort_();
    this.state = "READY";
    if (!this.paused()) {
      this.monitorBuffer_();
    }
  };
  _proto.abort_ = function abort_() {
    if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {
      this.pendingSegment_.abortRequests();
    }
    this.pendingSegment_ = null;
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
    this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
    this.waitingOnRemove_ = false;
    import_window6.default.clearTimeout(this.quotaExceededErrorRetryTimeout_);
    this.quotaExceededErrorRetryTimeout_ = null;
  };
  _proto.checkForAbort_ = function checkForAbort_(requestId) {
    if (this.state === "APPENDING" && !this.pendingSegment_) {
      this.state = "READY";
      return true;
    }
    if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {
      return true;
    }
    return false;
  };
  _proto.error = function error(_error) {
    if (typeof _error !== "undefined") {
      this.logger_("error occurred:", _error);
      this.error_ = _error;
    }
    this.pendingSegment_ = null;
    return this.error_;
  };
  _proto.endOfStream = function endOfStream2() {
    this.ended_ = true;
    if (this.transmuxer_) {
      segmentTransmuxer.reset(this.transmuxer_);
    }
    this.gopBuffer_.length = 0;
    this.pause();
    this.trigger("ended");
  };
  _proto.buffered_ = function buffered_() {
    var trackInfo = this.getMediaInfo_();
    if (!this.sourceUpdater_ || !trackInfo) {
      return videojs.createTimeRanges();
    }
    if (this.loaderType_ === "main") {
      var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
      if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed3) {
        return this.sourceUpdater_.buffered();
      }
      if (hasVideo) {
        return this.sourceUpdater_.videoBuffered();
      }
    }
    return this.sourceUpdater_.audioBuffered();
  };
  _proto.initSegmentForMap = function initSegmentForMap(map, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!map) {
      return null;
    }
    var id = initSegmentId(map);
    var storedMap = this.initSegments_[id];
    if (set4 && !storedMap && map.bytes) {
      this.initSegments_[id] = storedMap = {
        resolvedUri: map.resolvedUri,
        byterange: map.byterange,
        bytes: map.bytes,
        tracks: map.tracks,
        timescales: map.timescales
      };
    }
    return storedMap || map;
  };
  _proto.segmentKey = function segmentKey(key, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!key) {
      return null;
    }
    var id = segmentKeyId(key);
    var storedKey = this.keyCache_[id];
    if (this.cacheEncryptionKeys_ && set4 && !storedKey && key.bytes) {
      this.keyCache_[id] = storedKey = {
        resolvedUri: key.resolvedUri,
        bytes: key.bytes
      };
    }
    var result = {
      resolvedUri: (storedKey || key).resolvedUri
    };
    if (storedKey) {
      result.bytes = storedKey.bytes;
    }
    return result;
  };
  _proto.couldBeginLoading_ = function couldBeginLoading_() {
    return this.playlist_ && !this.paused();
  };
  _proto.load = function load() {
    this.monitorBuffer_();
    if (!this.playlist_) {
      return;
    }
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      return this.init_();
    }
    if (!this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT") {
      return;
    }
    this.state = "READY";
  };
  _proto.init_ = function init_() {
    this.state = "READY";
    this.resetEverything();
    return this.monitorBuffer_();
  };
  _proto.playlist = function playlist(newPlaylist, options) {
    if (options === void 0) {
      options = {};
    }
    if (!newPlaylist) {
      return;
    }
    var oldPlaylist = this.playlist_;
    var segmentInfo = this.pendingSegment_;
    this.playlist_ = newPlaylist;
    this.xhrOptions_ = options;
    if (this.state === "INIT") {
      newPlaylist.syncInfo = {
        mediaSequence: newPlaylist.mediaSequence,
        time: 0
      };
      if (this.loaderType_ === "main") {
        this.syncController_.setDateTimeMappingForStart(newPlaylist);
      }
    }
    var oldId = null;
    if (oldPlaylist) {
      if (oldPlaylist.id) {
        oldId = oldPlaylist.id;
      } else if (oldPlaylist.uri) {
        oldId = oldPlaylist.uri;
      }
    }
    this.logger_("playlist update [" + oldId + " => " + (newPlaylist.id || newPlaylist.uri) + "]");
    this.trigger("syncinfoupdate");
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      return this.init_();
    }
    if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
      if (this.mediaIndex !== null) {
        if (!newPlaylist.endList) {
          this.resetLoader();
        } else {
          this.resyncLoader();
        }
      }
      this.currentMediaInfo_ = void 0;
      this.trigger("playlistupdate");
      return;
    }
    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
    this.logger_("live window shift [" + mediaSequenceDiff + "]");
    if (this.mediaIndex !== null) {
      this.mediaIndex -= mediaSequenceDiff;
      if (this.mediaIndex < 0) {
        this.mediaIndex = null;
        this.partIndex = null;
      } else {
        var segment = this.playlist_.segments[this.mediaIndex];
        if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
          var mediaIndex = this.mediaIndex;
          this.logger_("currently processing part (index " + this.partIndex + ") no longer exists.");
          this.resetLoader();
          this.mediaIndex = mediaIndex;
        }
      }
    }
    if (segmentInfo) {
      segmentInfo.mediaIndex -= mediaSequenceDiff;
      if (segmentInfo.mediaIndex < 0) {
        segmentInfo.mediaIndex = null;
        segmentInfo.partIndex = null;
      } else {
        if (segmentInfo.mediaIndex >= 0) {
          segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
        }
        if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {
          segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
        }
      }
    }
    this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
  };
  _proto.pause = function pause() {
    if (this.checkBufferTimeout_) {
      import_window6.default.clearTimeout(this.checkBufferTimeout_);
      this.checkBufferTimeout_ = null;
    }
  };
  _proto.paused = function paused() {
    return this.checkBufferTimeout_ === null;
  };
  _proto.resetEverything = function resetEverything(done) {
    this.ended_ = false;
    this.activeInitSegmentId_ = null;
    this.appendInitSegment_ = {
      audio: true,
      video: true
    };
    this.resetLoader();
    this.remove(0, Infinity, done);
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearAllMp4Captions"
      });
      this.transmuxer_.postMessage({
        action: "reset"
      });
    }
  };
  _proto.resetLoader = function resetLoader() {
    this.fetchAtBuffer_ = false;
    this.resyncLoader();
  };
  _proto.resyncLoader = function resyncLoader() {
    if (this.transmuxer_) {
      segmentTransmuxer.reset(this.transmuxer_);
    }
    this.mediaIndex = null;
    this.partIndex = null;
    this.syncPoint_ = null;
    this.isPendingTimestampOffset_ = false;
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
    this.abort();
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  };
  _proto.remove = function remove2(start2, end, done, force) {
    if (done === void 0) {
      done = function done2() {
      };
    }
    if (force === void 0) {
      force = false;
    }
    if (end === Infinity) {
      end = this.duration_();
    }
    if (end <= start2) {
      this.logger_("skipping remove because end ${end} is <= start ${start}");
      return;
    }
    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
      this.logger_("skipping remove because no source updater or starting media info");
      return;
    }
    var removesRemaining = 1;
    var removeFinished = function removeFinished2() {
      removesRemaining--;
      if (removesRemaining === 0) {
        done();
      }
    };
    if (force || !this.audioDisabled_) {
      removesRemaining++;
      this.sourceUpdater_.removeAudio(start2, end, removeFinished);
    }
    if (force || this.loaderType_ === "main") {
      this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start2, end, this.timeMapping_);
      removesRemaining++;
      this.sourceUpdater_.removeVideo(start2, end, removeFinished);
    }
    for (var track in this.inbandTextTracks_) {
      removeCuesFromTrack(start2, end, this.inbandTextTracks_[track]);
    }
    removeCuesFromTrack(start2, end, this.segmentMetadataTrack_);
    removeFinished();
  };
  _proto.monitorBuffer_ = function monitorBuffer_() {
    if (this.checkBufferTimeout_) {
      import_window6.default.clearTimeout(this.checkBufferTimeout_);
    }
    this.checkBufferTimeout_ = import_window6.default.setTimeout(this.monitorBufferTick_.bind(this), 1);
  };
  _proto.monitorBufferTick_ = function monitorBufferTick_() {
    if (this.state === "READY") {
      this.fillBuffer_();
    }
    if (this.checkBufferTimeout_) {
      import_window6.default.clearTimeout(this.checkBufferTimeout_);
    }
    this.checkBufferTimeout_ = import_window6.default.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);
  };
  _proto.fillBuffer_ = function fillBuffer_() {
    if (this.sourceUpdater_.updating()) {
      return;
    }
    var segmentInfo = this.chooseNextRequest_();
    if (!segmentInfo) {
      return;
    }
    if (typeof segmentInfo.timestampOffset === "number") {
      this.isPendingTimestampOffset_ = false;
      this.timelineChangeController_.pendingTimelineChange({
        type: this.loaderType_,
        from: this.currentTimeline_,
        to: segmentInfo.timeline
      });
    }
    this.loadSegment_(segmentInfo);
  };
  _proto.isEndOfStream_ = function isEndOfStream_(mediaIndex, playlist, partIndex) {
    if (mediaIndex === void 0) {
      mediaIndex = this.mediaIndex;
    }
    if (playlist === void 0) {
      playlist = this.playlist_;
    }
    if (partIndex === void 0) {
      partIndex = this.partIndex;
    }
    if (!playlist || !this.mediaSource_) {
      return false;
    }
    var segment = typeof mediaIndex === "number" && playlist.segments[mediaIndex];
    var appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
    var appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
    return playlist.endList && this.mediaSource_.readyState === "open" && appendedLastSegment && appendedLastPart;
  };
  _proto.chooseNextRequest_ = function chooseNextRequest_() {
    var buffered = this.buffered_();
    var bufferedEnd = lastBufferedEnd(buffered) || 0;
    var bufferedTime = timeAheadOf(buffered, this.currentTime_());
    var preloaded = !this.hasPlayed_() && bufferedTime >= 1;
    var haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
    var segments = this.playlist_.segments;
    if (!segments.length || preloaded || haveEnoughBuffer) {
      return null;
    }
    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());
    var next = {
      partIndex: null,
      mediaIndex: null,
      startOfSegment: null,
      playlist: this.playlist_,
      isSyncRequest: Boolean(!this.syncPoint_)
    };
    if (next.isSyncRequest) {
      next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
    } else if (this.mediaIndex !== null) {
      var segment = segments[this.mediaIndex];
      var partIndex = typeof this.partIndex === "number" ? this.partIndex : -1;
      next.startOfSegment = segment.end ? segment.end : bufferedEnd;
      if (segment.parts && segment.parts[partIndex + 1]) {
        next.mediaIndex = this.mediaIndex;
        next.partIndex = partIndex + 1;
      } else {
        next.mediaIndex = this.mediaIndex + 1;
      }
    } else {
      var _Playlist$getMediaInf = Playlist.getMediaInfoForTime({
        experimentalExactManifestTimings: this.experimentalExactManifestTimings,
        playlist: this.playlist_,
        currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),
        startingPartIndex: this.syncPoint_.partIndex,
        startingSegmentIndex: this.syncPoint_.segmentIndex,
        startTime: this.syncPoint_.time
      }), segmentIndex = _Playlist$getMediaInf.segmentIndex, startTime = _Playlist$getMediaInf.startTime, _partIndex = _Playlist$getMediaInf.partIndex;
      next.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + bufferedEnd : "currentTime " + this.currentTime_();
      next.mediaIndex = segmentIndex;
      next.startOfSegment = startTime;
      next.partIndex = _partIndex;
    }
    var nextSegment = segments[next.mediaIndex];
    var nextPart = nextSegment && typeof next.partIndex === "number" && nextSegment.parts && nextSegment.parts[next.partIndex];
    if (!nextSegment || typeof next.partIndex === "number" && !nextPart) {
      return null;
    }
    if (typeof next.partIndex !== "number" && nextSegment.parts) {
      next.partIndex = 0;
      nextPart = nextSegment.parts[0];
    }
    if (!bufferedTime && nextPart && !nextPart.independent) {
      if (next.partIndex === 0) {
        var lastSegment = segments[next.mediaIndex - 1];
        var lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
        if (lastSegmentLastPart && lastSegmentLastPart.independent) {
          next.mediaIndex -= 1;
          next.partIndex = lastSegment.parts.length - 1;
          next.independent = "previous segment";
        }
      } else if (nextSegment.parts[next.partIndex - 1].independent) {
        next.partIndex -= 1;
        next.independent = "previous part";
      }
    }
    var ended = this.mediaSource_ && this.mediaSource_.readyState === "ended";
    if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {
      return null;
    }
    return this.generateSegmentInfo_(next);
  };
  _proto.generateSegmentInfo_ = function generateSegmentInfo_(options) {
    var independent = options.independent, playlist = options.playlist, mediaIndex = options.mediaIndex, startOfSegment = options.startOfSegment, isSyncRequest = options.isSyncRequest, partIndex = options.partIndex, forceTimestampOffset = options.forceTimestampOffset, getMediaInfoForTime3 = options.getMediaInfoForTime;
    var segment = playlist.segments[mediaIndex];
    var part = typeof partIndex === "number" && segment.parts[partIndex];
    var segmentInfo = {
      requestId: "segment-loader-" + Math.random(),
      // resolve the segment URL relative to the playlist
      uri: part && part.resolvedUri || segment.resolvedUri,
      // the segment's mediaIndex at the time it was requested
      mediaIndex,
      partIndex: part ? partIndex : null,
      // whether or not to update the SegmentLoader's state with this
      // segment's mediaIndex
      isSyncRequest,
      startOfSegment,
      // the segment's playlist
      playlist,
      // unencrypted bytes of the segment
      bytes: null,
      // when a key is defined for this segment, the encrypted bytes
      encryptedBytes: null,
      // The target timestampOffset for this segment when we append it
      // to the source buffer
      timestampOffset: null,
      // The timeline that the segment is in
      timeline: segment.timeline,
      // The expected duration of the segment in seconds
      duration: part && part.duration || segment.duration,
      // retain the segment in case the playlist updates while doing an async process
      segment,
      part,
      byteLength: 0,
      transmuxer: this.transmuxer_,
      // type of getMediaInfoForTime that was used to get this segment
      getMediaInfoForTime: getMediaInfoForTime3,
      independent
    };
    var overrideCheck = typeof forceTimestampOffset !== "undefined" ? forceTimestampOffset : this.isPendingTimestampOffset_;
    segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
      segmentTimeline: segment.timeline,
      currentTimeline: this.currentTimeline_,
      startOfSegment,
      buffered: this.buffered_(),
      overrideCheck
    });
    var audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
    if (typeof audioBufferedEnd === "number") {
      segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
    }
    if (this.sourceUpdater_.videoBuffered().length) {
      segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(
        this.gopBuffer_,
        // since the transmuxer is using the actual timing values, but the time is
        // adjusted by the timestmap offset, we must adjust the value here
        this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
        this.timeMapping_
      );
    }
    return segmentInfo;
  };
  _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_(options) {
    return timestampOffsetForSegment(options);
  };
  _proto.earlyAbortWhenNeeded_ = function earlyAbortWhenNeeded_(stats) {
    if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
    // TODO: Replace using timeout with a boolean indicating whether this playlist is
    //       the lowestEnabledRendition.
    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
    !this.playlist_.attributes.BANDWIDTH) {
      return;
    }
    if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1e3) {
      return;
    }
    var currentTime = this.currentTime_();
    var measuredBandwidth = stats.bandwidth;
    var segmentDuration = this.pendingSegment_.duration;
    var requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
    var timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
    if (requestTimeRemaining <= timeUntilRebuffer$1) {
      return;
    }
    var switchCandidate = minRebufferMaxBandwidthSelector({
      master: this.vhs_.playlists.master,
      currentTime,
      bandwidth: measuredBandwidth,
      duration: this.duration_(),
      segmentDuration,
      timeUntilRebuffer: timeUntilRebuffer$1,
      currentTimeline: this.currentTimeline_,
      syncController: this.syncController_
    });
    if (!switchCandidate) {
      return;
    }
    var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
    var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
    var minimumTimeSaving = 0.5;
    if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {
      minimumTimeSaving = 1;
    }
    if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {
      return;
    }
    this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;
    this.trigger("earlyabort");
  };
  _proto.handleAbort_ = function handleAbort_(segmentInfo) {
    this.logger_("Aborting " + segmentInfoString(segmentInfo));
    this.mediaRequestsAborted += 1;
  };
  _proto.handleProgress_ = function handleProgress_(event, simpleSegment) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    this.trigger("progress");
  };
  _proto.handleTrackInfo_ = function handleTrackInfo_(simpleSegment, trackInfo) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (this.checkForIllegalMediaSwitch(trackInfo)) {
      return;
    }
    trackInfo = trackInfo || {};
    if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
      this.startingMediaInfo_ = trackInfo;
      this.currentMediaInfo_ = trackInfo;
      this.logger_("trackinfo update", trackInfo);
      this.trigger("trackinfo");
    }
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    this.pendingSegment_.trackInfo = trackInfo;
    if (this.hasEnoughInfoToAppend_()) {
      this.processCallQueue_();
    }
  };
  _proto.handleTimingInfo_ = function handleTimingInfo_(simpleSegment, mediaType, timeType, time) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    var segmentInfo = this.pendingSegment_;
    var timingInfoProperty = timingInfoPropertyForMedia(mediaType);
    segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
    segmentInfo[timingInfoProperty][timeType] = time;
    this.logger_("timinginfo: " + mediaType + " - " + timeType + " - " + time);
    if (this.hasEnoughInfoToAppend_()) {
      this.processCallQueue_();
    }
  };
  _proto.handleCaptions_ = function handleCaptions_(simpleSegment, captionData) {
    var _this2 = this;
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (captionData.length === 0) {
      this.logger_("SegmentLoader received no captions from a caption event");
      return;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo.hasAppendedData_) {
      this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
      return;
    }
    var timestampOffset2 = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    var captionTracks = {};
    captionData.forEach(function(caption) {
      captionTracks[caption.stream] = captionTracks[caption.stream] || {
        // Infinity, as any other value will be less than this
        startTime: Infinity,
        captions: [],
        // 0 as an other value will be more than this
        endTime: 0
      };
      var captionTrack = captionTracks[caption.stream];
      captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset2);
      captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset2);
      captionTrack.captions.push(caption);
    });
    Object.keys(captionTracks).forEach(function(trackName) {
      var _captionTracks$trackN = captionTracks[trackName], startTime = _captionTracks$trackN.startTime, endTime = _captionTracks$trackN.endTime, captions = _captionTracks$trackN.captions;
      var inbandTextTracks = _this2.inbandTextTracks_;
      _this2.logger_("adding cues from " + startTime + " -> " + endTime + " for " + trackName);
      createCaptionsTrackIfNotExists(inbandTextTracks, _this2.vhs_.tech_, trackName);
      removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
      addCaptionData({
        captionArray: captions,
        inbandTextTracks,
        timestampOffset: timestampOffset2
      });
    });
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  };
  _proto.handleId3_ = function handleId3_(simpleSegment, id3Frames, dispatchType) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo.hasAppendedData_) {
      this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
      return;
    }
    var timestampOffset2 = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);
    addMetadata({
      inbandTextTracks: this.inbandTextTracks_,
      metadataArray: id3Frames,
      timestampOffset: timestampOffset2,
      videoDuration: this.duration_()
    });
  };
  _proto.processMetadataQueue_ = function processMetadataQueue_() {
    this.metadataQueue_.id3.forEach(function(fn) {
      return fn();
    });
    this.metadataQueue_.caption.forEach(function(fn) {
      return fn();
    });
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
  };
  _proto.processCallQueue_ = function processCallQueue_() {
    var callQueue = this.callQueue_;
    this.callQueue_ = [];
    callQueue.forEach(function(fun) {
      return fun();
    });
  };
  _proto.processLoadQueue_ = function processLoadQueue_() {
    var loadQueue = this.loadQueue_;
    this.loadQueue_ = [];
    loadQueue.forEach(function(fun) {
      return fun();
    });
  };
  _proto.hasEnoughInfoToLoad_ = function hasEnoughInfoToLoad_() {
    if (this.loaderType_ !== "audio") {
      return true;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo) {
      return false;
    }
    if (!this.getCurrentMediaInfo_()) {
      return true;
    }
    if (
      // Technically, instead of waiting to load a segment on timeline changes, a segment
      // can be requested and downloaded and only wait before it is transmuxed or parsed.
      // But in practice, there are a few reasons why it is better to wait until a loader
      // is ready to append that segment before requesting and downloading:
      //
      // 1. Because audio and main loaders cross discontinuities together, if this loader
      //    is waiting for the other to catch up, then instead of requesting another
      //    segment and using up more bandwidth, by not yet loading, more bandwidth is
      //    allotted to the loader currently behind.
      // 2. media-segment-request doesn't have to have logic to consider whether a segment
      // is ready to be processed or not, isolating the queueing behavior to the loader.
      // 3. The audio loader bases some of its segment properties on timing information
      //    provided by the main loader, meaning that, if the logic for waiting on
      //    processing was in media-segment-request, then it would also need to know how
      //    to re-generate the segment information after the main loader caught up.
      shouldWaitForTimelineChange({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: segmentInfo.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })
    ) {
      return false;
    }
    return true;
  };
  _proto.getCurrentMediaInfo_ = function getCurrentMediaInfo_(segmentInfo) {
    if (segmentInfo === void 0) {
      segmentInfo = this.pendingSegment_;
    }
    return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
  };
  _proto.getMediaInfo_ = function getMediaInfo_(segmentInfo) {
    if (segmentInfo === void 0) {
      segmentInfo = this.pendingSegment_;
    }
    return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
  };
  _proto.getPendingSegmentPlaylist = function getPendingSegmentPlaylist() {
    return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
  };
  _proto.hasEnoughInfoToAppend_ = function hasEnoughInfoToAppend_() {
    if (!this.sourceUpdater_.ready()) {
      return false;
    }
    if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {
      return false;
    }
    var segmentInfo = this.pendingSegment_;
    var trackInfo = this.getCurrentMediaInfo_();
    if (!segmentInfo || !trackInfo) {
      return false;
    }
    var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
    if (hasVideo && !segmentInfo.videoTimingInfo) {
      return false;
    }
    if (hasAudio && !this.audioDisabled_ && !isMuxed3 && !segmentInfo.audioTimingInfo) {
      return false;
    }
    if (shouldWaitForTimelineChange({
      timelineChangeController: this.timelineChangeController_,
      currentTimeline: this.currentTimeline_,
      segmentTimeline: segmentInfo.timeline,
      loaderType: this.loaderType_,
      audioDisabled: this.audioDisabled_
    })) {
      return false;
    }
    return true;
  };
  _proto.handleData_ = function handleData_3(simpleSegment, result) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
      this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.setTimeMapping_(segmentInfo.timeline);
    this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
    if (this.mediaSource_.readyState === "closed") {
      return;
    }
    if (simpleSegment.map) {
      simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
      segmentInfo.segment.map = simpleSegment.map;
    }
    if (simpleSegment.key) {
      this.segmentKey(simpleSegment.key, true);
    }
    segmentInfo.isFmp4 = simpleSegment.isFmp4;
    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
    if (segmentInfo.isFmp4) {
      this.trigger("fmp4");
      segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
    } else {
      var trackInfo = this.getCurrentMediaInfo_();
      var useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
      var firstVideoFrameTimeForData;
      if (useVideoTimingInfo) {
        firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
      }
      segmentInfo.timingInfo.start = this.trueSegmentStart_({
        currentStart: segmentInfo.timingInfo.start,
        playlist: segmentInfo.playlist,
        mediaIndex: segmentInfo.mediaIndex,
        currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
        useVideoTimingInfo,
        firstVideoFrameTimeForData,
        videoTimingInfo: segmentInfo.videoTimingInfo,
        audioTimingInfo: segmentInfo.audioTimingInfo
      });
    }
    this.updateAppendInitSegmentStatus(segmentInfo, result.type);
    this.updateSourceBufferTimestampOffset_(segmentInfo);
    if (segmentInfo.isSyncRequest) {
      this.updateTimingInfoEnd_(segmentInfo);
      this.syncController_.saveSegmentTimingInfo({
        segmentInfo,
        shouldSaveTimelineMapping: this.loaderType_ === "main"
      });
      var next = this.chooseNextRequest_();
      if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
        this.logger_("sync segment was incorrect, not appending");
        return;
      }
      this.logger_("sync segment was correct, appending");
    }
    segmentInfo.hasAppendedData_ = true;
    this.processMetadataQueue_();
    this.appendData_(segmentInfo, result);
  };
  _proto.updateAppendInitSegmentStatus = function updateAppendInitSegmentStatus(segmentInfo, type2) {
    if (this.loaderType_ === "main" && typeof segmentInfo.timestampOffset === "number" && // in the case that we're handling partial data, we don't want to append an init
    // segment for each chunk
    !segmentInfo.changedTimestampOffset) {
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
    }
    if (this.playlistOfLastInitSegment_[type2] !== segmentInfo.playlist) {
      this.appendInitSegment_[type2] = true;
    }
  };
  _proto.getInitSegmentAndUpdateState_ = function getInitSegmentAndUpdateState_(_ref4) {
    var type2 = _ref4.type, initSegment = _ref4.initSegment, map = _ref4.map, playlist = _ref4.playlist;
    if (map) {
      var id = initSegmentId(map);
      if (this.activeInitSegmentId_ === id) {
        return null;
      }
      initSegment = this.initSegmentForMap(map, true).bytes;
      this.activeInitSegmentId_ = id;
    }
    if (initSegment && this.appendInitSegment_[type2]) {
      this.playlistOfLastInitSegment_[type2] = playlist;
      this.appendInitSegment_[type2] = false;
      this.activeInitSegmentId_ = null;
      return initSegment;
    }
    return null;
  };
  _proto.handleQuotaExceededError_ = function handleQuotaExceededError_(_ref5, error) {
    var _this3 = this;
    var segmentInfo = _ref5.segmentInfo, type2 = _ref5.type, bytes = _ref5.bytes;
    var audioBuffered = this.sourceUpdater_.audioBuffered();
    var videoBuffered = this.sourceUpdater_.videoBuffered();
    if (audioBuffered.length > 1) {
      this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + timeRangesToArray(audioBuffered).join(", "));
    }
    if (videoBuffered.length > 1) {
      this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + timeRangesToArray(videoBuffered).join(", "));
    }
    var audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
    var audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
    var videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
    var videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
    if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {
      this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. " + ("Appended byte length: " + bytes.byteLength + ", ") + ("audio buffer: " + timeRangesToArray(audioBuffered).join(", ") + ", ") + ("video buffer: " + timeRangesToArray(videoBuffered).join(", ") + ", "));
      this.error({
        message: "Quota exceeded error with append of a single segment of content",
        excludeUntil: Infinity
      });
      this.trigger("error");
      return;
    }
    this.waitingOnRemove_ = true;
    this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
      segmentInfo,
      type: type2,
      bytes
    }));
    var currentTime = this.currentTime_();
    var timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;
    this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + timeToRemoveUntil);
    this.remove(0, timeToRemoveUntil, function() {
      _this3.logger_("On QUOTA_EXCEEDED_ERR, retrying append in " + MIN_BACK_BUFFER + "s");
      _this3.waitingOnRemove_ = false;
      _this3.quotaExceededErrorRetryTimeout_ = import_window6.default.setTimeout(function() {
        _this3.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue");
        _this3.quotaExceededErrorRetryTimeout_ = null;
        _this3.processCallQueue_();
      }, MIN_BACK_BUFFER * 1e3);
    }, true);
  };
  _proto.handleAppendError_ = function handleAppendError_(_ref6, error) {
    var segmentInfo = _ref6.segmentInfo, type2 = _ref6.type, bytes = _ref6.bytes;
    if (!error) {
      return;
    }
    if (error.code === QUOTA_EXCEEDED_ERR) {
      this.handleQuotaExceededError_({
        segmentInfo,
        type: type2,
        bytes
      });
      return;
    }
    this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error);
    this.error(type2 + " append of " + bytes.length + "b failed for segment " + ("#" + segmentInfo.mediaIndex + " in playlist " + segmentInfo.playlist.id));
    this.trigger("appenderror");
  };
  _proto.appendToSourceBuffer_ = function appendToSourceBuffer_(_ref7) {
    var segmentInfo = _ref7.segmentInfo, type2 = _ref7.type, initSegment = _ref7.initSegment, data = _ref7.data, bytes = _ref7.bytes;
    if (!bytes) {
      var segments = [data];
      var byteLength = data.byteLength;
      if (initSegment) {
        segments.unshift(initSegment);
        byteLength += initSegment.byteLength;
      }
      bytes = concatSegments({
        bytes: byteLength,
        segments
      });
    }
    this.sourceUpdater_.appendBuffer({
      segmentInfo,
      type: type2,
      bytes
    }, this.handleAppendError_.bind(this, {
      segmentInfo,
      type: type2,
      bytes
    }));
  };
  _proto.handleSegmentTimingInfo_ = function handleSegmentTimingInfo_(type2, requestId, segmentTimingInfo) {
    if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {
      return;
    }
    var segment = this.pendingSegment_.segment;
    var timingInfoProperty = type2 + "TimingInfo";
    if (!segment[timingInfoProperty]) {
      segment[timingInfoProperty] = {};
    }
    segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
    segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
    segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
    segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
    segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
    segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
  };
  _proto.appendData_ = function appendData_(segmentInfo, result) {
    var type2 = result.type, data = result.data;
    if (!data || !data.byteLength) {
      return;
    }
    if (type2 === "audio" && this.audioDisabled_) {
      return;
    }
    var initSegment = this.getInitSegmentAndUpdateState_({
      type: type2,
      initSegment: result.initSegment,
      playlist: segmentInfo.playlist,
      map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
    });
    this.appendToSourceBuffer_({
      segmentInfo,
      type: type2,
      initSegment,
      data
    });
  };
  _proto.loadSegment_ = function loadSegment_(segmentInfo) {
    var _this4 = this;
    this.state = "WAITING";
    this.pendingSegment_ = segmentInfo;
    this.trimBackBuffer_(segmentInfo);
    if (typeof segmentInfo.timestampOffset === "number") {
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: "clearAllMp4Captions"
        });
      }
    }
    if (!this.hasEnoughInfoToLoad_()) {
      this.loadQueue_.push(function() {
        var options = _extends({}, segmentInfo, {
          forceTimestampOffset: true
        });
        _extends(segmentInfo, _this4.generateSegmentInfo_(options));
        _this4.isPendingTimestampOffset_ = false;
        _this4.updateTransmuxerAndRequestSegment_(segmentInfo);
      });
      return;
    }
    this.updateTransmuxerAndRequestSegment_(segmentInfo);
  };
  _proto.updateTransmuxerAndRequestSegment_ = function updateTransmuxerAndRequestSegment_(segmentInfo) {
    var _this5 = this;
    if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
      this.gopBuffer_.length = 0;
      segmentInfo.gopsToAlignWith = [];
      this.timeMapping_ = 0;
      this.transmuxer_.postMessage({
        action: "reset"
      });
      this.transmuxer_.postMessage({
        action: "setTimestampOffset",
        timestampOffset: segmentInfo.timestampOffset
      });
    }
    var simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
    var isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
    var isWalkingForward = this.mediaIndex !== null;
    var isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
    // the first timeline
    segmentInfo.timeline > 0;
    var isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
    this.logger_("Requesting " + segmentInfoString(segmentInfo));
    if (simpleSegment.map && !simpleSegment.map.bytes) {
      this.logger_("going to request init segment.");
      this.appendInitSegment_ = {
        video: true,
        audio: true
      };
    }
    segmentInfo.abortRequests = mediaSegmentRequest({
      xhr: this.vhs_.xhr,
      xhrOptions: this.xhrOptions_,
      decryptionWorker: this.decrypter_,
      segment: simpleSegment,
      abortFn: this.handleAbort_.bind(this, segmentInfo),
      progressFn: this.handleProgress_.bind(this),
      trackInfoFn: this.handleTrackInfo_.bind(this),
      timingInfoFn: this.handleTimingInfo_.bind(this),
      videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
      audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
      captionsFn: this.handleCaptions_.bind(this),
      isEndOfTimeline,
      endedTimelineFn: function endedTimelineFn() {
        _this5.logger_("received endedtimeline callback");
      },
      id3Fn: this.handleId3_.bind(this),
      dataFn: this.handleData_.bind(this),
      doneFn: this.segmentRequestFinished_.bind(this),
      onTransmuxerLog: function onTransmuxerLog(_ref8) {
        var message = _ref8.message, level = _ref8.level, stream = _ref8.stream;
        _this5.logger_(segmentInfoString(segmentInfo) + " logged from transmuxer stream " + stream + " as a " + level + ": " + message);
      }
    });
  };
  _proto.trimBackBuffer_ = function trimBackBuffer_(segmentInfo) {
    var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
    if (removeToTime > 0) {
      this.remove(0, removeToTime);
    }
  };
  _proto.createSimplifiedSegmentObj_ = function createSimplifiedSegmentObj_(segmentInfo) {
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var simpleSegment = {
      resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
      byterange: part ? part.byterange : segment.byterange,
      requestId: segmentInfo.requestId,
      transmuxer: segmentInfo.transmuxer,
      audioAppendStart: segmentInfo.audioAppendStart,
      gopsToAlignWith: segmentInfo.gopsToAlignWith,
      part: segmentInfo.part
    };
    var previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
    if (previousSegment && previousSegment.timeline === segment.timeline) {
      if (previousSegment.videoTimingInfo) {
        simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;
      } else if (previousSegment.audioTimingInfo) {
        simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
      }
    }
    if (segment.key) {
      var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);
      simpleSegment.key = this.segmentKey(segment.key);
      simpleSegment.key.iv = iv;
    }
    if (segment.map) {
      simpleSegment.map = this.initSegmentForMap(segment.map);
    }
    return simpleSegment;
  };
  _proto.saveTransferStats_ = function saveTransferStats_(stats) {
    this.mediaRequests += 1;
    if (stats) {
      this.mediaBytesTransferred += stats.bytesReceived;
      this.mediaTransferDuration += stats.roundTripTime;
    }
  };
  _proto.saveBandwidthRelatedStats_ = function saveBandwidthRelatedStats_(duration5, stats) {
    this.pendingSegment_.byteLength = stats.bytesReceived;
    if (duration5 < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
      this.logger_("Ignoring segment's bandwidth because its duration of " + duration5 + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
      return;
    }
    this.bandwidth = stats.bandwidth;
    this.roundTrip = stats.roundTripTime;
  };
  _proto.handleTimeout_ = function handleTimeout_() {
    this.mediaRequestsTimedout += 1;
    this.bandwidth = 1;
    this.roundTrip = NaN;
    this.trigger("bandwidthupdate");
    this.trigger("timeout");
  };
  _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
    if (this.callQueue_.length) {
      this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
      return;
    }
    this.saveTransferStats_(simpleSegment.stats);
    if (!this.pendingSegment_) {
      return;
    }
    if (simpleSegment.requestId !== this.pendingSegment_.requestId) {
      return;
    }
    if (error) {
      this.pendingSegment_ = null;
      this.state = "READY";
      if (error.code === REQUEST_ERRORS.ABORTED) {
        return;
      }
      this.pause();
      if (error.code === REQUEST_ERRORS.TIMEOUT) {
        this.handleTimeout_();
        return;
      }
      this.mediaRequestsErrored += 1;
      this.error(error);
      this.trigger("error");
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
    segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
    if (result.gopInfo) {
      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
    }
    this.state = "APPENDING";
    this.trigger("appending");
    this.waitForAppendsToComplete_(segmentInfo);
  };
  _proto.setTimeMapping_ = function setTimeMapping_(timeline) {
    var timelineMapping = this.syncController_.mappingForTimeline(timeline);
    if (timelineMapping !== null) {
      this.timeMapping_ = timelineMapping;
    }
  };
  _proto.updateMediaSecondsLoaded_ = function updateMediaSecondsLoaded_(segment) {
    if (typeof segment.start === "number" && typeof segment.end === "number") {
      this.mediaSecondsLoaded += segment.end - segment.start;
    } else {
      this.mediaSecondsLoaded += segment.duration;
    }
  };
  _proto.shouldUpdateTransmuxerTimestampOffset_ = function shouldUpdateTransmuxerTimestampOffset_(timestampOffset2) {
    if (timestampOffset2 === null) {
      return false;
    }
    if (this.loaderType_ === "main" && timestampOffset2 !== this.sourceUpdater_.videoTimestampOffset()) {
      return true;
    }
    if (!this.audioDisabled_ && timestampOffset2 !== this.sourceUpdater_.audioTimestampOffset()) {
      return true;
    }
    return false;
  };
  _proto.trueSegmentStart_ = function trueSegmentStart_(_ref9) {
    var currentStart = _ref9.currentStart, playlist = _ref9.playlist, mediaIndex = _ref9.mediaIndex, firstVideoFrameTimeForData = _ref9.firstVideoFrameTimeForData, currentVideoTimestampOffset = _ref9.currentVideoTimestampOffset, useVideoTimingInfo = _ref9.useVideoTimingInfo, videoTimingInfo = _ref9.videoTimingInfo, audioTimingInfo = _ref9.audioTimingInfo;
    if (typeof currentStart !== "undefined") {
      return currentStart;
    }
    if (!useVideoTimingInfo) {
      return audioTimingInfo.start;
    }
    var previousSegment = playlist.segments[mediaIndex - 1];
    if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === "undefined" || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {
      return firstVideoFrameTimeForData;
    }
    return videoTimingInfo.start;
  };
  _proto.waitForAppendsToComplete_ = function waitForAppendsToComplete_(segmentInfo) {
    var trackInfo = this.getCurrentMediaInfo_(segmentInfo);
    if (!trackInfo) {
      this.error({
        message: "No starting media returned, likely due to an unsupported media format.",
        blacklistDuration: Infinity
      });
      this.trigger("error");
      return;
    }
    var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
    var waitForVideo = this.loaderType_ === "main" && hasVideo;
    var waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed3;
    segmentInfo.waitingOnAppends = 0;
    if (!segmentInfo.hasAppendedData_) {
      if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === "number") {
        this.isPendingTimestampOffset_ = true;
      }
      segmentInfo.timingInfo = {
        start: 0
      };
      segmentInfo.waitingOnAppends++;
      if (!this.isPendingTimestampOffset_) {
        this.updateSourceBufferTimestampOffset_(segmentInfo);
        this.processMetadataQueue_();
      }
      this.checkAppendsDone_(segmentInfo);
      return;
    }
    if (waitForVideo) {
      segmentInfo.waitingOnAppends++;
    }
    if (waitForAudio) {
      segmentInfo.waitingOnAppends++;
    }
    if (waitForVideo) {
      this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
    }
    if (waitForAudio) {
      this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
    }
  };
  _proto.checkAppendsDone_ = function checkAppendsDone_(segmentInfo) {
    if (this.checkForAbort_(segmentInfo.requestId)) {
      return;
    }
    segmentInfo.waitingOnAppends--;
    if (segmentInfo.waitingOnAppends === 0) {
      this.handleAppendsDone_();
    }
  };
  _proto.checkForIllegalMediaSwitch = function checkForIllegalMediaSwitch(trackInfo) {
    var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
    if (illegalMediaSwitchError) {
      this.error({
        message: illegalMediaSwitchError,
        blacklistDuration: Infinity
      });
      this.trigger("error");
      return true;
    }
    return false;
  };
  _proto.updateSourceBufferTimestampOffset_ = function updateSourceBufferTimestampOffset_(segmentInfo) {
    if (segmentInfo.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
    // priority, timing-wise, so we must wait
    typeof segmentInfo.timingInfo.start !== "number" || // already updated the timestamp offset for this segment
    segmentInfo.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
    this.loaderType_ !== "main") {
      return;
    }
    var didChange = false;
    segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
      videoTimingInfo: segmentInfo.segment.videoTimingInfo,
      audioTimingInfo: segmentInfo.segment.audioTimingInfo,
      timingInfo: segmentInfo.timingInfo
    });
    segmentInfo.changedTimestampOffset = true;
    if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
      this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
      didChange = true;
    }
    if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
      this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
      didChange = true;
    }
    if (didChange) {
      this.trigger("timestampoffset");
    }
  };
  _proto.getSegmentStartTimeForTimestampOffsetCalculation_ = function getSegmentStartTimeForTimestampOffsetCalculation_(_ref10) {
    var videoTimingInfo = _ref10.videoTimingInfo, audioTimingInfo = _ref10.audioTimingInfo, timingInfo = _ref10.timingInfo;
    if (!this.useDtsForTimestampOffset_) {
      return timingInfo.start;
    }
    if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === "number") {
      return videoTimingInfo.transmuxedDecodeStart;
    }
    if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === "number") {
      return audioTimingInfo.transmuxedDecodeStart;
    }
    return timingInfo.start;
  };
  _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_(segmentInfo) {
    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
    var trackInfo = this.getMediaInfo_();
    var useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
    var prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
    if (!prioritizedTimingInfo) {
      return;
    }
    segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === "number" ? (
      // End time may not exist in a case where we aren't parsing the full segment (one
      // current example is the case of fmp4), so use the rough duration to calculate an
      // end time.
      prioritizedTimingInfo.end
    ) : prioritizedTimingInfo.start + segmentInfo.duration;
  };
  _proto.handleAppendsDone_ = function handleAppendsDone_() {
    if (this.pendingSegment_) {
      this.trigger("appendsdone");
    }
    if (!this.pendingSegment_) {
      this.state = "READY";
      if (!this.paused()) {
        this.monitorBuffer_();
      }
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.updateTimingInfoEnd_(segmentInfo);
    if (this.shouldSaveSegmentTimingInfo_) {
      this.syncController_.saveSegmentTimingInfo({
        segmentInfo,
        shouldSaveTimelineMapping: this.loaderType_ === "main"
      });
    }
    var segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
    if (segmentDurationMessage) {
      if (segmentDurationMessage.severity === "warn") {
        videojs.log.warn(segmentDurationMessage.message);
      } else {
        this.logger_(segmentDurationMessage.message);
      }
    }
    this.recordThroughput_(segmentInfo);
    this.pendingSegment_ = null;
    this.state = "READY";
    if (segmentInfo.isSyncRequest) {
      this.trigger("syncinfoupdate");
      if (!segmentInfo.hasAppendedData_) {
        this.logger_("Throwing away un-appended sync request " + segmentInfoString(segmentInfo));
        return;
      }
    }
    this.logger_("Appended " + segmentInfoString(segmentInfo));
    this.addSegmentMetadataCue_(segmentInfo);
    this.fetchAtBuffer_ = true;
    if (this.currentTimeline_ !== segmentInfo.timeline) {
      this.timelineChangeController_.lastTimelineChange({
        type: this.loaderType_,
        from: this.currentTimeline_,
        to: segmentInfo.timeline
      });
      if (this.loaderType_ === "main" && !this.audioDisabled_) {
        this.timelineChangeController_.lastTimelineChange({
          type: "audio",
          from: this.currentTimeline_,
          to: segmentInfo.timeline
        });
      }
    }
    this.currentTimeline_ = segmentInfo.timeline;
    this.trigger("syncinfoupdate");
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
    var badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
    if (badSegmentGuess || badPartGuess) {
      this.logger_("bad " + (badSegmentGuess ? "segment" : "part") + " " + segmentInfoString(segmentInfo));
      this.resetEverything();
      return;
    }
    var isWalkingForward = this.mediaIndex !== null;
    if (isWalkingForward) {
      this.trigger("bandwidthupdate");
    }
    this.trigger("progress");
    this.mediaIndex = segmentInfo.mediaIndex;
    this.partIndex = segmentInfo.partIndex;
    if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {
      this.endOfStream();
    }
    this.trigger("appended");
    if (segmentInfo.hasAppendedData_) {
      this.mediaAppends++;
    }
    if (!this.paused()) {
      this.monitorBuffer_();
    }
  };
  _proto.recordThroughput_ = function recordThroughput_(segmentInfo) {
    if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
      this.logger_("Ignoring segment's throughput because its duration of " + segmentInfo.duration + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
      return;
    }
    var rate = this.throughput.rate;
    var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
    var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1e3);
    this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
  };
  _proto.addSegmentMetadataCue_ = function addSegmentMetadataCue_(segmentInfo) {
    if (!this.segmentMetadataTrack_) {
      return;
    }
    var segment = segmentInfo.segment;
    var start2 = segment.start;
    var end = segment.end;
    if (!finite(start2) || !finite(end)) {
      return;
    }
    removeCuesFromTrack(start2, end, this.segmentMetadataTrack_);
    var Cue = import_window6.default.WebKitDataCue || import_window6.default.VTTCue;
    var value = {
      custom: segment.custom,
      dateTimeObject: segment.dateTimeObject,
      dateTimeString: segment.dateTimeString,
      bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
      resolution: segmentInfo.playlist.attributes.RESOLUTION,
      codecs: segmentInfo.playlist.attributes.CODECS,
      byteLength: segmentInfo.byteLength,
      uri: segmentInfo.uri,
      timeline: segmentInfo.timeline,
      playlist: segmentInfo.playlist.id,
      start: start2,
      end
    };
    var data = JSON.stringify(value);
    var cue = new Cue(start2, end, data);
    cue.value = value;
    this.segmentMetadataTrack_.addCue(cue);
  };
  return SegmentLoader2;
}(videojs.EventTarget);
function noop() {
}
var toTitleCase2 = function toTitleCase3(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w2) {
    return w2.toUpperCase();
  });
};
var bufferTypes = ["video", "audio"];
var _updating = function updating(type2, sourceUpdater) {
  var sourceBuffer = sourceUpdater[type2 + "Buffer"];
  return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type2];
};
var nextQueueIndexOfType = function nextQueueIndexOfType2(type2, queue) {
  for (var i = 0; i < queue.length; i++) {
    var queueEntry = queue[i];
    if (queueEntry.type === "mediaSource") {
      return null;
    }
    if (queueEntry.type === type2) {
      return i;
    }
  }
  return null;
};
var shiftQueue = function shiftQueue2(type2, sourceUpdater) {
  if (sourceUpdater.queue.length === 0) {
    return;
  }
  var queueIndex = 0;
  var queueEntry = sourceUpdater.queue[queueIndex];
  if (queueEntry.type === "mediaSource") {
    if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== "closed") {
      sourceUpdater.queue.shift();
      queueEntry.action(sourceUpdater);
      if (queueEntry.doneFn) {
        queueEntry.doneFn();
      }
      shiftQueue2("audio", sourceUpdater);
      shiftQueue2("video", sourceUpdater);
    }
    return;
  }
  if (type2 === "mediaSource") {
    return;
  }
  if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === "closed" || _updating(type2, sourceUpdater)) {
    return;
  }
  if (queueEntry.type !== type2) {
    queueIndex = nextQueueIndexOfType(type2, sourceUpdater.queue);
    if (queueIndex === null) {
      return;
    }
    queueEntry = sourceUpdater.queue[queueIndex];
  }
  sourceUpdater.queue.splice(queueIndex, 1);
  sourceUpdater.queuePending[type2] = queueEntry;
  queueEntry.action(type2, sourceUpdater);
  if (!queueEntry.doneFn) {
    sourceUpdater.queuePending[type2] = null;
    shiftQueue2(type2, sourceUpdater);
    return;
  }
};
var cleanupBuffer = function cleanupBuffer2(type2, sourceUpdater) {
  var buffer = sourceUpdater[type2 + "Buffer"];
  var titleType = toTitleCase2(type2);
  if (!buffer) {
    return;
  }
  buffer.removeEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]);
  buffer.removeEventListener("error", sourceUpdater["on" + titleType + "Error_"]);
  sourceUpdater.codecs[type2] = null;
  sourceUpdater[type2 + "Buffer"] = null;
};
var inSourceBuffers = function inSourceBuffers2(mediaSource, sourceBuffer) {
  return mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
};
var actions = {
  appendBuffer: function appendBuffer(bytes, segmentInfo, onError2) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Appending segment " + segmentInfo.mediaIndex + "'s " + bytes.length + " bytes to " + type2 + "Buffer");
      try {
        sourceBuffer.appendBuffer(bytes);
      } catch (e) {
        sourceUpdater.logger_("Error with code " + e.code + " " + (e.code === QUOTA_EXCEEDED_ERR ? "(QUOTA_EXCEEDED_ERR) " : "") + ("when appending segment " + segmentInfo.mediaIndex + " to " + type2 + "Buffer"));
        sourceUpdater.queuePending[type2] = null;
        onError2(e);
      }
    };
  },
  remove: function remove(start2, end) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Removing " + start2 + " to " + end + " from " + type2 + "Buffer");
      try {
        sourceBuffer.remove(start2, end);
      } catch (e) {
        sourceUpdater.logger_("Remove " + start2 + " to " + end + " from " + type2 + "Buffer failed");
      }
    };
  },
  timestampOffset: function timestampOffset(offset) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Setting " + type2 + "timestampOffset to " + offset);
      sourceBuffer.timestampOffset = offset;
    };
  },
  callback: function callback(_callback) {
    return function(type2, sourceUpdater) {
      _callback();
    };
  },
  endOfStream: function endOfStream(error) {
    return function(sourceUpdater) {
      if (sourceUpdater.mediaSource.readyState !== "open") {
        return;
      }
      sourceUpdater.logger_("Calling mediaSource endOfStream(" + (error || "") + ")");
      try {
        sourceUpdater.mediaSource.endOfStream(error);
      } catch (e) {
        videojs.log.warn("Failed to call media source endOfStream", e);
      }
    };
  },
  duration: function duration4(_duration) {
    return function(sourceUpdater) {
      sourceUpdater.logger_("Setting mediaSource duration to " + _duration);
      try {
        sourceUpdater.mediaSource.duration = _duration;
      } catch (e) {
        videojs.log.warn("Failed to set media source duration", e);
      }
    };
  },
  abort: function abort() {
    return function(type2, sourceUpdater) {
      if (sourceUpdater.mediaSource.readyState !== "open") {
        return;
      }
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("calling abort on " + type2 + "Buffer");
      try {
        sourceBuffer.abort();
      } catch (e) {
        videojs.log.warn("Failed to abort on " + type2 + "Buffer", e);
      }
    };
  },
  addSourceBuffer: function addSourceBuffer(type2, codec) {
    return function(sourceUpdater) {
      var titleType = toTitleCase2(type2);
      var mime = getMimeForCodec(codec);
      sourceUpdater.logger_("Adding " + type2 + "Buffer with codec " + codec + " to mediaSource");
      var sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
      sourceBuffer.addEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]);
      sourceBuffer.addEventListener("error", sourceUpdater["on" + titleType + "Error_"]);
      sourceUpdater.codecs[type2] = codec;
      sourceUpdater[type2 + "Buffer"] = sourceBuffer;
    };
  },
  removeSourceBuffer: function removeSourceBuffer(type2) {
    return function(sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      cleanupBuffer(type2, sourceUpdater);
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Removing " + type2 + "Buffer with codec " + sourceUpdater.codecs[type2] + " from mediaSource");
      try {
        sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
      } catch (e) {
        videojs.log.warn("Failed to removeSourceBuffer " + type2 + "Buffer", e);
      }
    };
  },
  changeType: function changeType(codec) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      var mime = getMimeForCodec(codec);
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      if (sourceUpdater.codecs[type2] === codec) {
        return;
      }
      sourceUpdater.logger_("changing " + type2 + "Buffer codec from " + sourceUpdater.codecs[type2] + " to " + codec);
      try {
        sourceBuffer.changeType(mime);
        sourceUpdater.codecs[type2] = codec;
      } catch (e) {
        videojs.log.warn("Failed to changeType on " + type2 + "Buffer", e);
      }
    };
  }
};
var pushQueue = function pushQueue2(_ref) {
  var type2 = _ref.type, sourceUpdater = _ref.sourceUpdater, action = _ref.action, doneFn = _ref.doneFn, name = _ref.name;
  sourceUpdater.queue.push({
    type: type2,
    action,
    doneFn,
    name
  });
  shiftQueue(type2, sourceUpdater);
};
var onUpdateend = function onUpdateend2(type2, sourceUpdater) {
  return function(e) {
    if (sourceUpdater.queuePending[type2]) {
      var doneFn = sourceUpdater.queuePending[type2].doneFn;
      sourceUpdater.queuePending[type2] = null;
      if (doneFn) {
        doneFn(sourceUpdater[type2 + "Error_"]);
      }
    }
    shiftQueue(type2, sourceUpdater);
  };
};
var SourceUpdater = function(_videojs$EventTarget) {
  _inheritsLoose(SourceUpdater2, _videojs$EventTarget);
  function SourceUpdater2(mediaSource) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.mediaSource = mediaSource;
    _this.sourceopenListener_ = function() {
      return shiftQueue("mediaSource", _assertThisInitialized(_this));
    };
    _this.mediaSource.addEventListener("sourceopen", _this.sourceopenListener_);
    _this.logger_ = logger("SourceUpdater");
    _this.audioTimestampOffset_ = 0;
    _this.videoTimestampOffset_ = 0;
    _this.queue = [];
    _this.queuePending = {
      audio: null,
      video: null
    };
    _this.delayedAudioAppendQueue_ = [];
    _this.videoAppendQueued_ = false;
    _this.codecs = {};
    _this.onVideoUpdateEnd_ = onUpdateend("video", _assertThisInitialized(_this));
    _this.onAudioUpdateEnd_ = onUpdateend("audio", _assertThisInitialized(_this));
    _this.onVideoError_ = function(e) {
      _this.videoError_ = e;
    };
    _this.onAudioError_ = function(e) {
      _this.audioError_ = e;
    };
    _this.createdSourceBuffers_ = false;
    _this.initializedEme_ = false;
    _this.triggeredReady_ = false;
    return _this;
  }
  var _proto = SourceUpdater2.prototype;
  _proto.initializedEme = function initializedEme() {
    this.initializedEme_ = true;
    this.triggerReady();
  };
  _proto.hasCreatedSourceBuffers = function hasCreatedSourceBuffers() {
    return this.createdSourceBuffers_;
  };
  _proto.hasInitializedAnyEme = function hasInitializedAnyEme() {
    return this.initializedEme_;
  };
  _proto.ready = function ready() {
    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
  };
  _proto.createSourceBuffers = function createSourceBuffers(codecs) {
    if (this.hasCreatedSourceBuffers()) {
      return;
    }
    this.addOrChangeSourceBuffers(codecs);
    this.createdSourceBuffers_ = true;
    this.trigger("createdsourcebuffers");
    this.triggerReady();
  };
  _proto.triggerReady = function triggerReady() {
    if (this.ready() && !this.triggeredReady_) {
      this.triggeredReady_ = true;
      this.trigger("ready");
    }
  };
  _proto.addSourceBuffer = function addSourceBuffer2(type2, codec) {
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.addSourceBuffer(type2, codec),
      name: "addSourceBuffer"
    });
  };
  _proto.abort = function abort2(type2) {
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.abort(type2),
      name: "abort"
    });
  };
  _proto.removeSourceBuffer = function removeSourceBuffer2(type2) {
    if (!this.canRemoveSourceBuffer()) {
      videojs.log.error("removeSourceBuffer is not supported!");
      return;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.removeSourceBuffer(type2),
      name: "removeSourceBuffer"
    });
  };
  _proto.canRemoveSourceBuffer = function canRemoveSourceBuffer() {
    return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && import_window6.default.MediaSource && import_window6.default.MediaSource.prototype && typeof import_window6.default.MediaSource.prototype.removeSourceBuffer === "function";
  };
  SourceUpdater2.canChangeType = function canChangeType() {
    return import_window6.default.SourceBuffer && import_window6.default.SourceBuffer.prototype && typeof import_window6.default.SourceBuffer.prototype.changeType === "function";
  };
  _proto.canChangeType = function canChangeType() {
    return this.constructor.canChangeType();
  };
  _proto.changeType = function changeType2(type2, codec) {
    if (!this.canChangeType()) {
      videojs.log.error("changeType is not supported!");
      return;
    }
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.changeType(codec),
      name: "changeType"
    });
  };
  _proto.addOrChangeSourceBuffers = function addOrChangeSourceBuffers(codecs) {
    var _this2 = this;
    if (!codecs || typeof codecs !== "object" || Object.keys(codecs).length === 0) {
      throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
    }
    Object.keys(codecs).forEach(function(type2) {
      var codec = codecs[type2];
      if (!_this2.hasCreatedSourceBuffers()) {
        return _this2.addSourceBuffer(type2, codec);
      }
      if (_this2.canChangeType()) {
        _this2.changeType(type2, codec);
      }
    });
  };
  _proto.appendBuffer = function appendBuffer2(options, doneFn) {
    var _this3 = this;
    var segmentInfo = options.segmentInfo, type2 = options.type, bytes = options.bytes;
    this.processedAppend_ = true;
    if (type2 === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
      this.delayedAudioAppendQueue_.push([options, doneFn]);
      this.logger_("delayed audio append of " + bytes.length + " until video append");
      return;
    }
    var onError2 = doneFn;
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.appendBuffer(bytes, segmentInfo || {
        mediaIndex: -1
      }, onError2),
      doneFn,
      name: "appendBuffer"
    });
    if (type2 === "video") {
      this.videoAppendQueued_ = true;
      if (!this.delayedAudioAppendQueue_.length) {
        return;
      }
      var queue = this.delayedAudioAppendQueue_.slice();
      this.logger_("queuing delayed audio " + queue.length + " appendBuffers");
      this.delayedAudioAppendQueue_.length = 0;
      queue.forEach(function(que) {
        _this3.appendBuffer.apply(_this3, que);
      });
    }
  };
  _proto.audioBuffered = function audioBuffered() {
    if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {
      return videojs.createTimeRange();
    }
    return this.audioBuffer.buffered ? this.audioBuffer.buffered : videojs.createTimeRange();
  };
  _proto.videoBuffered = function videoBuffered() {
    if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {
      return videojs.createTimeRange();
    }
    return this.videoBuffer.buffered ? this.videoBuffer.buffered : videojs.createTimeRange();
  };
  _proto.buffered = function buffered() {
    var video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
    var audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
    if (audio && !video) {
      return this.audioBuffered();
    }
    if (video && !audio) {
      return this.videoBuffered();
    }
    return bufferIntersection(this.audioBuffered(), this.videoBuffered());
  };
  _proto.setDuration = function setDuration(duration5, doneFn) {
    if (doneFn === void 0) {
      doneFn = noop;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.duration(duration5),
      name: "duration",
      doneFn
    });
  };
  _proto.endOfStream = function endOfStream2(error, doneFn) {
    if (error === void 0) {
      error = null;
    }
    if (doneFn === void 0) {
      doneFn = noop;
    }
    if (typeof error !== "string") {
      error = void 0;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.endOfStream(error),
      name: "endOfStream",
      doneFn
    });
  };
  _proto.removeAudio = function removeAudio(start2, end, done) {
    if (done === void 0) {
      done = noop;
    }
    if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
      done();
      return;
    }
    pushQueue({
      type: "audio",
      sourceUpdater: this,
      action: actions.remove(start2, end),
      doneFn: done,
      name: "remove"
    });
  };
  _proto.removeVideo = function removeVideo(start2, end, done) {
    if (done === void 0) {
      done = noop;
    }
    if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
      done();
      return;
    }
    pushQueue({
      type: "video",
      sourceUpdater: this,
      action: actions.remove(start2, end),
      doneFn: done,
      name: "remove"
    });
  };
  _proto.updating = function updating2() {
    if (_updating("audio", this) || _updating("video", this)) {
      return true;
    }
    return false;
  };
  _proto.audioTimestampOffset = function audioTimestampOffset(offset) {
    if (typeof offset !== "undefined" && this.audioBuffer && // no point in updating if it's the same
    this.audioTimestampOffset_ !== offset) {
      pushQueue({
        type: "audio",
        sourceUpdater: this,
        action: actions.timestampOffset(offset),
        name: "timestampOffset"
      });
      this.audioTimestampOffset_ = offset;
    }
    return this.audioTimestampOffset_;
  };
  _proto.videoTimestampOffset = function videoTimestampOffset(offset) {
    if (typeof offset !== "undefined" && this.videoBuffer && // no point in updating if it's the same
    this.videoTimestampOffset !== offset) {
      pushQueue({
        type: "video",
        sourceUpdater: this,
        action: actions.timestampOffset(offset),
        name: "timestampOffset"
      });
      this.videoTimestampOffset_ = offset;
    }
    return this.videoTimestampOffset_;
  };
  _proto.audioQueueCallback = function audioQueueCallback(callback2) {
    if (!this.audioBuffer) {
      return;
    }
    pushQueue({
      type: "audio",
      sourceUpdater: this,
      action: actions.callback(callback2),
      name: "callback"
    });
  };
  _proto.videoQueueCallback = function videoQueueCallback(callback2) {
    if (!this.videoBuffer) {
      return;
    }
    pushQueue({
      type: "video",
      sourceUpdater: this,
      action: actions.callback(callback2),
      name: "callback"
    });
  };
  _proto.dispose = function dispose() {
    var _this4 = this;
    this.trigger("dispose");
    bufferTypes.forEach(function(type2) {
      _this4.abort(type2);
      if (_this4.canRemoveSourceBuffer()) {
        _this4.removeSourceBuffer(type2);
      } else {
        _this4[type2 + "QueueCallback"](function() {
          return cleanupBuffer(type2, _this4);
        });
      }
    });
    this.videoAppendQueued_ = false;
    this.delayedAudioAppendQueue_.length = 0;
    if (this.sourceopenListener_) {
      this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_);
    }
    this.off();
  };
  return SourceUpdater2;
}(videojs.EventTarget);
var uint8ToUtf8 = function uint8ToUtf82(uintArray) {
  return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
};
var VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map(function(_char3) {
  return _char3.charCodeAt(0);
}));
var NoVttJsError = function(_Error) {
  _inheritsLoose(NoVttJsError2, _Error);
  function NoVttJsError2() {
    return _Error.call(this, "Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.") || this;
  }
  return NoVttJsError2;
}(_wrapNativeSuper(Error));
var VTTSegmentLoader = function(_SegmentLoader) {
  _inheritsLoose(VTTSegmentLoader2, _SegmentLoader);
  function VTTSegmentLoader2(settings, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _SegmentLoader.call(this, settings, options) || this;
    _this.mediaSource_ = null;
    _this.subtitlesTrack_ = null;
    _this.loaderType_ = "subtitle";
    _this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;
    _this.loadVttJs = settings.loadVttJs;
    _this.shouldSaveSegmentTimingInfo_ = false;
    return _this;
  }
  var _proto = VTTSegmentLoader2.prototype;
  _proto.createTransmuxer_ = function createTransmuxer_() {
    return null;
  };
  _proto.buffered_ = function buffered_() {
    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {
      return videojs.createTimeRanges();
    }
    var cues = this.subtitlesTrack_.cues;
    var start2 = cues[0].startTime;
    var end = cues[cues.length - 1].startTime;
    return videojs.createTimeRanges([[start2, end]]);
  };
  _proto.initSegmentForMap = function initSegmentForMap(map, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!map) {
      return null;
    }
    var id = initSegmentId(map);
    var storedMap = this.initSegments_[id];
    if (set4 && !storedMap && map.bytes) {
      var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;
      var combinedSegment = new Uint8Array(combinedByteLength);
      combinedSegment.set(map.bytes);
      combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);
      this.initSegments_[id] = storedMap = {
        resolvedUri: map.resolvedUri,
        byterange: map.byterange,
        bytes: combinedSegment
      };
    }
    return storedMap || map;
  };
  _proto.couldBeginLoading_ = function couldBeginLoading_() {
    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
  };
  _proto.init_ = function init_() {
    this.state = "READY";
    this.resetEverything();
    return this.monitorBuffer_();
  };
  _proto.track = function track(_track) {
    if (typeof _track === "undefined") {
      return this.subtitlesTrack_;
    }
    this.subtitlesTrack_ = _track;
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      this.init_();
    }
    return this.subtitlesTrack_;
  };
  _proto.remove = function remove2(start2, end) {
    removeCuesFromTrack(start2, end, this.subtitlesTrack_);
  };
  _proto.fillBuffer_ = function fillBuffer_() {
    var _this2 = this;
    var segmentInfo = this.chooseNextRequest_();
    if (!segmentInfo) {
      return;
    }
    if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
      var checkTimestampOffset = function checkTimestampOffset2() {
        _this2.state = "READY";
        if (!_this2.paused()) {
          _this2.monitorBuffer_();
        }
      };
      this.syncController_.one("timestampoffset", checkTimestampOffset);
      this.state = "WAITING_ON_TIMELINE";
      return;
    }
    this.loadSegment_(segmentInfo);
  };
  _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_() {
    return null;
  };
  _proto.chooseNextRequest_ = function chooseNextRequest_() {
    return this.skipEmptySegments_(_SegmentLoader.prototype.chooseNextRequest_.call(this));
  };
  _proto.skipEmptySegments_ = function skipEmptySegments_(segmentInfo) {
    while (segmentInfo && segmentInfo.segment.empty) {
      if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
        segmentInfo = null;
        break;
      }
      segmentInfo = this.generateSegmentInfo_({
        playlist: segmentInfo.playlist,
        mediaIndex: segmentInfo.mediaIndex + 1,
        startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
        isSyncRequest: segmentInfo.isSyncRequest
      });
    }
    return segmentInfo;
  };
  _proto.stopForError = function stopForError(error) {
    this.error(error);
    this.state = "READY";
    this.pause();
    this.trigger("error");
  };
  _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
    var _this3 = this;
    if (!this.subtitlesTrack_) {
      this.state = "READY";
      return;
    }
    this.saveTransferStats_(simpleSegment.stats);
    if (!this.pendingSegment_) {
      this.state = "READY";
      this.mediaRequestsAborted += 1;
      return;
    }
    if (error) {
      if (error.code === REQUEST_ERRORS.TIMEOUT) {
        this.handleTimeout_();
      }
      if (error.code === REQUEST_ERRORS.ABORTED) {
        this.mediaRequestsAborted += 1;
      } else {
        this.mediaRequestsErrored += 1;
      }
      this.stopForError(error);
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
    if (simpleSegment.key) {
      this.segmentKey(simpleSegment.key, true);
    }
    this.state = "APPENDING";
    this.trigger("appending");
    var segment = segmentInfo.segment;
    if (segment.map) {
      segment.map.bytes = simpleSegment.map.bytes;
    }
    segmentInfo.bytes = simpleSegment.bytes;
    if (typeof import_window6.default.WebVTT !== "function" && typeof this.loadVttJs === "function") {
      this.state = "WAITING_ON_VTTJS";
      this.loadVttJs().then(function() {
        return _this3.segmentRequestFinished_(error, simpleSegment, result);
      }, function() {
        return _this3.stopForError({
          message: "Error loading vtt.js"
        });
      });
      return;
    }
    segment.requested = true;
    try {
      this.parseVTTCues_(segmentInfo);
    } catch (e) {
      this.stopForError({
        message: e.message
      });
      return;
    }
    this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
    if (segmentInfo.cues.length) {
      segmentInfo.timingInfo = {
        start: segmentInfo.cues[0].startTime,
        end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
      };
    } else {
      segmentInfo.timingInfo = {
        start: segmentInfo.startOfSegment,
        end: segmentInfo.startOfSegment + segmentInfo.duration
      };
    }
    if (segmentInfo.isSyncRequest) {
      this.trigger("syncinfoupdate");
      this.pendingSegment_ = null;
      this.state = "READY";
      return;
    }
    segmentInfo.byteLength = segmentInfo.bytes.byteLength;
    this.mediaSecondsLoaded += segment.duration;
    segmentInfo.cues.forEach(function(cue) {
      _this3.subtitlesTrack_.addCue(_this3.featuresNativeTextTracks_ ? new import_window6.default.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);
    });
    removeDuplicateCuesFromTrack(this.subtitlesTrack_);
    this.handleAppendsDone_();
  };
  _proto.handleData_ = function handleData_3() {
  };
  _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_() {
  };
  _proto.parseVTTCues_ = function parseVTTCues_(segmentInfo) {
    var decoder;
    var decodeBytesToString = false;
    if (typeof import_window6.default.WebVTT !== "function") {
      throw new NoVttJsError();
    }
    if (typeof import_window6.default.TextDecoder === "function") {
      decoder = new import_window6.default.TextDecoder("utf8");
    } else {
      decoder = import_window6.default.WebVTT.StringDecoder();
      decodeBytesToString = true;
    }
    var parser6 = new import_window6.default.WebVTT.Parser(import_window6.default, import_window6.default.vttjs, decoder);
    segmentInfo.cues = [];
    segmentInfo.timestampmap = {
      MPEGTS: 0,
      LOCAL: 0
    };
    parser6.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
    parser6.ontimestampmap = function(map) {
      segmentInfo.timestampmap = map;
    };
    parser6.onparsingerror = function(error) {
      videojs.log.warn("Error encountered when parsing cues: " + error.message);
    };
    if (segmentInfo.segment.map) {
      var mapData = segmentInfo.segment.map.bytes;
      if (decodeBytesToString) {
        mapData = uint8ToUtf8(mapData);
      }
      parser6.parse(mapData);
    }
    var segmentData = segmentInfo.bytes;
    if (decodeBytesToString) {
      segmentData = uint8ToUtf8(segmentData);
    }
    parser6.parse(segmentData);
    parser6.flush();
  };
  _proto.updateTimeMapping_ = function updateTimeMapping_(segmentInfo, mappingObj, playlist) {
    var segment = segmentInfo.segment;
    if (!mappingObj) {
      return;
    }
    if (!segmentInfo.cues.length) {
      segment.empty = true;
      return;
    }
    var timestampmap = segmentInfo.timestampmap;
    var diff = timestampmap.MPEGTS / import_clock.ONE_SECOND_IN_TS - timestampmap.LOCAL + mappingObj.mapping;
    segmentInfo.cues.forEach(function(cue) {
      cue.startTime += diff;
      cue.endTime += diff;
    });
    if (!playlist.syncInfo) {
      var firstStart = segmentInfo.cues[0].startTime;
      var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
      playlist.syncInfo = {
        mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
        time: Math.min(firstStart, lastStart - segment.duration)
      };
    }
  };
  return VTTSegmentLoader2;
}(SegmentLoader);
var findAdCue = function findAdCue2(track, mediaTime) {
  var cues = track.cues;
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];
    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {
      return cue;
    }
  }
  return null;
};
var updateAdCues = function updateAdCues2(media, track, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (!media.segments) {
    return;
  }
  var mediaTime = offset;
  var cue;
  for (var i = 0; i < media.segments.length; i++) {
    var segment = media.segments[i];
    if (!cue) {
      cue = findAdCue(track, mediaTime + segment.duration / 2);
    }
    if (cue) {
      if ("cueIn" in segment) {
        cue.endTime = mediaTime;
        cue.adEndTime = mediaTime;
        mediaTime += segment.duration;
        cue = null;
        continue;
      }
      if (mediaTime < cue.endTime) {
        mediaTime += segment.duration;
        continue;
      }
      cue.endTime += segment.duration;
    } else {
      if ("cueOut" in segment) {
        cue = new import_window6.default.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);
        cue.adStartTime = mediaTime;
        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
        track.addCue(cue);
      }
      if ("cueOutCont" in segment) {
        var _segment$cueOutCont$s = segment.cueOutCont.split("/").map(parseFloat), adOffset = _segment$cueOutCont$s[0], adTotal = _segment$cueOutCont$s[1];
        cue = new import_window6.default.VTTCue(mediaTime, mediaTime + segment.duration, "");
        cue.adStartTime = mediaTime - adOffset;
        cue.adEndTime = cue.adStartTime + adTotal;
        track.addCue(cue);
      }
    }
    mediaTime += segment.duration;
  }
};
var MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
var syncPointStrategies = [
  // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
  //                the equivalence display-time 0 === segment-index 0
  {
    name: "VOD",
    run: function run(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (duration5 !== Infinity) {
        var syncPoint = {
          time: 0,
          segmentIndex: 0,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  },
  // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
  {
    name: "ProgramDateTime",
    run: function run2(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (!Object.keys(syncController.timelineToDatetimeMappings).length) {
        return null;
      }
      var syncPoint = null;
      var lastDistance = null;
      var partsAndSegments = getPartsAndSegments(playlist);
      currentTime = currentTime || 0;
      for (var i = 0; i < partsAndSegments.length; i++) {
        var index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        var partAndSegment = partsAndSegments[index];
        var segment = partAndSegment.segment;
        var datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
        if (!datetimeMapping || !segment.dateTimeObject) {
          continue;
        }
        var segmentTime = segment.dateTimeObject.getTime() / 1e3;
        var start2 = segmentTime + datetimeMapping;
        if (segment.parts && typeof partAndSegment.partIndex === "number") {
          for (var z2 = 0; z2 < partAndSegment.partIndex; z2++) {
            start2 += segment.parts[z2].duration;
          }
        }
        var distance = Math.abs(currentTime - start2);
        if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {
          break;
        }
        lastDistance = distance;
        syncPoint = {
          time: start2,
          segmentIndex: partAndSegment.segmentIndex,
          partIndex: partAndSegment.partIndex
        };
      }
      return syncPoint;
    }
  },
  // Stategy "Segment": We have a known time mapping for a timeline and a
  //                    segment in the current timeline with timing data
  {
    name: "Segment",
    run: function run3(syncController, playlist, duration5, currentTimeline, currentTime) {
      var syncPoint = null;
      var lastDistance = null;
      currentTime = currentTime || 0;
      var partsAndSegments = getPartsAndSegments(playlist);
      for (var i = 0; i < partsAndSegments.length; i++) {
        var index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        var partAndSegment = partsAndSegments[index];
        var segment = partAndSegment.segment;
        var start2 = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
        if (segment.timeline === currentTimeline && typeof start2 !== "undefined") {
          var distance = Math.abs(currentTime - start2);
          if (lastDistance !== null && lastDistance < distance) {
            break;
          }
          if (!syncPoint || lastDistance === null || lastDistance >= distance) {
            lastDistance = distance;
            syncPoint = {
              time: start2,
              segmentIndex: partAndSegment.segmentIndex,
              partIndex: partAndSegment.partIndex
            };
          }
        }
      }
      return syncPoint;
    }
  },
  // Stategy "Discontinuity": We have a discontinuity with a known
  //                          display-time
  {
    name: "Discontinuity",
    run: function run4(syncController, playlist, duration5, currentTimeline, currentTime) {
      var syncPoint = null;
      currentTime = currentTime || 0;
      if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
        var lastDistance = null;
        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {
          var segmentIndex = playlist.discontinuityStarts[i];
          var discontinuity = playlist.discontinuitySequence + i + 1;
          var discontinuitySync = syncController.discontinuities[discontinuity];
          if (discontinuitySync) {
            var distance = Math.abs(currentTime - discontinuitySync.time);
            if (lastDistance !== null && lastDistance < distance) {
              break;
            }
            if (!syncPoint || lastDistance === null || lastDistance >= distance) {
              lastDistance = distance;
              syncPoint = {
                time: discontinuitySync.time,
                segmentIndex,
                partIndex: null
              };
            }
          }
        }
      }
      return syncPoint;
    }
  },
  // Stategy "Playlist": We have a playlist with a known mapping of
  //                     segment index to display time
  {
    name: "Playlist",
    run: function run5(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (playlist.syncInfo) {
        var syncPoint = {
          time: playlist.syncInfo.time,
          segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  }
];
var SyncController = function(_videojs$EventTarget) {
  _inheritsLoose(SyncController2, _videojs$EventTarget);
  function SyncController2(options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.timelines = [];
    _this.discontinuities = [];
    _this.timelineToDatetimeMappings = {};
    _this.logger_ = logger("SyncController");
    return _this;
  }
  var _proto = SyncController2.prototype;
  _proto.getSyncPoint = function getSyncPoint(playlist, duration5, currentTimeline, currentTime) {
    var syncPoints = this.runStrategies_(playlist, duration5, currentTimeline, currentTime);
    if (!syncPoints.length) {
      return null;
    }
    return this.selectSyncPoint_(syncPoints, {
      key: "time",
      value: currentTime
    });
  };
  _proto.getExpiredTime = function getExpiredTime(playlist, duration5) {
    if (!playlist || !playlist.segments) {
      return null;
    }
    var syncPoints = this.runStrategies_(playlist, duration5, playlist.discontinuitySequence, 0);
    if (!syncPoints.length) {
      return null;
    }
    var syncPoint = this.selectSyncPoint_(syncPoints, {
      key: "segmentIndex",
      value: 0
    });
    if (syncPoint.segmentIndex > 0) {
      syncPoint.time *= -1;
    }
    return Math.abs(syncPoint.time + sumDurations({
      defaultDuration: playlist.targetDuration,
      durationList: playlist.segments,
      startIndex: syncPoint.segmentIndex,
      endIndex: 0
    }));
  };
  _proto.runStrategies_ = function runStrategies_(playlist, duration5, currentTimeline, currentTime) {
    var syncPoints = [];
    for (var i = 0; i < syncPointStrategies.length; i++) {
      var strategy = syncPointStrategies[i];
      var syncPoint = strategy.run(this, playlist, duration5, currentTimeline, currentTime);
      if (syncPoint) {
        syncPoint.strategy = strategy.name;
        syncPoints.push({
          strategy: strategy.name,
          syncPoint
        });
      }
    }
    return syncPoints;
  };
  _proto.selectSyncPoint_ = function selectSyncPoint_(syncPoints, target) {
    var bestSyncPoint = syncPoints[0].syncPoint;
    var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
    var bestStrategy = syncPoints[0].strategy;
    for (var i = 1; i < syncPoints.length; i++) {
      var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
      if (newDistance < bestDistance) {
        bestDistance = newDistance;
        bestSyncPoint = syncPoints[i].syncPoint;
        bestStrategy = syncPoints[i].strategy;
      }
    }
    this.logger_("syncPoint for [" + target.key + ": " + target.value + "] chosen with strategy" + (" [" + bestStrategy + "]: [time:" + bestSyncPoint.time + ",") + (" segmentIndex:" + bestSyncPoint.segmentIndex) + (typeof bestSyncPoint.partIndex === "number" ? ",partIndex:" + bestSyncPoint.partIndex : "") + "]");
    return bestSyncPoint;
  };
  _proto.saveExpiredSegmentInfo = function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
    if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
      videojs.log.warn("Not saving expired segment info. Media sequence gap " + mediaSequenceDiff + " is too large.");
      return;
    }
    for (var i = mediaSequenceDiff - 1; i >= 0; i--) {
      var lastRemovedSegment = oldPlaylist.segments[i];
      if (lastRemovedSegment && typeof lastRemovedSegment.start !== "undefined") {
        newPlaylist.syncInfo = {
          mediaSequence: oldPlaylist.mediaSequence + i,
          time: lastRemovedSegment.start
        };
        this.logger_("playlist refresh sync: [time:" + newPlaylist.syncInfo.time + "," + (" mediaSequence: " + newPlaylist.syncInfo.mediaSequence + "]"));
        this.trigger("syncinfoupdate");
        break;
      }
    }
  };
  _proto.setDateTimeMappingForStart = function setDateTimeMappingForStart(playlist) {
    this.timelineToDatetimeMappings = {};
    if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
      var firstSegment = playlist.segments[0];
      var playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1e3;
      this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
    }
  };
  _proto.saveSegmentTimingInfo = function saveSegmentTimingInfo(_ref) {
    var segmentInfo = _ref.segmentInfo, shouldSaveTimelineMapping = _ref.shouldSaveTimelineMapping;
    var didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
    var segment = segmentInfo.segment;
    if (didCalculateSegmentTimeMapping) {
      this.saveDiscontinuitySyncInfo_(segmentInfo);
      if (!segmentInfo.playlist.syncInfo) {
        segmentInfo.playlist.syncInfo = {
          mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
          time: segment.start
        };
      }
    }
    var dateTime = segment.dateTimeObject;
    if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {
      this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1e3);
    }
  };
  _proto.timestampOffsetForTimeline = function timestampOffsetForTimeline(timeline) {
    if (typeof this.timelines[timeline] === "undefined") {
      return null;
    }
    return this.timelines[timeline].time;
  };
  _proto.mappingForTimeline = function mappingForTimeline(timeline) {
    if (typeof this.timelines[timeline] === "undefined") {
      return null;
    }
    return this.timelines[timeline].mapping;
  };
  _proto.calculateSegmentTimeMapping_ = function calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var mappingObj = this.timelines[segmentInfo.timeline];
    var start2;
    var end;
    if (typeof segmentInfo.timestampOffset === "number") {
      mappingObj = {
        time: segmentInfo.startOfSegment,
        mapping: segmentInfo.startOfSegment - timingInfo.start
      };
      if (shouldSaveTimelineMapping) {
        this.timelines[segmentInfo.timeline] = mappingObj;
        this.trigger("timestampoffset");
        this.logger_("time mapping for timeline " + segmentInfo.timeline + ": " + ("[time: " + mappingObj.time + "] [mapping: " + mappingObj.mapping + "]"));
      }
      start2 = segmentInfo.startOfSegment;
      end = timingInfo.end + mappingObj.mapping;
    } else if (mappingObj) {
      start2 = timingInfo.start + mappingObj.mapping;
      end = timingInfo.end + mappingObj.mapping;
    } else {
      return false;
    }
    if (part) {
      part.start = start2;
      part.end = end;
    }
    if (!segment.start || start2 < segment.start) {
      segment.start = start2;
    }
    segment.end = end;
    return true;
  };
  _proto.saveDiscontinuitySyncInfo_ = function saveDiscontinuitySyncInfo_(segmentInfo) {
    var playlist = segmentInfo.playlist;
    var segment = segmentInfo.segment;
    if (segment.discontinuity) {
      this.discontinuities[segment.timeline] = {
        time: segment.start,
        accuracy: 0
      };
    } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {
        var segmentIndex = playlist.discontinuityStarts[i];
        var discontinuity = playlist.discontinuitySequence + i + 1;
        var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
        var accuracy = Math.abs(mediaIndexDiff);
        if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
          var time = void 0;
          if (mediaIndexDiff < 0) {
            time = segment.start - sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: playlist.segments,
              startIndex: segmentInfo.mediaIndex,
              endIndex: segmentIndex
            });
          } else {
            time = segment.end + sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: playlist.segments,
              startIndex: segmentInfo.mediaIndex + 1,
              endIndex: segmentIndex
            });
          }
          this.discontinuities[discontinuity] = {
            time,
            accuracy
          };
        }
      }
    }
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.off();
  };
  return SyncController2;
}(videojs.EventTarget);
var TimelineChangeController = function(_videojs$EventTarget) {
  _inheritsLoose(TimelineChangeController2, _videojs$EventTarget);
  function TimelineChangeController2() {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.pendingTimelineChanges_ = {};
    _this.lastTimelineChanges_ = {};
    return _this;
  }
  var _proto = TimelineChangeController2.prototype;
  _proto.clearPendingTimelineChange = function clearPendingTimelineChange(type2) {
    this.pendingTimelineChanges_[type2] = null;
    this.trigger("pendingtimelinechange");
  };
  _proto.pendingTimelineChange = function pendingTimelineChange(_ref) {
    var type2 = _ref.type, from3 = _ref.from, to = _ref.to;
    if (typeof from3 === "number" && typeof to === "number") {
      this.pendingTimelineChanges_[type2] = {
        type: type2,
        from: from3,
        to
      };
      this.trigger("pendingtimelinechange");
    }
    return this.pendingTimelineChanges_[type2];
  };
  _proto.lastTimelineChange = function lastTimelineChange(_ref2) {
    var type2 = _ref2.type, from3 = _ref2.from, to = _ref2.to;
    if (typeof from3 === "number" && typeof to === "number") {
      this.lastTimelineChanges_[type2] = {
        type: type2,
        from: from3,
        to
      };
      delete this.pendingTimelineChanges_[type2];
      this.trigger("timelinechange");
    }
    return this.lastTimelineChanges_[type2];
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.pendingTimelineChanges_ = {};
    this.lastTimelineChanges_ = {};
    this.off();
  };
  return TimelineChangeController2;
}(videojs.EventTarget);
var workerCode = transform(getWorkerString(function() {
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function createCommonjsModule(fn, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: function require2(path, base) {
        return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
      }
    }, fn(module, module.exports), module.exports;
  }
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var createClass = createCommonjsModule(function(module) {
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    module.exports = _createClass;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var setPrototypeOf = createCommonjsModule(function(module) {
    function _setPrototypeOf2(o, p) {
      module.exports = _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
      return _setPrototypeOf2(o, p);
    }
    module.exports = _setPrototypeOf2;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var inheritsLoose = createCommonjsModule(function(module) {
    function _inheritsLoose2(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      setPrototypeOf(subClass, superClass);
    }
    module.exports = _inheritsLoose2;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var Stream2 = function() {
    function Stream3() {
      this.listeners = {};
    }
    var _proto = Stream3.prototype;
    _proto.on = function on3(type2, listener) {
      if (!this.listeners[type2]) {
        this.listeners[type2] = [];
      }
      this.listeners[type2].push(listener);
    };
    _proto.off = function off2(type2, listener) {
      if (!this.listeners[type2]) {
        return false;
      }
      var index = this.listeners[type2].indexOf(listener);
      this.listeners[type2] = this.listeners[type2].slice(0);
      this.listeners[type2].splice(index, 1);
      return index > -1;
    };
    _proto.trigger = function trigger2(type2) {
      var callbacks = this.listeners[type2];
      if (!callbacks) {
        return;
      }
      if (arguments.length === 2) {
        var length = callbacks.length;
        for (var i = 0; i < length; ++i) {
          callbacks[i].call(this, arguments[1]);
        }
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        var _length = callbacks.length;
        for (var _i = 0; _i < _length; ++_i) {
          callbacks[_i].apply(this, args);
        }
      }
    };
    _proto.dispose = function dispose() {
      this.listeners = {};
    };
    _proto.pipe = function pipe(destination) {
      this.on("data", function(data) {
        destination.push(data);
      });
    };
    return Stream3;
  }();
  function unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
  var precompute = function precompute2() {
    var tables = [[[], [], [], [], []], [[], [], [], [], []]];
    var encTable = tables[0];
    var decTable = tables[1];
    var sbox = encTable[4];
    var sboxInv = decTable[4];
    var i;
    var x;
    var xInv;
    var d3 = [];
    var th = [];
    var x2;
    var x4;
    var x8;
    var s;
    var tEnc;
    var tDec;
    for (i = 0; i < 256; i++) {
      th[(d3[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
    }
    for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
      s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
      s = s >> 8 ^ s & 255 ^ 99;
      sbox[x] = s;
      sboxInv[s] = x;
      x8 = d3[x4 = d3[x2 = d3[x]]];
      tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      tEnc = d3[s] * 257 ^ s * 16843008;
      for (i = 0; i < 4; i++) {
        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
      }
    }
    for (i = 0; i < 5; i++) {
      encTable[i] = encTable[i].slice(0);
      decTable[i] = decTable[i].slice(0);
    }
    return tables;
  };
  var aesTables = null;
  var AES = function() {
    function AES2(key) {
      if (!aesTables) {
        aesTables = precompute();
      }
      this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];
      var i;
      var j2;
      var tmp;
      var sbox = this._tables[0][4];
      var decTable = this._tables[1];
      var keyLen = key.length;
      var rcon = 1;
      if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
        throw new Error("Invalid aes key size");
      }
      var encKey = key.slice(0);
      var decKey = [];
      this._key = [encKey, decKey];
      for (i = keyLen; i < 4 * keyLen + 28; i++) {
        tmp = encKey[i - 1];
        if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
          tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
          if (i % keyLen === 0) {
            tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
            rcon = rcon << 1 ^ (rcon >> 7) * 283;
          }
        }
        encKey[i] = encKey[i - keyLen] ^ tmp;
      }
      for (j2 = 0; i; j2++, i--) {
        tmp = encKey[j2 & 3 ? i : i - 4];
        if (i <= 4 || j2 < 4) {
          decKey[j2] = tmp;
        } else {
          decKey[j2] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
        }
      }
    }
    var _proto = AES2.prototype;
    _proto.decrypt = function decrypt4(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
      var key = this._key[1];
      var a = encrypted0 ^ key[0];
      var b2 = encrypted3 ^ key[1];
      var c = encrypted2 ^ key[2];
      var d3 = encrypted1 ^ key[3];
      var a2;
      var b22;
      var c2;
      var nInnerRounds = key.length / 4 - 2;
      var i;
      var kIndex = 4;
      var table = this._tables[1];
      var table0 = table[0];
      var table1 = table[1];
      var table2 = table[2];
      var table3 = table[3];
      var sbox = table[4];
      for (i = 0; i < nInnerRounds; i++) {
        a2 = table0[a >>> 24] ^ table1[b2 >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d3 & 255] ^ key[kIndex];
        b22 = table0[b2 >>> 24] ^ table1[c >> 16 & 255] ^ table2[d3 >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
        c2 = table0[c >>> 24] ^ table1[d3 >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b2 & 255] ^ key[kIndex + 2];
        d3 = table0[d3 >>> 24] ^ table1[a >> 16 & 255] ^ table2[b2 >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
        kIndex += 4;
        a = a2;
        b2 = b22;
        c = c2;
      }
      for (i = 0; i < 4; i++) {
        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b2 >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d3 & 255] ^ key[kIndex++];
        a2 = a;
        a = b2;
        b2 = c;
        c = d3;
        d3 = a2;
      }
    };
    return AES2;
  }();
  var AsyncStream = function(_Stream) {
    inheritsLoose(AsyncStream2, _Stream);
    function AsyncStream2() {
      var _this;
      _this = _Stream.call(this, Stream2) || this;
      _this.jobs = [];
      _this.delay = 1;
      _this.timeout_ = null;
      return _this;
    }
    var _proto = AsyncStream2.prototype;
    _proto.processJob_ = function processJob_() {
      this.jobs.shift()();
      if (this.jobs.length) {
        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
      } else {
        this.timeout_ = null;
      }
    };
    _proto.push = function push(job) {
      this.jobs.push(job);
      if (!this.timeout_) {
        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
      }
    };
    return AsyncStream2;
  }(Stream2);
  var ntoh = function ntoh2(word) {
    return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
  };
  var decrypt3 = function decrypt4(encrypted, key, initVector) {
    var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
    var decipher = new AES(Array.prototype.slice.call(key));
    var decrypted = new Uint8Array(encrypted.byteLength);
    var decrypted32 = new Int32Array(decrypted.buffer);
    var init0;
    var init1;
    var init2;
    var init3;
    var encrypted0;
    var encrypted1;
    var encrypted2;
    var encrypted3;
    var wordIx;
    init0 = initVector[0];
    init1 = initVector[1];
    init2 = initVector[2];
    init3 = initVector[3];
    for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
      encrypted0 = ntoh(encrypted32[wordIx]);
      encrypted1 = ntoh(encrypted32[wordIx + 1]);
      encrypted2 = ntoh(encrypted32[wordIx + 2]);
      encrypted3 = ntoh(encrypted32[wordIx + 3]);
      decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
      decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
      decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
      decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
      decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
      init0 = encrypted0;
      init1 = encrypted1;
      init2 = encrypted2;
      init3 = encrypted3;
    }
    return decrypted;
  };
  var Decrypter2 = function() {
    function Decrypter3(encrypted, key, initVector, done) {
      var step = Decrypter3.STEP;
      var encrypted32 = new Int32Array(encrypted.buffer);
      var decrypted = new Uint8Array(encrypted.byteLength);
      var i = 0;
      this.asyncStream_ = new AsyncStream();
      this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
      for (i = step; i < encrypted32.length; i += step) {
        initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);
        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
      }
      this.asyncStream_.push(function() {
        done(null, unpad(decrypted));
      });
    }
    var _proto = Decrypter3.prototype;
    _proto.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {
      return function() {
        var bytes = decrypt3(encrypted, key, initVector);
        decrypted.set(bytes, encrypted.byteOffset);
      };
    };
    createClass(Decrypter3, null, [{
      key: "STEP",
      get: function get7() {
        return 32e3;
      }
    }]);
    return Decrypter3;
  }();
  var win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  var window_1 = win;
  var isArrayBufferView3 = function isArrayBufferView4(obj) {
    if (ArrayBuffer.isView === "function") {
      return ArrayBuffer.isView(obj);
    }
    return obj && obj.buffer instanceof ArrayBuffer;
  };
  var BigInt2 = window_1.BigInt || Number;
  [BigInt2("0x1"), BigInt2("0x100"), BigInt2("0x10000"), BigInt2("0x1000000"), BigInt2("0x100000000"), BigInt2("0x10000000000"), BigInt2("0x1000000000000"), BigInt2("0x100000000000000"), BigInt2("0x10000000000000000")];
  var createTransferableMessage3 = function createTransferableMessage4(message) {
    var transferable = {};
    Object.keys(message).forEach(function(key) {
      var value = message[key];
      if (isArrayBufferView3(value)) {
        transferable[key] = {
          bytes: value.buffer,
          byteOffset: value.byteOffset,
          byteLength: value.byteLength
        };
      } else {
        transferable[key] = value;
      }
    });
    return transferable;
  };
  self.onmessage = function(event) {
    var data = event.data;
    var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
    var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
    var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
    new Decrypter2(encrypted, key, iv, function(err, bytes) {
      self.postMessage(createTransferableMessage3({
        source: data.source,
        decrypted: bytes
      }), [bytes.buffer]);
    });
  };
}));
var Decrypter = factory(workerCode);
var audioTrackKind_ = function audioTrackKind_2(properties) {
  var kind = properties["default"] ? "main" : "alternative";
  if (properties.characteristics && properties.characteristics.indexOf("public.accessibility.describes-video") >= 0) {
    kind = "main-desc";
  }
  return kind;
};
var stopLoaders = function stopLoaders2(segmentLoader, mediaType) {
  segmentLoader.abort();
  segmentLoader.pause();
  if (mediaType && mediaType.activePlaylistLoader) {
    mediaType.activePlaylistLoader.pause();
    mediaType.activePlaylistLoader = null;
  }
};
var startLoaders = function startLoaders2(playlistLoader, mediaType) {
  mediaType.activePlaylistLoader = playlistLoader;
  playlistLoader.load();
};
var onGroupChanged = function onGroupChanged2(type2, settings) {
  return function() {
    var _settings$segmentLoad = settings.segmentLoaders, segmentLoader = _settings$segmentLoad[type2], mainSegmentLoader = _settings$segmentLoad.main, mediaType = settings.mediaTypes[type2];
    var activeTrack2 = mediaType.activeTrack();
    var activeGroup3 = mediaType.getActiveGroup();
    var previousActiveLoader = mediaType.activePlaylistLoader;
    var lastGroup = mediaType.lastGroup_;
    if (activeGroup3 && lastGroup && activeGroup3.id === lastGroup.id) {
      return;
    }
    mediaType.lastGroup_ = activeGroup3;
    mediaType.lastTrack_ = activeTrack2;
    stopLoaders(segmentLoader, mediaType);
    if (!activeGroup3 || activeGroup3.isMasterPlaylist) {
      return;
    }
    if (!activeGroup3.playlistLoader) {
      if (previousActiveLoader) {
        mainSegmentLoader.resetEverything();
      }
      return;
    }
    segmentLoader.resyncLoader();
    startLoaders(activeGroup3.playlistLoader, mediaType);
  };
};
var onGroupChanging = function onGroupChanging2(type2, settings) {
  return function() {
    var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
    mediaType.lastGroup_ = null;
    segmentLoader.abort();
    segmentLoader.pause();
  };
};
var onTrackChanged = function onTrackChanged2(type2, settings) {
  return function() {
    var masterPlaylistLoader = settings.masterPlaylistLoader, _settings$segmentLoad2 = settings.segmentLoaders, segmentLoader = _settings$segmentLoad2[type2], mainSegmentLoader = _settings$segmentLoad2.main, mediaType = settings.mediaTypes[type2];
    var activeTrack2 = mediaType.activeTrack();
    var activeGroup3 = mediaType.getActiveGroup();
    var previousActiveLoader = mediaType.activePlaylistLoader;
    var lastTrack = mediaType.lastTrack_;
    if (lastTrack && activeTrack2 && lastTrack.id === activeTrack2.id) {
      return;
    }
    mediaType.lastGroup_ = activeGroup3;
    mediaType.lastTrack_ = activeTrack2;
    stopLoaders(segmentLoader, mediaType);
    if (!activeGroup3) {
      return;
    }
    if (activeGroup3.isMasterPlaylist) {
      if (!activeTrack2 || !lastTrack || activeTrack2.id === lastTrack.id) {
        return;
      }
      var mpc = settings.vhs.masterPlaylistController_;
      var newPlaylist = mpc.selectPlaylist();
      if (mpc.media() === newPlaylist) {
        return;
      }
      mediaType.logger_("track change. Switching master audio from " + lastTrack.id + " to " + activeTrack2.id);
      masterPlaylistLoader.pause();
      mainSegmentLoader.resetEverything();
      mpc.fastQualityChange_(newPlaylist);
      return;
    }
    if (type2 === "AUDIO") {
      if (!activeGroup3.playlistLoader) {
        mainSegmentLoader.setAudio(true);
        mainSegmentLoader.resetEverything();
        return;
      }
      segmentLoader.setAudio(true);
      mainSegmentLoader.setAudio(false);
    }
    if (previousActiveLoader === activeGroup3.playlistLoader) {
      startLoaders(activeGroup3.playlistLoader, mediaType);
      return;
    }
    if (segmentLoader.track) {
      segmentLoader.track(activeTrack2);
    }
    segmentLoader.resetEverything();
    startLoaders(activeGroup3.playlistLoader, mediaType);
  };
};
var onError = {
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning (or error if the playlist is blacklisted) to
   *         console and switches back to default audio track.
   * @function onError.AUDIO
   */
  AUDIO: function AUDIO(type2, settings) {
    return function() {
      var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2], blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;
      stopLoaders(segmentLoader, mediaType);
      var activeTrack2 = mediaType.activeTrack();
      var activeGroup3 = mediaType.activeGroup();
      var id = (activeGroup3.filter(function(group) {
        return group["default"];
      })[0] || activeGroup3[0]).id;
      var defaultTrack = mediaType.tracks[id];
      if (activeTrack2 === defaultTrack) {
        blacklistCurrentPlaylist({
          message: "Problem encountered loading the default audio track."
        });
        return;
      }
      videojs.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
      for (var trackId in mediaType.tracks) {
        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
      }
      mediaType.onTrackChanged();
    };
  },
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning to console and disables the active subtitle track
   * @function onError.SUBTITLES
   */
  SUBTITLES: function SUBTITLES(type2, settings) {
    return function() {
      var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
      videojs.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
      stopLoaders(segmentLoader, mediaType);
      var track = mediaType.activeTrack();
      if (track) {
        track.mode = "disabled";
      }
      mediaType.onTrackChanged();
    };
  }
};
var setupListeners = {
  /**
   * Setup event listeners for audio playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.AUDIO
   */
  AUDIO: function AUDIO2(type2, playlistLoader, settings) {
    if (!playlistLoader) {
      return;
    }
    var tech = settings.tech, requestOptions = settings.requestOptions, segmentLoader = settings.segmentLoaders[type2];
    playlistLoader.on("loadedmetadata", function() {
      var media = playlistLoader.media();
      segmentLoader.playlist(media, requestOptions);
      if (!tech.paused() || media.endList && tech.preload() !== "none") {
        segmentLoader.load();
      }
    });
    playlistLoader.on("loadedplaylist", function() {
      segmentLoader.playlist(playlistLoader.media(), requestOptions);
      if (!tech.paused()) {
        segmentLoader.load();
      }
    });
    playlistLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup event listeners for subtitle playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.SUBTITLES
   */
  SUBTITLES: function SUBTITLES2(type2, playlistLoader, settings) {
    var tech = settings.tech, requestOptions = settings.requestOptions, segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
    playlistLoader.on("loadedmetadata", function() {
      var media = playlistLoader.media();
      segmentLoader.playlist(media, requestOptions);
      segmentLoader.track(mediaType.activeTrack());
      if (!tech.paused() || media.endList && tech.preload() !== "none") {
        segmentLoader.load();
      }
    });
    playlistLoader.on("loadedplaylist", function() {
      segmentLoader.playlist(playlistLoader.media(), requestOptions);
      if (!tech.paused()) {
        segmentLoader.load();
      }
    });
    playlistLoader.on("error", onError[type2](type2, settings));
  }
};
var initialize = {
  /**
   * Setup PlaylistLoaders and AudioTracks for the audio groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.AUDIO
   */
  "AUDIO": function AUDIO3(type2, settings) {
    var vhs = settings.vhs, sourceType = settings.sourceType, segmentLoader = settings.segmentLoaders[type2], requestOptions = settings.requestOptions, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$ = settings.mediaTypes[type2], groups = _settings$mediaTypes$.groups, tracks = _settings$mediaTypes$.tracks, logger_ = _settings$mediaTypes$.logger_, masterPlaylistLoader = settings.masterPlaylistLoader;
    var audioOnlyMaster = isAudioOnly(masterPlaylistLoader.master);
    if (!mediaGroups[type2] || Object.keys(mediaGroups[type2]).length === 0) {
      mediaGroups[type2] = {
        main: {
          "default": {
            "default": true
          }
        }
      };
      if (audioOnlyMaster) {
        mediaGroups[type2].main["default"].playlists = masterPlaylistLoader.master.playlists;
      }
    }
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        var properties = mediaGroups[type2][groupId][variantLabel];
        var playlistLoader = void 0;
        if (audioOnlyMaster) {
          logger_("AUDIO group '" + groupId + "' label '" + variantLabel + "' is a master playlist");
          properties.isMasterPlaylist = true;
          playlistLoader = null;
        } else if (sourceType === "vhs-json" && properties.playlists) {
          playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);
        } else if (properties.resolvedUri) {
          playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
        } else if (properties.playlists && sourceType === "dash") {
          playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
        } else {
          playlistLoader = null;
        }
        properties = videojs.mergeOptions({
          id: variantLabel,
          playlistLoader
        }, properties);
        setupListeners[type2](type2, properties.playlistLoader, settings);
        groups[groupId].push(properties);
        if (typeof tracks[variantLabel] === "undefined") {
          var track = new videojs.AudioTrack({
            id: variantLabel,
            kind: audioTrackKind_(properties),
            enabled: false,
            language: properties.language,
            "default": properties["default"],
            label: variantLabel
          });
          tracks[variantLabel] = track;
        }
      }
    }
    segmentLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup PlaylistLoaders and TextTracks for the subtitle groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.SUBTITLES
   */
  "SUBTITLES": function SUBTITLES3(type2, settings) {
    var tech = settings.tech, vhs = settings.vhs, sourceType = settings.sourceType, segmentLoader = settings.segmentLoaders[type2], requestOptions = settings.requestOptions, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$2 = settings.mediaTypes[type2], groups = _settings$mediaTypes$2.groups, tracks = _settings$mediaTypes$2.tracks, masterPlaylistLoader = settings.masterPlaylistLoader;
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        if (mediaGroups[type2][groupId][variantLabel].forced) {
          continue;
        }
        var properties = mediaGroups[type2][groupId][variantLabel];
        var playlistLoader = void 0;
        if (sourceType === "hls") {
          playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
        } else if (sourceType === "dash") {
          var playlists = properties.playlists.filter(function(p) {
            return p.excludeUntil !== Infinity;
          });
          if (!playlists.length) {
            return;
          }
          playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
        } else if (sourceType === "vhs-json") {
          playlistLoader = new PlaylistLoader(
            // if the vhs-json object included the media playlist, use the media playlist
            // as provided, otherwise use the resolved URI to load the playlist
            properties.playlists ? properties.playlists[0] : properties.resolvedUri,
            vhs,
            requestOptions
          );
        }
        properties = videojs.mergeOptions({
          id: variantLabel,
          playlistLoader
        }, properties);
        setupListeners[type2](type2, properties.playlistLoader, settings);
        groups[groupId].push(properties);
        if (typeof tracks[variantLabel] === "undefined") {
          var track = tech.addRemoteTextTrack({
            id: variantLabel,
            kind: "subtitles",
            "default": properties["default"] && properties.autoselect,
            language: properties.language,
            label: variantLabel
          }, false).track;
          tracks[variantLabel] = track;
        }
      }
    }
    segmentLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup TextTracks for the closed-caption groups
   *
   * @param {String} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize['CLOSED-CAPTIONS']
   */
  "CLOSED-CAPTIONS": function CLOSEDCAPTIONS(type2, settings) {
    var tech = settings.tech, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$3 = settings.mediaTypes[type2], groups = _settings$mediaTypes$3.groups, tracks = _settings$mediaTypes$3.tracks;
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        var properties = mediaGroups[type2][groupId][variantLabel];
        if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {
          continue;
        }
        var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
        var newProps = {
          label: variantLabel,
          language: properties.language,
          instreamId: properties.instreamId,
          "default": properties["default"] && properties.autoselect
        };
        if (captionServices[newProps.instreamId]) {
          newProps = videojs.mergeOptions(newProps, captionServices[newProps.instreamId]);
        }
        if (newProps["default"] === void 0) {
          delete newProps["default"];
        }
        groups[groupId].push(videojs.mergeOptions({
          id: variantLabel
        }, properties));
        if (typeof tracks[variantLabel] === "undefined") {
          var track = tech.addRemoteTextTrack({
            id: newProps.instreamId,
            kind: "captions",
            "default": newProps["default"],
            language: newProps.language,
            label: newProps.label
          }, false).track;
          tracks[variantLabel] = track;
        }
      }
    }
  }
};
var groupMatch = function groupMatch2(list, media) {
  for (var i = 0; i < list.length; i++) {
    if (playlistMatch(media, list[i])) {
      return true;
    }
    if (list[i].playlists && groupMatch2(list[i].playlists, media)) {
      return true;
    }
  }
  return false;
};
var activeGroup = function activeGroup2(type2, settings) {
  return function(track) {
    var masterPlaylistLoader = settings.masterPlaylistLoader, groups = settings.mediaTypes[type2].groups;
    var media = masterPlaylistLoader.media();
    if (!media) {
      return null;
    }
    var variants = null;
    if (media.attributes[type2]) {
      variants = groups[media.attributes[type2]];
    }
    var groupKeys = Object.keys(groups);
    if (!variants) {
      if (type2 === "AUDIO" && groupKeys.length > 1 && isAudioOnly(settings.master)) {
        for (var i = 0; i < groupKeys.length; i++) {
          var groupPropertyList = groups[groupKeys[i]];
          if (groupMatch(groupPropertyList, media)) {
            variants = groupPropertyList;
            break;
          }
        }
      } else if (groups.main) {
        variants = groups.main;
      } else if (groupKeys.length === 1) {
        variants = groups[groupKeys[0]];
      }
    }
    if (typeof track === "undefined") {
      return variants;
    }
    if (track === null || !variants) {
      return null;
    }
    return variants.filter(function(props) {
      return props.id === track.id;
    })[0] || null;
  };
};
var activeTrack = {
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.AUDIO
   */
  AUDIO: function AUDIO4(type2, settings) {
    return function() {
      var tracks = settings.mediaTypes[type2].tracks;
      for (var id in tracks) {
        if (tracks[id].enabled) {
          return tracks[id];
        }
      }
      return null;
    };
  },
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.SUBTITLES
   */
  SUBTITLES: function SUBTITLES4(type2, settings) {
    return function() {
      var tracks = settings.mediaTypes[type2].tracks;
      for (var id in tracks) {
        if (tracks[id].mode === "showing" || tracks[id].mode === "hidden") {
          return tracks[id];
        }
      }
      return null;
    };
  }
};
var getActiveGroup = function getActiveGroup2(type2, _ref) {
  var mediaTypes2 = _ref.mediaTypes;
  return function() {
    var activeTrack_ = mediaTypes2[type2].activeTrack();
    if (!activeTrack_) {
      return null;
    }
    return mediaTypes2[type2].activeGroup(activeTrack_);
  };
};
var setupMediaGroups = function setupMediaGroups2(settings) {
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(type2) {
    initialize[type2](type2, settings);
  });
  var mediaTypes2 = settings.mediaTypes, masterPlaylistLoader = settings.masterPlaylistLoader, tech = settings.tech, vhs = settings.vhs, _settings$segmentLoad3 = settings.segmentLoaders, audioSegmentLoader = _settings$segmentLoad3["AUDIO"], mainSegmentLoader = _settings$segmentLoad3.main;
  ["AUDIO", "SUBTITLES"].forEach(function(type2) {
    mediaTypes2[type2].activeGroup = activeGroup(type2, settings);
    mediaTypes2[type2].activeTrack = activeTrack[type2](type2, settings);
    mediaTypes2[type2].onGroupChanged = onGroupChanged(type2, settings);
    mediaTypes2[type2].onGroupChanging = onGroupChanging(type2, settings);
    mediaTypes2[type2].onTrackChanged = onTrackChanged(type2, settings);
    mediaTypes2[type2].getActiveGroup = getActiveGroup(type2, settings);
  });
  var audioGroup = mediaTypes2.AUDIO.activeGroup();
  if (audioGroup) {
    var groupId = (audioGroup.filter(function(group) {
      return group["default"];
    })[0] || audioGroup[0]).id;
    mediaTypes2.AUDIO.tracks[groupId].enabled = true;
    mediaTypes2.AUDIO.onGroupChanged();
    mediaTypes2.AUDIO.onTrackChanged();
    var activeAudioGroup = mediaTypes2.AUDIO.getActiveGroup();
    if (!activeAudioGroup.playlistLoader) {
      mainSegmentLoader.setAudio(true);
    } else {
      mainSegmentLoader.setAudio(false);
      audioSegmentLoader.setAudio(true);
    }
  }
  masterPlaylistLoader.on("mediachange", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      return mediaTypes2[type2].onGroupChanged();
    });
  });
  masterPlaylistLoader.on("mediachanging", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      return mediaTypes2[type2].onGroupChanging();
    });
  });
  var onAudioTrackChanged = function onAudioTrackChanged2() {
    mediaTypes2.AUDIO.onTrackChanged();
    tech.trigger({
      type: "usage",
      name: "vhs-audio-change"
    });
    tech.trigger({
      type: "usage",
      name: "hls-audio-change"
    });
  };
  tech.audioTracks().addEventListener("change", onAudioTrackChanged);
  tech.remoteTextTracks().addEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
  vhs.on("dispose", function() {
    tech.audioTracks().removeEventListener("change", onAudioTrackChanged);
    tech.remoteTextTracks().removeEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
  });
  tech.clearTracks("audio");
  for (var id in mediaTypes2.AUDIO.tracks) {
    tech.audioTracks().addTrack(mediaTypes2.AUDIO.tracks[id]);
  }
};
var createMediaTypes = function createMediaTypes2() {
  var mediaTypes2 = {};
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(type2) {
    mediaTypes2[type2] = {
      groups: {},
      tracks: {},
      activePlaylistLoader: null,
      activeGroup: noop,
      activeTrack: noop,
      getActiveGroup: noop,
      onGroupChanged: noop,
      onTrackChanged: noop,
      lastTrack_: null,
      logger_: logger("MediaGroups[" + type2 + "]")
    };
  });
  return mediaTypes2;
};
var ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;
var Vhs$1;
var loaderStats = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"];
var sumLoaderStat = function sumLoaderStat2(stat) {
  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
};
var shouldSwitchToMedia = function shouldSwitchToMedia2(_ref) {
  var currentPlaylist = _ref.currentPlaylist, buffered = _ref.buffered, currentTime = _ref.currentTime, nextPlaylist = _ref.nextPlaylist, bufferLowWaterLine = _ref.bufferLowWaterLine, bufferHighWaterLine = _ref.bufferHighWaterLine, duration5 = _ref.duration, experimentalBufferBasedABR = _ref.experimentalBufferBasedABR, log2 = _ref.log;
  if (!nextPlaylist) {
    videojs.log.warn("We received no playlist to switch to. Please check your stream.");
    return false;
  }
  var sharedLogLine = "allowing switch " + (currentPlaylist && currentPlaylist.id || "null") + " -> " + nextPlaylist.id;
  if (!currentPlaylist) {
    log2(sharedLogLine + " as current playlist is not set");
    return true;
  }
  if (nextPlaylist.id === currentPlaylist.id) {
    return false;
  }
  var isBuffered = Boolean(findRange(buffered, currentTime).length);
  if (!currentPlaylist.endList) {
    if (!isBuffered && typeof currentPlaylist.partTargetDuration === "number") {
      log2("not " + sharedLogLine + " as current playlist is live llhls, but currentTime isn't in buffered.");
      return false;
    }
    log2(sharedLogLine + " as current playlist is live");
    return true;
  }
  var forwardBuffer = timeAheadOf(buffered, currentTime);
  var maxBufferLowWaterLine = experimentalBufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
  if (duration5 < maxBufferLowWaterLine) {
    log2(sharedLogLine + " as duration < max low water line (" + duration5 + " < " + maxBufferLowWaterLine + ")");
    return true;
  }
  var nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
  var currBandwidth = currentPlaylist.attributes.BANDWIDTH;
  if (nextBandwidth < currBandwidth && (!experimentalBufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
    var logLine = sharedLogLine + " as next bandwidth < current bandwidth (" + nextBandwidth + " < " + currBandwidth + ")";
    if (experimentalBufferBasedABR) {
      logLine += " and forwardBuffer < bufferHighWaterLine (" + forwardBuffer + " < " + bufferHighWaterLine + ")";
    }
    log2(logLine);
    return true;
  }
  if ((!experimentalBufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
    var _logLine = sharedLogLine + " as forwardBuffer >= bufferLowWaterLine (" + forwardBuffer + " >= " + bufferLowWaterLine + ")";
    if (experimentalBufferBasedABR) {
      _logLine += " and next bandwidth > current bandwidth (" + nextBandwidth + " > " + currBandwidth + ")";
    }
    log2(_logLine);
    return true;
  }
  log2("not " + sharedLogLine + " as no switching criteria met");
  return false;
};
var MasterPlaylistController = function(_videojs$EventTarget) {
  _inheritsLoose(MasterPlaylistController2, _videojs$EventTarget);
  function MasterPlaylistController2(options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    var src = options.src, handleManifestRedirects = options.handleManifestRedirects, withCredentials = options.withCredentials, tech = options.tech, bandwidth2 = options.bandwidth, externVhs = options.externVhs, useCueTags = options.useCueTags, blacklistDuration = options.blacklistDuration, enableLowInitialPlaylist = options.enableLowInitialPlaylist, sourceType = options.sourceType, cacheEncryptionKeys = options.cacheEncryptionKeys, experimentalBufferBasedABR = options.experimentalBufferBasedABR, experimentalLeastPixelDiffSelector = options.experimentalLeastPixelDiffSelector, captionServices = options.captionServices;
    if (!src) {
      throw new Error("A non-empty playlist URL or JSON manifest string is required");
    }
    var maxPlaylistRetries = options.maxPlaylistRetries;
    if (maxPlaylistRetries === null || typeof maxPlaylistRetries === "undefined") {
      maxPlaylistRetries = Infinity;
    }
    Vhs$1 = externVhs;
    _this.experimentalBufferBasedABR = Boolean(experimentalBufferBasedABR);
    _this.experimentalLeastPixelDiffSelector = Boolean(experimentalLeastPixelDiffSelector);
    _this.withCredentials = withCredentials;
    _this.tech_ = tech;
    _this.vhs_ = tech.vhs;
    _this.sourceType_ = sourceType;
    _this.useCueTags_ = useCueTags;
    _this.blacklistDuration = blacklistDuration;
    _this.maxPlaylistRetries = maxPlaylistRetries;
    _this.enableLowInitialPlaylist = enableLowInitialPlaylist;
    if (_this.useCueTags_) {
      _this.cueTagsTrack_ = _this.tech_.addTextTrack("metadata", "ad-cues");
      _this.cueTagsTrack_.inBandMetadataTrackDispatchType = "";
    }
    _this.requestOptions_ = {
      withCredentials,
      handleManifestRedirects,
      maxPlaylistRetries,
      timeout: null
    };
    _this.on("error", _this.pauseLoading);
    _this.mediaTypes_ = createMediaTypes();
    _this.mediaSource = new import_window6.default.MediaSource();
    _this.handleDurationChange_ = _this.handleDurationChange_.bind(_assertThisInitialized(_this));
    _this.handleSourceOpen_ = _this.handleSourceOpen_.bind(_assertThisInitialized(_this));
    _this.handleSourceEnded_ = _this.handleSourceEnded_.bind(_assertThisInitialized(_this));
    _this.mediaSource.addEventListener("durationchange", _this.handleDurationChange_);
    _this.mediaSource.addEventListener("sourceopen", _this.handleSourceOpen_);
    _this.mediaSource.addEventListener("sourceended", _this.handleSourceEnded_);
    _this.seekable_ = videojs.createTimeRanges();
    _this.hasPlayed_ = false;
    _this.syncController_ = new SyncController(options);
    _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
      kind: "metadata",
      label: "segment-metadata"
    }, false).track;
    _this.decrypter_ = new Decrypter();
    _this.sourceUpdater_ = new SourceUpdater(_this.mediaSource);
    _this.inbandTextTracks_ = {};
    _this.timelineChangeController_ = new TimelineChangeController();
    var segmentLoaderSettings = {
      vhs: _this.vhs_,
      parse708captions: options.parse708captions,
      useDtsForTimestampOffset: options.useDtsForTimestampOffset,
      captionServices,
      mediaSource: _this.mediaSource,
      currentTime: _this.tech_.currentTime.bind(_this.tech_),
      seekable: function seekable3() {
        return _this.seekable();
      },
      seeking: function seeking() {
        return _this.tech_.seeking();
      },
      duration: function duration5() {
        return _this.duration();
      },
      hasPlayed: function hasPlayed() {
        return _this.hasPlayed_;
      },
      goalBufferLength: function goalBufferLength() {
        return _this.goalBufferLength();
      },
      bandwidth: bandwidth2,
      syncController: _this.syncController_,
      decrypter: _this.decrypter_,
      sourceType: _this.sourceType_,
      inbandTextTracks: _this.inbandTextTracks_,
      cacheEncryptionKeys,
      sourceUpdater: _this.sourceUpdater_,
      timelineChangeController: _this.timelineChangeController_,
      experimentalExactManifestTimings: options.experimentalExactManifestTimings
    };
    _this.masterPlaylistLoader_ = _this.sourceType_ === "dash" ? new DashPlaylistLoader(src, _this.vhs_, _this.requestOptions_) : new PlaylistLoader(src, _this.vhs_, _this.requestOptions_);
    _this.setupMasterPlaylistLoaderListeners_();
    _this.mainSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      segmentMetadataTrack: _this.segmentMetadataTrack_,
      loaderType: "main"
    }), options);
    _this.audioSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      loaderType: "audio"
    }), options);
    _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      loaderType: "vtt",
      featuresNativeTextTracks: _this.tech_.featuresNativeTextTracks,
      loadVttJs: function loadVttJs() {
        return new Promise(function(resolve, reject) {
          function onLoad() {
            tech.off("vttjserror", onError2);
            resolve();
          }
          function onError2() {
            tech.off("vttjsloaded", onLoad);
            reject();
          }
          tech.one("vttjsloaded", onLoad);
          tech.one("vttjserror", onError2);
          tech.addWebVttScript_();
        });
      }
    }), options);
    _this.setupSegmentLoaderListeners_();
    if (_this.experimentalBufferBasedABR) {
      _this.masterPlaylistLoader_.one("loadedplaylist", function() {
        return _this.startABRTimer_();
      });
      _this.tech_.on("pause", function() {
        return _this.stopABRTimer_();
      });
      _this.tech_.on("play", function() {
        return _this.startABRTimer_();
      });
    }
    loaderStats.forEach(function(stat) {
      _this[stat + "_"] = sumLoaderStat.bind(_assertThisInitialized(_this), stat);
    });
    _this.logger_ = logger("MPC");
    _this.triggeredFmp4Usage = false;
    if (_this.tech_.preload() === "none") {
      _this.loadOnPlay_ = function() {
        _this.loadOnPlay_ = null;
        _this.masterPlaylistLoader_.load();
      };
      _this.tech_.one("play", _this.loadOnPlay_);
    } else {
      _this.masterPlaylistLoader_.load();
    }
    _this.timeToLoadedData__ = -1;
    _this.mainAppendsToLoadedData__ = -1;
    _this.audioAppendsToLoadedData__ = -1;
    var event = _this.tech_.preload() === "none" ? "play" : "loadstart";
    _this.tech_.one(event, function() {
      var timeToLoadedDataStart = Date.now();
      _this.tech_.one("loadeddata", function() {
        _this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
        _this.mainAppendsToLoadedData__ = _this.mainSegmentLoader_.mediaAppends;
        _this.audioAppendsToLoadedData__ = _this.audioSegmentLoader_.mediaAppends;
      });
    });
    return _this;
  }
  var _proto = MasterPlaylistController2.prototype;
  _proto.mainAppendsToLoadedData_ = function mainAppendsToLoadedData_() {
    return this.mainAppendsToLoadedData__;
  };
  _proto.audioAppendsToLoadedData_ = function audioAppendsToLoadedData_() {
    return this.audioAppendsToLoadedData__;
  };
  _proto.appendsToLoadedData_ = function appendsToLoadedData_() {
    var main = this.mainAppendsToLoadedData_();
    var audio = this.audioAppendsToLoadedData_();
    if (main === -1 || audio === -1) {
      return -1;
    }
    return main + audio;
  };
  _proto.timeToLoadedData_ = function timeToLoadedData_() {
    return this.timeToLoadedData__;
  };
  _proto.checkABR_ = function checkABR_(reason) {
    if (reason === void 0) {
      reason = "abr";
    }
    var nextPlaylist = this.selectPlaylist();
    if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {
      this.switchMedia_(nextPlaylist, reason);
    }
  };
  _proto.switchMedia_ = function switchMedia_(playlist, cause, delay) {
    var oldMedia = this.media();
    var oldId = oldMedia && (oldMedia.id || oldMedia.uri);
    var newId = playlist.id || playlist.uri;
    if (oldId && oldId !== newId) {
      this.logger_("switch media " + oldId + " -> " + newId + " from " + cause);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-change-" + cause
      });
    }
    this.masterPlaylistLoader_.media(playlist, delay);
  };
  _proto.startABRTimer_ = function startABRTimer_() {
    var _this2 = this;
    this.stopABRTimer_();
    this.abrTimer_ = import_window6.default.setInterval(function() {
      return _this2.checkABR_();
    }, 250);
  };
  _proto.stopABRTimer_ = function stopABRTimer_() {
    if (this.tech_.scrubbing && this.tech_.scrubbing()) {
      return;
    }
    import_window6.default.clearInterval(this.abrTimer_);
    this.abrTimer_ = null;
  };
  _proto.getAudioTrackPlaylists_ = function getAudioTrackPlaylists_() {
    var master = this.master();
    var defaultPlaylists = master && master.playlists || [];
    if (!master || !master.mediaGroups || !master.mediaGroups.AUDIO) {
      return defaultPlaylists;
    }
    var AUDIO5 = master.mediaGroups.AUDIO;
    var groupKeys = Object.keys(AUDIO5);
    var track;
    if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {
      track = this.mediaTypes_.AUDIO.activeTrack();
    } else {
      var defaultGroup = AUDIO5.main || groupKeys.length && AUDIO5[groupKeys[0]];
      for (var label in defaultGroup) {
        if (defaultGroup[label]["default"]) {
          track = {
            label
          };
          break;
        }
      }
    }
    if (!track) {
      return defaultPlaylists;
    }
    var playlists = [];
    for (var group in AUDIO5) {
      if (AUDIO5[group][track.label]) {
        var properties = AUDIO5[group][track.label];
        if (properties.playlists && properties.playlists.length) {
          playlists.push.apply(playlists, properties.playlists);
        } else if (properties.uri) {
          playlists.push(properties);
        } else if (master.playlists.length) {
          for (var i = 0; i < master.playlists.length; i++) {
            var playlist = master.playlists[i];
            if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {
              playlists.push(playlist);
            }
          }
        }
      }
    }
    if (!playlists.length) {
      return defaultPlaylists;
    }
    return playlists;
  };
  _proto.setupMasterPlaylistLoaderListeners_ = function setupMasterPlaylistLoaderListeners_() {
    var _this3 = this;
    this.masterPlaylistLoader_.on("loadedmetadata", function() {
      var media = _this3.masterPlaylistLoader_.media();
      var requestTimeout = media.targetDuration * 1.5 * 1e3;
      if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
        _this3.requestOptions_.timeout = 0;
      } else {
        _this3.requestOptions_.timeout = requestTimeout;
      }
      if (media.endList && _this3.tech_.preload() !== "none") {
        _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
        _this3.mainSegmentLoader_.load();
      }
      setupMediaGroups({
        sourceType: _this3.sourceType_,
        segmentLoaders: {
          AUDIO: _this3.audioSegmentLoader_,
          SUBTITLES: _this3.subtitleSegmentLoader_,
          main: _this3.mainSegmentLoader_
        },
        tech: _this3.tech_,
        requestOptions: _this3.requestOptions_,
        masterPlaylistLoader: _this3.masterPlaylistLoader_,
        vhs: _this3.vhs_,
        master: _this3.master(),
        mediaTypes: _this3.mediaTypes_,
        blacklistCurrentPlaylist: _this3.blacklistCurrentPlaylist.bind(_this3)
      });
      _this3.triggerPresenceUsage_(_this3.master(), media);
      _this3.setupFirstPlay();
      if (!_this3.mediaTypes_.AUDIO.activePlaylistLoader || _this3.mediaTypes_.AUDIO.activePlaylistLoader.media()) {
        _this3.trigger("selectedinitialmedia");
      } else {
        _this3.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", function() {
          _this3.trigger("selectedinitialmedia");
        });
      }
    });
    this.masterPlaylistLoader_.on("loadedplaylist", function() {
      if (_this3.loadOnPlay_) {
        _this3.tech_.off("play", _this3.loadOnPlay_);
      }
      var updatedPlaylist = _this3.masterPlaylistLoader_.media();
      if (!updatedPlaylist) {
        _this3.excludeUnsupportedVariants_();
        var selectedMedia;
        if (_this3.enableLowInitialPlaylist) {
          selectedMedia = _this3.selectInitialPlaylist();
        }
        if (!selectedMedia) {
          selectedMedia = _this3.selectPlaylist();
        }
        if (!selectedMedia || !_this3.shouldSwitchToMedia_(selectedMedia)) {
          return;
        }
        _this3.initialMedia_ = selectedMedia;
        _this3.switchMedia_(_this3.initialMedia_, "initial");
        var haveJsonSource = _this3.sourceType_ === "vhs-json" && _this3.initialMedia_.segments;
        if (!haveJsonSource) {
          return;
        }
        updatedPlaylist = _this3.initialMedia_;
      }
      _this3.handleUpdatedMediaPlaylist(updatedPlaylist);
    });
    this.masterPlaylistLoader_.on("error", function() {
      _this3.blacklistCurrentPlaylist(_this3.masterPlaylistLoader_.error);
    });
    this.masterPlaylistLoader_.on("mediachanging", function() {
      _this3.mainSegmentLoader_.abort();
      _this3.mainSegmentLoader_.pause();
    });
    this.masterPlaylistLoader_.on("mediachange", function() {
      var media = _this3.masterPlaylistLoader_.media();
      var requestTimeout = media.targetDuration * 1.5 * 1e3;
      if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
        _this3.requestOptions_.timeout = 0;
      } else {
        _this3.requestOptions_.timeout = requestTimeout;
      }
      _this3.masterPlaylistLoader_.load();
      _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
      _this3.mainSegmentLoader_.load();
      _this3.tech_.trigger({
        type: "mediachange",
        bubbles: true
      });
    });
    this.masterPlaylistLoader_.on("playlistunchanged", function() {
      var updatedPlaylist = _this3.masterPlaylistLoader_.media();
      if (updatedPlaylist.lastExcludeReason_ === "playlist-unchanged") {
        return;
      }
      var playlistOutdated = _this3.stuckAtPlaylistEnd_(updatedPlaylist);
      if (playlistOutdated) {
        _this3.blacklistCurrentPlaylist({
          message: "Playlist no longer updating.",
          reason: "playlist-unchanged"
        });
        _this3.tech_.trigger("playliststuck");
      }
    });
    this.masterPlaylistLoader_.on("renditiondisabled", function() {
      _this3.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-disabled"
      });
      _this3.tech_.trigger({
        type: "usage",
        name: "hls-rendition-disabled"
      });
    });
    this.masterPlaylistLoader_.on("renditionenabled", function() {
      _this3.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-enabled"
      });
      _this3.tech_.trigger({
        type: "usage",
        name: "hls-rendition-enabled"
      });
    });
  };
  _proto.handleUpdatedMediaPlaylist = function handleUpdatedMediaPlaylist(updatedPlaylist) {
    if (this.useCueTags_) {
      this.updateAdCues_(updatedPlaylist);
    }
    this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
    this.updateDuration(!updatedPlaylist.endList);
    if (!this.tech_.paused()) {
      this.mainSegmentLoader_.load();
      if (this.audioSegmentLoader_) {
        this.audioSegmentLoader_.load();
      }
    }
  };
  _proto.triggerPresenceUsage_ = function triggerPresenceUsage_(master, media) {
    var mediaGroups = master.mediaGroups || {};
    var defaultDemuxed = true;
    var audioGroupKeys = Object.keys(mediaGroups.AUDIO);
    for (var mediaGroup in mediaGroups.AUDIO) {
      for (var label in mediaGroups.AUDIO[mediaGroup]) {
        var properties = mediaGroups.AUDIO[mediaGroup][label];
        if (!properties.uri) {
          defaultDemuxed = false;
        }
      }
    }
    if (defaultDemuxed) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-demuxed"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-demuxed"
      });
    }
    if (Object.keys(mediaGroups.SUBTITLES).length) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-webvtt"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-webvtt"
      });
    }
    if (Vhs$1.Playlist.isAes(media)) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-aes"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-aes"
      });
    }
    if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-alternate-audio"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-alternate-audio"
      });
    }
    if (this.useCueTags_) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-playlist-cue-tags"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-playlist-cue-tags"
      });
    }
  };
  _proto.shouldSwitchToMedia_ = function shouldSwitchToMedia_(nextPlaylist) {
    var currentPlaylist = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_;
    var currentTime = this.tech_.currentTime();
    var bufferLowWaterLine = this.bufferLowWaterLine();
    var bufferHighWaterLine = this.bufferHighWaterLine();
    var buffered = this.tech_.buffered();
    return shouldSwitchToMedia({
      buffered,
      currentTime,
      currentPlaylist,
      nextPlaylist,
      bufferLowWaterLine,
      bufferHighWaterLine,
      duration: this.duration(),
      experimentalBufferBasedABR: this.experimentalBufferBasedABR,
      log: this.logger_
    });
  };
  _proto.setupSegmentLoaderListeners_ = function setupSegmentLoaderListeners_() {
    var _this4 = this;
    this.mainSegmentLoader_.on("bandwidthupdate", function() {
      _this4.checkABR_("bandwidthupdate");
      _this4.tech_.trigger("bandwidthupdate");
    });
    this.mainSegmentLoader_.on("timeout", function() {
      if (_this4.experimentalBufferBasedABR) {
        _this4.mainSegmentLoader_.load();
      }
    });
    if (!this.experimentalBufferBasedABR) {
      this.mainSegmentLoader_.on("progress", function() {
        _this4.trigger("progress");
      });
    }
    this.mainSegmentLoader_.on("error", function() {
      _this4.blacklistCurrentPlaylist(_this4.mainSegmentLoader_.error());
    });
    this.mainSegmentLoader_.on("appenderror", function() {
      _this4.error = _this4.mainSegmentLoader_.error_;
      _this4.trigger("error");
    });
    this.mainSegmentLoader_.on("syncinfoupdate", function() {
      _this4.onSyncInfoUpdate_();
    });
    this.mainSegmentLoader_.on("timestampoffset", function() {
      _this4.tech_.trigger({
        type: "usage",
        name: "vhs-timestamp-offset"
      });
      _this4.tech_.trigger({
        type: "usage",
        name: "hls-timestamp-offset"
      });
    });
    this.audioSegmentLoader_.on("syncinfoupdate", function() {
      _this4.onSyncInfoUpdate_();
    });
    this.audioSegmentLoader_.on("appenderror", function() {
      _this4.error = _this4.audioSegmentLoader_.error_;
      _this4.trigger("error");
    });
    this.mainSegmentLoader_.on("ended", function() {
      _this4.logger_("main segment loader ended");
      _this4.onEndOfStream();
    });
    this.mainSegmentLoader_.on("earlyabort", function(event) {
      if (_this4.experimentalBufferBasedABR) {
        return;
      }
      _this4.delegateLoaders_("all", ["abort"]);
      _this4.blacklistCurrentPlaylist({
        message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
      }, ABORT_EARLY_BLACKLIST_SECONDS);
    });
    var updateCodecs = function updateCodecs2() {
      if (!_this4.sourceUpdater_.hasCreatedSourceBuffers()) {
        return _this4.tryToCreateSourceBuffers_();
      }
      var codecs = _this4.getCodecsOrExclude_();
      if (!codecs) {
        return;
      }
      _this4.sourceUpdater_.addOrChangeSourceBuffers(codecs);
    };
    this.mainSegmentLoader_.on("trackinfo", updateCodecs);
    this.audioSegmentLoader_.on("trackinfo", updateCodecs);
    this.mainSegmentLoader_.on("fmp4", function() {
      if (!_this4.triggeredFmp4Usage) {
        _this4.tech_.trigger({
          type: "usage",
          name: "vhs-fmp4"
        });
        _this4.tech_.trigger({
          type: "usage",
          name: "hls-fmp4"
        });
        _this4.triggeredFmp4Usage = true;
      }
    });
    this.audioSegmentLoader_.on("fmp4", function() {
      if (!_this4.triggeredFmp4Usage) {
        _this4.tech_.trigger({
          type: "usage",
          name: "vhs-fmp4"
        });
        _this4.tech_.trigger({
          type: "usage",
          name: "hls-fmp4"
        });
        _this4.triggeredFmp4Usage = true;
      }
    });
    this.audioSegmentLoader_.on("ended", function() {
      _this4.logger_("audioSegmentLoader ended");
      _this4.onEndOfStream();
    });
  };
  _proto.mediaSecondsLoaded_ = function mediaSecondsLoaded_() {
    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
  };
  _proto.load = function load() {
    this.mainSegmentLoader_.load();
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      this.audioSegmentLoader_.load();
    }
    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
      this.subtitleSegmentLoader_.load();
    }
  };
  _proto.smoothQualityChange_ = function smoothQualityChange_(media) {
    if (media === void 0) {
      media = this.selectPlaylist();
    }
    this.fastQualityChange_(media);
  };
  _proto.fastQualityChange_ = function fastQualityChange_(media) {
    var _this5 = this;
    if (media === void 0) {
      media = this.selectPlaylist();
    }
    if (media === this.masterPlaylistLoader_.media()) {
      this.logger_("skipping fastQualityChange because new media is same as old");
      return;
    }
    this.switchMedia_(media, "fast-quality");
    this.mainSegmentLoader_.resetEverything(function() {
      if (videojs.browser.IE_VERSION || videojs.browser.IS_EDGE) {
        _this5.tech_.setCurrentTime(_this5.tech_.currentTime() + 0.04);
      } else {
        _this5.tech_.setCurrentTime(_this5.tech_.currentTime());
      }
    });
  };
  _proto.play = function play() {
    if (this.setupFirstPlay()) {
      return;
    }
    if (this.tech_.ended()) {
      this.tech_.setCurrentTime(0);
    }
    if (this.hasPlayed_) {
      this.load();
    }
    var seekable3 = this.tech_.seekable();
    if (this.tech_.duration() === Infinity) {
      if (this.tech_.currentTime() < seekable3.start(0)) {
        return this.tech_.setCurrentTime(seekable3.end(seekable3.length - 1));
      }
    }
  };
  _proto.setupFirstPlay = function setupFirstPlay() {
    var _this6 = this;
    var media = this.masterPlaylistLoader_.media();
    if (!media || this.tech_.paused() || this.hasPlayed_) {
      return false;
    }
    if (!media.endList) {
      var seekable3 = this.seekable();
      if (!seekable3.length) {
        return false;
      }
      if (videojs.browser.IE_VERSION && this.tech_.readyState() === 0) {
        this.tech_.one("loadedmetadata", function() {
          _this6.trigger("firstplay");
          _this6.tech_.setCurrentTime(seekable3.end(0));
          _this6.hasPlayed_ = true;
        });
        return false;
      }
      this.trigger("firstplay");
      this.tech_.setCurrentTime(seekable3.end(0));
    }
    this.hasPlayed_ = true;
    this.load();
    return true;
  };
  _proto.handleSourceOpen_ = function handleSourceOpen_() {
    this.tryToCreateSourceBuffers_();
    if (this.tech_.autoplay()) {
      var playPromise = this.tech_.play();
      if (typeof playPromise !== "undefined" && typeof playPromise.then === "function") {
        playPromise.then(null, function(e) {
        });
      }
    }
    this.trigger("sourceopen");
  };
  _proto.handleSourceEnded_ = function handleSourceEnded_() {
    if (!this.inbandTextTracks_.metadataTrack_) {
      return;
    }
    var cues = this.inbandTextTracks_.metadataTrack_.cues;
    if (!cues || !cues.length) {
      return;
    }
    var duration5 = this.duration();
    cues[cues.length - 1].endTime = isNaN(duration5) || Math.abs(duration5) === Infinity ? Number.MAX_VALUE : duration5;
  };
  _proto.handleDurationChange_ = function handleDurationChange_() {
    this.tech_.trigger("durationchange");
  };
  _proto.onEndOfStream = function onEndOfStream() {
    var isEndOfStream = this.mainSegmentLoader_.ended_;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      var mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
      if (!mainMediaInfo || mainMediaInfo.hasVideo) {
        isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;
      } else {
        isEndOfStream = this.audioSegmentLoader_.ended_;
      }
    }
    if (!isEndOfStream) {
      return;
    }
    this.stopABRTimer_();
    this.sourceUpdater_.endOfStream();
  };
  _proto.stuckAtPlaylistEnd_ = function stuckAtPlaylistEnd_(playlist) {
    var seekable3 = this.seekable();
    if (!seekable3.length) {
      return false;
    }
    var expired = this.syncController_.getExpiredTime(playlist, this.duration());
    if (expired === null) {
      return false;
    }
    var absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    if (!buffered.length) {
      return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
    }
    var bufferedEnd = buffered.end(buffered.length - 1);
    return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
  };
  _proto.blacklistCurrentPlaylist = function blacklistCurrentPlaylist(error, blacklistDuration) {
    if (error === void 0) {
      error = {};
    }
    var currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();
    blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;
    if (!currentPlaylist) {
      this.error = error;
      if (this.mediaSource.readyState !== "open") {
        this.trigger("error");
      } else {
        this.sourceUpdater_.endOfStream("network");
      }
      return;
    }
    currentPlaylist.playlistErrors_++;
    var playlists = this.masterPlaylistLoader_.master.playlists;
    var enabledPlaylists = playlists.filter(isEnabled);
    var isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === currentPlaylist;
    if (playlists.length === 1 && blacklistDuration !== Infinity) {
      videojs.log.warn("Problem encountered with playlist " + currentPlaylist.id + ". Trying again since it is the only playlist.");
      this.tech_.trigger("retryplaylist");
      return this.masterPlaylistLoader_.load(isFinalRendition);
    }
    if (isFinalRendition) {
      var reincluded = false;
      playlists.forEach(function(playlist) {
        if (playlist === currentPlaylist) {
          return;
        }
        var excludeUntil2 = playlist.excludeUntil;
        if (typeof excludeUntil2 !== "undefined" && excludeUntil2 !== Infinity) {
          reincluded = true;
          delete playlist.excludeUntil;
        }
      });
      if (reincluded) {
        videojs.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded.");
        this.tech_.trigger("retryplaylist");
      }
    }
    var excludeUntil;
    if (currentPlaylist.playlistErrors_ > this.maxPlaylistRetries) {
      excludeUntil = Infinity;
    } else {
      excludeUntil = Date.now() + blacklistDuration * 1e3;
    }
    currentPlaylist.excludeUntil = excludeUntil;
    if (error.reason) {
      currentPlaylist.lastExcludeReason_ = error.reason;
    }
    this.tech_.trigger("blacklistplaylist");
    this.tech_.trigger({
      type: "usage",
      name: "vhs-rendition-blacklisted"
    });
    this.tech_.trigger({
      type: "usage",
      name: "hls-rendition-blacklisted"
    });
    var nextPlaylist = this.selectPlaylist();
    if (!nextPlaylist) {
      this.error = "Playback cannot continue. No available working or supported playlists.";
      this.trigger("error");
      return;
    }
    var logFn2 = error.internal ? this.logger_ : videojs.log.warn;
    var errorMessage = error.message ? " " + error.message : "";
    logFn2((error.internal ? "Internal problem" : "Problem") + " encountered with playlist " + currentPlaylist.id + "." + (errorMessage + " Switching to playlist " + nextPlaylist.id + "."));
    if (nextPlaylist.attributes.AUDIO !== currentPlaylist.attributes.AUDIO) {
      this.delegateLoaders_("audio", ["abort", "pause"]);
    }
    if (nextPlaylist.attributes.SUBTITLES !== currentPlaylist.attributes.SUBTITLES) {
      this.delegateLoaders_("subtitle", ["abort", "pause"]);
    }
    this.delegateLoaders_("main", ["abort", "pause"]);
    var delayDuration = nextPlaylist.targetDuration / 2 * 1e3 || 5 * 1e3;
    var shouldDelay = typeof nextPlaylist.lastRequest === "number" && Date.now() - nextPlaylist.lastRequest <= delayDuration;
    return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
  };
  _proto.pauseLoading = function pauseLoading() {
    this.delegateLoaders_("all", ["abort", "pause"]);
    this.stopABRTimer_();
  };
  _proto.delegateLoaders_ = function delegateLoaders_(filter, fnNames) {
    var _this7 = this;
    var loaders = [];
    var dontFilterPlaylist = filter === "all";
    if (dontFilterPlaylist || filter === "main") {
      loaders.push(this.masterPlaylistLoader_);
    }
    var mediaTypes2 = [];
    if (dontFilterPlaylist || filter === "audio") {
      mediaTypes2.push("AUDIO");
    }
    if (dontFilterPlaylist || filter === "subtitle") {
      mediaTypes2.push("CLOSED-CAPTIONS");
      mediaTypes2.push("SUBTITLES");
    }
    mediaTypes2.forEach(function(mediaType) {
      var loader = _this7.mediaTypes_[mediaType] && _this7.mediaTypes_[mediaType].activePlaylistLoader;
      if (loader) {
        loaders.push(loader);
      }
    });
    ["main", "audio", "subtitle"].forEach(function(name) {
      var loader = _this7[name + "SegmentLoader_"];
      if (loader && (filter === name || filter === "all")) {
        loaders.push(loader);
      }
    });
    loaders.forEach(function(loader) {
      return fnNames.forEach(function(fnName) {
        if (typeof loader[fnName] === "function") {
          loader[fnName]();
        }
      });
    });
  };
  _proto.setCurrentTime = function setCurrentTime(currentTime) {
    var buffered = findRange(this.tech_.buffered(), currentTime);
    if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {
      return 0;
    }
    if (!this.masterPlaylistLoader_.media().segments) {
      return 0;
    }
    if (buffered && buffered.length) {
      return currentTime;
    }
    this.mainSegmentLoader_.resetEverything();
    this.mainSegmentLoader_.abort();
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      this.audioSegmentLoader_.resetEverything();
      this.audioSegmentLoader_.abort();
    }
    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
      this.subtitleSegmentLoader_.resetEverything();
      this.subtitleSegmentLoader_.abort();
    }
    this.load();
  };
  _proto.duration = function duration5() {
    if (!this.masterPlaylistLoader_) {
      return 0;
    }
    var media = this.masterPlaylistLoader_.media();
    if (!media) {
      return 0;
    }
    if (!media.endList) {
      return Infinity;
    }
    if (this.mediaSource) {
      return this.mediaSource.duration;
    }
    return Vhs$1.Playlist.duration(media);
  };
  _proto.seekable = function seekable3() {
    return this.seekable_;
  };
  _proto.onSyncInfoUpdate_ = function onSyncInfoUpdate_() {
    var audioSeekable;
    if (!this.masterPlaylistLoader_) {
      return;
    }
    var media = this.masterPlaylistLoader_.media();
    if (!media) {
      return;
    }
    var expired = this.syncController_.getExpiredTime(media, this.duration());
    if (expired === null) {
      return;
    }
    var master = this.masterPlaylistLoader_.master;
    var mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
    if (mainSeekable.length === 0) {
      return;
    }
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();
      expired = this.syncController_.getExpiredTime(media, this.duration());
      if (expired === null) {
        return;
      }
      audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
      if (audioSeekable.length === 0) {
        return;
      }
    }
    var oldEnd;
    var oldStart;
    if (this.seekable_ && this.seekable_.length) {
      oldEnd = this.seekable_.end(0);
      oldStart = this.seekable_.start(0);
    }
    if (!audioSeekable) {
      this.seekable_ = mainSeekable;
    } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {
      this.seekable_ = mainSeekable;
    } else {
      this.seekable_ = videojs.createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);
    }
    if (this.seekable_ && this.seekable_.length) {
      if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {
        return;
      }
    }
    this.logger_("seekable updated [" + printableRange(this.seekable_) + "]");
    this.tech_.trigger("seekablechanged");
  };
  _proto.updateDuration = function updateDuration(isLive) {
    if (this.updateDuration_) {
      this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
      this.updateDuration_ = null;
    }
    if (this.mediaSource.readyState !== "open") {
      this.updateDuration_ = this.updateDuration.bind(this, isLive);
      this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
      return;
    }
    if (isLive) {
      var seekable3 = this.seekable();
      if (!seekable3.length) {
        return;
      }
      if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable3.end(seekable3.length - 1)) {
        this.sourceUpdater_.setDuration(seekable3.end(seekable3.length - 1));
      }
      return;
    }
    var buffered = this.tech_.buffered();
    var duration5 = Vhs$1.Playlist.duration(this.masterPlaylistLoader_.media());
    if (buffered.length > 0) {
      duration5 = Math.max(duration5, buffered.end(buffered.length - 1));
    }
    if (this.mediaSource.duration !== duration5) {
      this.sourceUpdater_.setDuration(duration5);
    }
  };
  _proto.dispose = function dispose() {
    var _this8 = this;
    this.trigger("dispose");
    this.decrypter_.terminate();
    this.masterPlaylistLoader_.dispose();
    this.mainSegmentLoader_.dispose();
    if (this.loadOnPlay_) {
      this.tech_.off("play", this.loadOnPlay_);
    }
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      var groups = _this8.mediaTypes_[type2].groups;
      for (var id in groups) {
        groups[id].forEach(function(group) {
          if (group.playlistLoader) {
            group.playlistLoader.dispose();
          }
        });
      }
    });
    this.audioSegmentLoader_.dispose();
    this.subtitleSegmentLoader_.dispose();
    this.sourceUpdater_.dispose();
    this.timelineChangeController_.dispose();
    this.stopABRTimer_();
    if (this.updateDuration_) {
      this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
    }
    this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_);
    this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_);
    this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_);
    this.off();
  };
  _proto.master = function master() {
    return this.masterPlaylistLoader_.master;
  };
  _proto.media = function media() {
    return this.masterPlaylistLoader_.media() || this.initialMedia_;
  };
  _proto.areMediaTypesKnown_ = function areMediaTypesKnown_() {
    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    var hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
    var hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
    if (!hasMainMediaInfo || !hasAudioMediaInfo) {
      return false;
    }
    return true;
  };
  _proto.getCodecsOrExclude_ = function getCodecsOrExclude_() {
    var _this9 = this;
    var media = {
      main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
      audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
    };
    var playlist = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
    media.video = media.main;
    var playlistCodecs = codecsForPlaylist(this.master(), playlist);
    var codecs = {};
    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    if (media.main.hasVideo) {
      codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;
    }
    if (media.main.isMuxed) {
      codecs.video += "," + (playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC);
    }
    if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
      codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC;
      media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
    }
    if (!codecs.audio && !codecs.video) {
      this.blacklistCurrentPlaylist({
        playlist,
        message: "Could not determine codecs for playlist.",
        blacklistDuration: Infinity
      });
      return;
    }
    var supportFunction = function supportFunction2(isFmp4, codec) {
      return isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);
    };
    var unsupportedCodecs = {};
    var unsupportedAudio;
    ["video", "audio"].forEach(function(type2) {
      if (codecs.hasOwnProperty(type2) && !supportFunction(media[type2].isFmp4, codecs[type2])) {
        var supporter = media[type2].isFmp4 ? "browser" : "muxer";
        unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
        unsupportedCodecs[supporter].push(codecs[type2]);
        if (type2 === "audio") {
          unsupportedAudio = supporter;
        }
      }
    });
    if (usingAudioLoader && unsupportedAudio && playlist.attributes.AUDIO) {
      var audioGroup = playlist.attributes.AUDIO;
      this.master().playlists.forEach(function(variant) {
        var variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
        if (variantAudioGroup === audioGroup && variant !== playlist) {
          variant.excludeUntil = Infinity;
        }
      });
      this.logger_("excluding audio group " + audioGroup + " as " + unsupportedAudio + ' does not support codec(s): "' + codecs.audio + '"');
    }
    if (Object.keys(unsupportedCodecs).length) {
      var message = Object.keys(unsupportedCodecs).reduce(function(acc, supporter) {
        if (acc) {
          acc += ", ";
        }
        acc += supporter + ' does not support codec(s): "' + unsupportedCodecs[supporter].join(",") + '"';
        return acc;
      }, "") + ".";
      this.blacklistCurrentPlaylist({
        playlist,
        internal: true,
        message,
        blacklistDuration: Infinity
      });
      return;
    }
    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
      var switchMessages = [];
      ["video", "audio"].forEach(function(type2) {
        var newCodec = (parseCodecs(_this9.sourceUpdater_.codecs[type2] || "")[0] || {}).type;
        var oldCodec = (parseCodecs(codecs[type2] || "")[0] || {}).type;
        if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {
          switchMessages.push('"' + _this9.sourceUpdater_.codecs[type2] + '" -> "' + codecs[type2] + '"');
        }
      });
      if (switchMessages.length) {
        this.blacklistCurrentPlaylist({
          playlist,
          message: "Codec switching not supported: " + switchMessages.join(", ") + ".",
          blacklistDuration: Infinity,
          internal: true
        });
        return;
      }
    }
    return codecs;
  };
  _proto.tryToCreateSourceBuffers_ = function tryToCreateSourceBuffers_() {
    if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) {
      return;
    }
    if (!this.areMediaTypesKnown_()) {
      return;
    }
    var codecs = this.getCodecsOrExclude_();
    if (!codecs) {
      return;
    }
    this.sourceUpdater_.createSourceBuffers(codecs);
    var codecString = [codecs.video, codecs.audio].filter(Boolean).join(",");
    this.excludeIncompatibleVariants_(codecString);
  };
  _proto.excludeUnsupportedVariants_ = function excludeUnsupportedVariants_() {
    var _this10 = this;
    var playlists = this.master().playlists;
    var ids = [];
    Object.keys(playlists).forEach(function(key) {
      var variant = playlists[key];
      if (ids.indexOf(variant.id) !== -1) {
        return;
      }
      ids.push(variant.id);
      var codecs = codecsForPlaylist(_this10.master, variant);
      var unsupported = [];
      if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {
        unsupported.push("audio codec " + codecs.audio);
      }
      if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {
        unsupported.push("video codec " + codecs.video);
      }
      if (codecs.text && codecs.text === "stpp.ttml.im1t") {
        unsupported.push("text codec " + codecs.text);
      }
      if (unsupported.length) {
        variant.excludeUntil = Infinity;
        _this10.logger_("excluding " + variant.id + " for unsupported: " + unsupported.join(", "));
      }
    });
  };
  _proto.excludeIncompatibleVariants_ = function excludeIncompatibleVariants_(codecString) {
    var _this11 = this;
    var ids = [];
    var playlists = this.master().playlists;
    var codecs = unwrapCodecList(parseCodecs(codecString));
    var codecCount_ = codecCount(codecs);
    var videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;
    var audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;
    Object.keys(playlists).forEach(function(key) {
      var variant = playlists[key];
      if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {
        return;
      }
      ids.push(variant.id);
      var blacklistReasons = [];
      var variantCodecs = codecsForPlaylist(_this11.masterPlaylistLoader_.master, variant);
      var variantCodecCount = codecCount(variantCodecs);
      if (!variantCodecs.audio && !variantCodecs.video) {
        return;
      }
      if (variantCodecCount !== codecCount_) {
        blacklistReasons.push('codec count "' + variantCodecCount + '" !== "' + codecCount_ + '"');
      }
      if (!_this11.sourceUpdater_.canChangeType()) {
        var variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;
        var variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null;
        if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {
          blacklistReasons.push('video codec "' + variantVideoDetails.type + '" !== "' + videoDetails.type + '"');
        }
        if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {
          blacklistReasons.push('audio codec "' + variantAudioDetails.type + '" !== "' + audioDetails.type + '"');
        }
      }
      if (blacklistReasons.length) {
        variant.excludeUntil = Infinity;
        _this11.logger_("blacklisting " + variant.id + ": " + blacklistReasons.join(" && "));
      }
    });
  };
  _proto.updateAdCues_ = function updateAdCues_(media) {
    var offset = 0;
    var seekable3 = this.seekable();
    if (seekable3.length) {
      offset = seekable3.start(0);
    }
    updateAdCues(media, this.cueTagsTrack_, offset);
  };
  _proto.goalBufferLength = function goalBufferLength() {
    var currentTime = this.tech_.currentTime();
    var initial = Config.GOAL_BUFFER_LENGTH;
    var rate = Config.GOAL_BUFFER_LENGTH_RATE;
    var max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
    return Math.min(initial + currentTime * rate, max);
  };
  _proto.bufferLowWaterLine = function bufferLowWaterLine() {
    var currentTime = this.tech_.currentTime();
    var initial = Config.BUFFER_LOW_WATER_LINE;
    var rate = Config.BUFFER_LOW_WATER_LINE_RATE;
    var max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);
    var newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
    return Math.min(initial + currentTime * rate, this.experimentalBufferBasedABR ? newMax : max);
  };
  _proto.bufferHighWaterLine = function bufferHighWaterLine() {
    return Config.BUFFER_HIGH_WATER_LINE;
  };
  return MasterPlaylistController2;
}(videojs.EventTarget);
var enableFunction = function enableFunction2(loader, playlistID, changePlaylistFn) {
  return function(enable) {
    var playlist = loader.master.playlists[playlistID];
    var incompatible = isIncompatible(playlist);
    var currentlyEnabled = isEnabled(playlist);
    if (typeof enable === "undefined") {
      return currentlyEnabled;
    }
    if (enable) {
      delete playlist.disabled;
    } else {
      playlist.disabled = true;
    }
    if (enable !== currentlyEnabled && !incompatible) {
      changePlaylistFn();
      if (enable) {
        loader.trigger("renditionenabled");
      } else {
        loader.trigger("renditiondisabled");
      }
    }
    return enable;
  };
};
var Representation = function Representation2(vhsHandler, playlist, id) {
  var mpc = vhsHandler.masterPlaylistController_, smoothQualityChange = vhsHandler.options_.smoothQualityChange;
  var changeType2 = smoothQualityChange ? "smooth" : "fast";
  var qualityChangeFunction = mpc[changeType2 + "QualityChange_"].bind(mpc);
  if (playlist.attributes) {
    var resolution = playlist.attributes.RESOLUTION;
    this.width = resolution && resolution.width;
    this.height = resolution && resolution.height;
    this.bandwidth = playlist.attributes.BANDWIDTH;
    this.frameRate = playlist.attributes["FRAME-RATE"];
  }
  this.codecs = codecsForPlaylist(mpc.master(), playlist);
  this.playlist = playlist;
  this.id = id;
  this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
};
var renditionSelectionMixin = function renditionSelectionMixin2(vhsHandler) {
  vhsHandler.representations = function() {
    var master = vhsHandler.masterPlaylistController_.master();
    var playlists = isAudioOnly(master) ? vhsHandler.masterPlaylistController_.getAudioTrackPlaylists_() : master.playlists;
    if (!playlists) {
      return [];
    }
    return playlists.filter(function(media) {
      return !isIncompatible(media);
    }).map(function(e, i) {
      return new Representation(vhsHandler, e, e.id);
    });
  };
};
var timerCancelEvents = ["seeking", "seeked", "pause", "playing", "error"];
var PlaybackWatcher = function() {
  function PlaybackWatcher2(options) {
    var _this = this;
    this.masterPlaylistController_ = options.masterPlaylistController;
    this.tech_ = options.tech;
    this.seekable = options.seekable;
    this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
    this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
    this.media = options.media;
    this.consecutiveUpdates = 0;
    this.lastRecordedTime = null;
    this.timer_ = null;
    this.checkCurrentTimeTimeout_ = null;
    this.logger_ = logger("PlaybackWatcher");
    this.logger_("initialize");
    var playHandler = function playHandler2() {
      return _this.monitorCurrentTime_();
    };
    var canPlayHandler = function canPlayHandler2() {
      return _this.monitorCurrentTime_();
    };
    var waitingHandler = function waitingHandler2() {
      return _this.techWaiting_();
    };
    var cancelTimerHandler = function cancelTimerHandler2() {
      return _this.cancelTimer_();
    };
    var mpc = this.masterPlaylistController_;
    var loaderTypes = ["main", "subtitle", "audio"];
    var loaderChecks = {};
    loaderTypes.forEach(function(type2) {
      loaderChecks[type2] = {
        reset: function reset3() {
          return _this.resetSegmentDownloads_(type2);
        },
        updateend: function updateend() {
          return _this.checkSegmentDownloads_(type2);
        }
      };
      mpc[type2 + "SegmentLoader_"].on("appendsdone", loaderChecks[type2].updateend);
      mpc[type2 + "SegmentLoader_"].on("playlistupdate", loaderChecks[type2].reset);
      _this.tech_.on(["seeked", "seeking"], loaderChecks[type2].reset);
    });
    var setSeekingHandlers = function setSeekingHandlers2(fn) {
      ["main", "audio"].forEach(function(type2) {
        mpc[type2 + "SegmentLoader_"][fn]("appended", _this.seekingAppendCheck_);
      });
    };
    this.seekingAppendCheck_ = function() {
      if (_this.fixesBadSeeks_()) {
        _this.consecutiveUpdates = 0;
        _this.lastRecordedTime = _this.tech_.currentTime();
        setSeekingHandlers("off");
      }
    };
    this.clearSeekingAppendCheck_ = function() {
      return setSeekingHandlers("off");
    };
    this.watchForBadSeeking_ = function() {
      _this.clearSeekingAppendCheck_();
      setSeekingHandlers("on");
    };
    this.tech_.on("seeked", this.clearSeekingAppendCheck_);
    this.tech_.on("seeking", this.watchForBadSeeking_);
    this.tech_.on("waiting", waitingHandler);
    this.tech_.on(timerCancelEvents, cancelTimerHandler);
    this.tech_.on("canplay", canPlayHandler);
    this.tech_.one("play", playHandler);
    this.dispose = function() {
      _this.clearSeekingAppendCheck_();
      _this.logger_("dispose");
      _this.tech_.off("waiting", waitingHandler);
      _this.tech_.off(timerCancelEvents, cancelTimerHandler);
      _this.tech_.off("canplay", canPlayHandler);
      _this.tech_.off("play", playHandler);
      _this.tech_.off("seeking", _this.watchForBadSeeking_);
      _this.tech_.off("seeked", _this.clearSeekingAppendCheck_);
      loaderTypes.forEach(function(type2) {
        mpc[type2 + "SegmentLoader_"].off("appendsdone", loaderChecks[type2].updateend);
        mpc[type2 + "SegmentLoader_"].off("playlistupdate", loaderChecks[type2].reset);
        _this.tech_.off(["seeked", "seeking"], loaderChecks[type2].reset);
      });
      if (_this.checkCurrentTimeTimeout_) {
        import_window6.default.clearTimeout(_this.checkCurrentTimeTimeout_);
      }
      _this.cancelTimer_();
    };
  }
  var _proto = PlaybackWatcher2.prototype;
  _proto.monitorCurrentTime_ = function monitorCurrentTime_() {
    this.checkCurrentTime_();
    if (this.checkCurrentTimeTimeout_) {
      import_window6.default.clearTimeout(this.checkCurrentTimeTimeout_);
    }
    this.checkCurrentTimeTimeout_ = import_window6.default.setTimeout(this.monitorCurrentTime_.bind(this), 250);
  };
  _proto.resetSegmentDownloads_ = function resetSegmentDownloads_(type2) {
    var loader = this.masterPlaylistController_[type2 + "SegmentLoader_"];
    if (this[type2 + "StalledDownloads_"] > 0) {
      this.logger_("resetting possible stalled download count for " + type2 + " loader");
    }
    this[type2 + "StalledDownloads_"] = 0;
    this[type2 + "Buffered_"] = loader.buffered_();
  };
  _proto.checkSegmentDownloads_ = function checkSegmentDownloads_(type2) {
    var mpc = this.masterPlaylistController_;
    var loader = mpc[type2 + "SegmentLoader_"];
    var buffered = loader.buffered_();
    var isBufferedDifferent = isRangeDifferent(this[type2 + "Buffered_"], buffered);
    this[type2 + "Buffered_"] = buffered;
    if (isBufferedDifferent) {
      this.resetSegmentDownloads_(type2);
      return;
    }
    this[type2 + "StalledDownloads_"]++;
    this.logger_("found #" + this[type2 + "StalledDownloads_"] + " " + type2 + " appends that did not increase buffer (possible stalled download)", {
      playlistId: loader.playlist_ && loader.playlist_.id,
      buffered: timeRangesToArray(buffered)
    });
    if (this[type2 + "StalledDownloads_"] < 10) {
      return;
    }
    this.logger_(type2 + " loader stalled download exclusion");
    this.resetSegmentDownloads_(type2);
    this.tech_.trigger({
      type: "usage",
      name: "vhs-" + type2 + "-download-exclusion"
    });
    if (type2 === "subtitle") {
      return;
    }
    mpc.blacklistCurrentPlaylist({
      message: "Excessive " + type2 + " segment downloading detected."
    }, Infinity);
  };
  _proto.checkCurrentTime_ = function checkCurrentTime_() {
    if (this.tech_.paused() || this.tech_.seeking()) {
      return;
    }
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {
      return this.techWaiting_();
    }
    if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
      this.consecutiveUpdates++;
      this.waiting_();
    } else if (currentTime === this.lastRecordedTime) {
      this.consecutiveUpdates++;
    } else {
      this.consecutiveUpdates = 0;
      this.lastRecordedTime = currentTime;
    }
  };
  _proto.cancelTimer_ = function cancelTimer_() {
    this.consecutiveUpdates = 0;
    if (this.timer_) {
      this.logger_("cancelTimer_");
      clearTimeout(this.timer_);
    }
    this.timer_ = null;
  };
  _proto.fixesBadSeeks_ = function fixesBadSeeks_() {
    var seeking = this.tech_.seeking();
    if (!seeking) {
      return false;
    }
    var seekable3 = this.seekable();
    var currentTime = this.tech_.currentTime();
    var isAfterSeekableRange = this.afterSeekableWindow_(seekable3, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
    var seekTo;
    if (isAfterSeekableRange) {
      var seekableEnd = seekable3.end(seekable3.length - 1);
      seekTo = seekableEnd;
    }
    if (this.beforeSeekableWindow_(seekable3, currentTime)) {
      var seekableStart = seekable3.start(0);
      seekTo = seekableStart + // if the playlist is too short and the seekable range is an exact time (can
      // happen in live with a 3 segment playlist), then don't use a time delta
      (seekableStart === seekable3.end(0) ? 0 : SAFE_TIME_DELTA);
    }
    if (typeof seekTo !== "undefined") {
      this.logger_("Trying to seek outside of seekable at time " + currentTime + " with " + ("seekable range " + printableRange(seekable3) + ". Seeking to ") + (seekTo + "."));
      this.tech_.setCurrentTime(seekTo);
      return true;
    }
    var sourceUpdater = this.masterPlaylistController_.sourceUpdater_;
    var buffered = this.tech_.buffered();
    var audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
    var videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
    var media = this.media();
    var minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2;
    var bufferedToCheck = [audioBuffered, videoBuffered];
    for (var i = 0; i < bufferedToCheck.length; i++) {
      if (!bufferedToCheck[i]) {
        continue;
      }
      var timeAhead = timeAheadOf(bufferedToCheck[i], currentTime);
      if (timeAhead < minAppendedDuration) {
        return false;
      }
    }
    var nextRange = findNextRange(buffered, currentTime);
    if (nextRange.length === 0) {
      return false;
    }
    seekTo = nextRange.start(0) + SAFE_TIME_DELTA;
    this.logger_("Buffered region starts (" + nextRange.start(0) + ") " + (" just beyond seek point (" + currentTime + "). Seeking to " + seekTo + "."));
    this.tech_.setCurrentTime(seekTo);
    return true;
  };
  _proto.waiting_ = function waiting_() {
    if (this.techWaiting_()) {
      return;
    }
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    var currentRange = findRange(buffered, currentTime);
    if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
      this.cancelTimer_();
      this.tech_.setCurrentTime(currentTime);
      this.logger_("Stopped at " + currentTime + " while inside a buffered region " + ("[" + currentRange.start(0) + " -> " + currentRange.end(0) + "]. Attempting to resume ") + "playback by seeking to the current time.");
      this.tech_.trigger({
        type: "usage",
        name: "vhs-unknown-waiting"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-unknown-waiting"
      });
      return;
    }
  };
  _proto.techWaiting_ = function techWaiting_() {
    var seekable3 = this.seekable();
    var currentTime = this.tech_.currentTime();
    if (this.tech_.seeking() || this.timer_ !== null) {
      return true;
    }
    if (this.beforeSeekableWindow_(seekable3, currentTime)) {
      var livePoint = seekable3.end(seekable3.length - 1);
      this.logger_("Fell out of live window at time " + currentTime + ". Seeking to " + ("live point (seekable end) " + livePoint));
      this.cancelTimer_();
      this.tech_.setCurrentTime(livePoint);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-live-resync"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-live-resync"
      });
      return true;
    }
    var sourceUpdater = this.tech_.vhs.masterPlaylistController_.sourceUpdater_;
    var buffered = this.tech_.buffered();
    var videoUnderflow = this.videoUnderflow_({
      audioBuffered: sourceUpdater.audioBuffered(),
      videoBuffered: sourceUpdater.videoBuffered(),
      currentTime
    });
    if (videoUnderflow) {
      this.cancelTimer_();
      this.tech_.setCurrentTime(currentTime);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-video-underflow"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-video-underflow"
      });
      return true;
    }
    var nextRange = findNextRange(buffered, currentTime);
    if (nextRange.length > 0) {
      var difference = nextRange.start(0) - currentTime;
      this.logger_("Stopped at " + currentTime + ", setting timer for " + difference + ", seeking " + ("to " + nextRange.start(0)));
      this.cancelTimer_();
      this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1e3, currentTime);
      return true;
    }
    return false;
  };
  _proto.afterSeekableWindow_ = function afterSeekableWindow_(seekable3, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow) {
    if (allowSeeksWithinUnsafeLiveWindow === void 0) {
      allowSeeksWithinUnsafeLiveWindow = false;
    }
    if (!seekable3.length) {
      return false;
    }
    var allowedEnd = seekable3.end(seekable3.length - 1) + SAFE_TIME_DELTA;
    var isLive = !playlist.endList;
    if (isLive && allowSeeksWithinUnsafeLiveWindow) {
      allowedEnd = seekable3.end(seekable3.length - 1) + playlist.targetDuration * 3;
    }
    if (currentTime > allowedEnd) {
      return true;
    }
    return false;
  };
  _proto.beforeSeekableWindow_ = function beforeSeekableWindow_(seekable3, currentTime) {
    if (seekable3.length && // can't fall before 0 and 0 seekable start identifies VOD stream
    seekable3.start(0) > 0 && currentTime < seekable3.start(0) - this.liveRangeSafeTimeDelta) {
      return true;
    }
    return false;
  };
  _proto.videoUnderflow_ = function videoUnderflow_(_ref) {
    var videoBuffered = _ref.videoBuffered, audioBuffered = _ref.audioBuffered, currentTime = _ref.currentTime;
    if (!videoBuffered) {
      return;
    }
    var gap;
    if (videoBuffered.length && audioBuffered.length) {
      var lastVideoRange = findRange(videoBuffered, currentTime - 3);
      var videoRange = findRange(videoBuffered, currentTime);
      var audioRange = findRange(audioBuffered, currentTime);
      if (audioRange.length && !videoRange.length && lastVideoRange.length) {
        gap = {
          start: lastVideoRange.end(0),
          end: audioRange.end(0)
        };
      }
    } else {
      var nextRange = findNextRange(videoBuffered, currentTime);
      if (!nextRange.length) {
        gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
      }
    }
    if (gap) {
      this.logger_("Encountered a gap in video from " + gap.start + " to " + gap.end + ". " + ("Seeking to current time " + currentTime));
      return true;
    }
    return false;
  };
  _proto.skipTheGap_ = function skipTheGap_(scheduledCurrentTime) {
    var buffered = this.tech_.buffered();
    var currentTime = this.tech_.currentTime();
    var nextRange = findNextRange(buffered, currentTime);
    this.cancelTimer_();
    if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {
      return;
    }
    this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0));
    this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);
    this.tech_.trigger({
      type: "usage",
      name: "vhs-gap-skip"
    });
    this.tech_.trigger({
      type: "usage",
      name: "hls-gap-skip"
    });
  };
  _proto.gapFromVideoUnderflow_ = function gapFromVideoUnderflow_(buffered, currentTime) {
    var gaps = findGaps(buffered);
    for (var i = 0; i < gaps.length; i++) {
      var start2 = gaps.start(i);
      var end = gaps.end(i);
      if (currentTime - start2 < 4 && currentTime - start2 > 2) {
        return {
          start: start2,
          end
        };
      }
    }
    return null;
  };
  return PlaybackWatcher2;
}();
var defaultOptions = {
  errorInterval: 30,
  getSource: function getSource(next) {
    var tech = this.tech({
      IWillNotUseThisInPlugins: true
    });
    var sourceObj = tech.currentSource_ || this.currentSource();
    return next(sourceObj);
  }
};
var initPlugin = function initPlugin2(player, options) {
  var lastCalled = 0;
  var seekTo = 0;
  var localOptions = videojs.mergeOptions(defaultOptions, options);
  player.ready(function() {
    player.trigger({
      type: "usage",
      name: "vhs-error-reload-initialized"
    });
    player.trigger({
      type: "usage",
      name: "hls-error-reload-initialized"
    });
  });
  var loadedMetadataHandler = function loadedMetadataHandler2() {
    if (seekTo) {
      player.currentTime(seekTo);
    }
  };
  var setSource2 = function setSource3(sourceObj) {
    if (sourceObj === null || sourceObj === void 0) {
      return;
    }
    seekTo = player.duration() !== Infinity && player.currentTime() || 0;
    player.one("loadedmetadata", loadedMetadataHandler);
    player.src(sourceObj);
    player.trigger({
      type: "usage",
      name: "vhs-error-reload"
    });
    player.trigger({
      type: "usage",
      name: "hls-error-reload"
    });
    player.play();
  };
  var errorHandler = function errorHandler2() {
    if (Date.now() - lastCalled < localOptions.errorInterval * 1e3) {
      player.trigger({
        type: "usage",
        name: "vhs-error-reload-canceled"
      });
      player.trigger({
        type: "usage",
        name: "hls-error-reload-canceled"
      });
      return;
    }
    if (!localOptions.getSource || typeof localOptions.getSource !== "function") {
      videojs.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
      return;
    }
    lastCalled = Date.now();
    return localOptions.getSource.call(player, setSource2);
  };
  var cleanupEvents = function cleanupEvents2() {
    player.off("loadedmetadata", loadedMetadataHandler);
    player.off("error", errorHandler);
    player.off("dispose", cleanupEvents2);
  };
  var reinitPlugin = function reinitPlugin2(newOptions) {
    cleanupEvents();
    initPlugin2(player, newOptions);
  };
  player.on("error", errorHandler);
  player.on("dispose", cleanupEvents);
  player.reloadSourceOnError = reinitPlugin;
};
var reloadSourceOnError = function reloadSourceOnError2(options) {
  initPlugin(this, options);
};
var version$4 = "2.16.3";
var version$3 = "6.0.1";
var version$2 = "0.22.1";
var version$1 = "4.8.0";
var version = "3.1.3";
var Vhs = {
  PlaylistLoader,
  Playlist,
  utils,
  STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
  INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,
  lastBandwidthSelector,
  movingAverageBandwidthSelector,
  comparePlaylistBandwidth,
  comparePlaylistResolution,
  xhr: xhrFactory()
};
Object.keys(Config).forEach(function(prop) {
  Object.defineProperty(Vhs, prop, {
    get: function get7() {
      videojs.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing");
      return Config[prop];
    },
    set: function set4(value) {
      videojs.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing");
      if (typeof value !== "number" || value < 0) {
        videojs.log.warn("value of Vhs." + prop + " must be greater than or equal to 0");
        return;
      }
      Config[prop] = value;
    }
  });
});
var LOCAL_STORAGE_KEY = "videojs-vhs";
var handleVhsMediaChange = function handleVhsMediaChange2(qualityLevels, playlistLoader) {
  var newPlaylist = playlistLoader.media();
  var selectedIndex = -1;
  for (var i = 0; i < qualityLevels.length; i++) {
    if (qualityLevels[i].id === newPlaylist.id) {
      selectedIndex = i;
      break;
    }
  }
  qualityLevels.selectedIndex_ = selectedIndex;
  qualityLevels.trigger({
    selectedIndex,
    type: "change"
  });
};
var handleVhsLoadedMetadata = function handleVhsLoadedMetadata2(qualityLevels, vhs) {
  vhs.representations().forEach(function(rep) {
    qualityLevels.addQualityLevel(rep);
  });
  handleVhsMediaChange(qualityLevels, vhs.playlists);
};
Vhs.canPlaySource = function() {
  return videojs.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
};
var emeKeySystems = function emeKeySystems2(keySystemOptions, mainPlaylist, audioPlaylist) {
  if (!keySystemOptions) {
    return keySystemOptions;
  }
  var codecs = {};
  if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {
    codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));
  }
  if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {
    codecs.audio = audioPlaylist.attributes.CODECS;
  }
  var videoContentType = getMimeForCodec(codecs.video);
  var audioContentType = getMimeForCodec(codecs.audio);
  var keySystemContentTypes = {};
  for (var keySystem in keySystemOptions) {
    keySystemContentTypes[keySystem] = {};
    if (audioContentType) {
      keySystemContentTypes[keySystem].audioContentType = audioContentType;
    }
    if (videoContentType) {
      keySystemContentTypes[keySystem].videoContentType = videoContentType;
    }
    if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {
      keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
    }
    if (typeof keySystemOptions[keySystem] === "string") {
      keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
    }
  }
  return videojs.mergeOptions(keySystemOptions, keySystemContentTypes);
};
var getAllPsshKeySystemsOptions = function getAllPsshKeySystemsOptions2(playlists, keySystems) {
  return playlists.reduce(function(keySystemsArr, playlist) {
    if (!playlist.contentProtection) {
      return keySystemsArr;
    }
    var keySystemsOptions = keySystems.reduce(function(keySystemsObj, keySystem) {
      var keySystemOptions = playlist.contentProtection[keySystem];
      if (keySystemOptions && keySystemOptions.pssh) {
        keySystemsObj[keySystem] = {
          pssh: keySystemOptions.pssh
        };
      }
      return keySystemsObj;
    }, {});
    if (Object.keys(keySystemsOptions).length) {
      keySystemsArr.push(keySystemsOptions);
    }
    return keySystemsArr;
  }, []);
};
var waitForKeySessionCreation = function waitForKeySessionCreation2(_ref) {
  var player = _ref.player, sourceKeySystems = _ref.sourceKeySystems, audioMedia = _ref.audioMedia, mainPlaylists = _ref.mainPlaylists;
  if (!player.eme.initializeMediaKeys) {
    return Promise.resolve();
  }
  var playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;
  var keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
  var initializationFinishedPromises = [];
  var keySessionCreatedPromises = [];
  keySystemsOptionsArr.forEach(function(keySystemsOptions) {
    keySessionCreatedPromises.push(new Promise(function(resolve, reject) {
      player.tech_.one("keysessioncreated", resolve);
    }));
    initializationFinishedPromises.push(new Promise(function(resolve, reject) {
      player.eme.initializeMediaKeys({
        keySystems: keySystemsOptions
      }, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    }));
  });
  return Promise.race([
    // If a session was previously created, these will all finish resolving without
    // creating a new session, otherwise it will take until the end of all license
    // requests, which is why the key session check is used (to make setup much faster).
    Promise.all(initializationFinishedPromises),
    // Once a single session is created, the browser knows DRM will be used.
    Promise.race(keySessionCreatedPromises)
  ]);
};
var setupEmeOptions = function setupEmeOptions2(_ref2) {
  var player = _ref2.player, sourceKeySystems = _ref2.sourceKeySystems, media = _ref2.media, audioMedia = _ref2.audioMedia;
  var sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);
  if (!sourceOptions) {
    return false;
  }
  player.currentSource().keySystems = sourceOptions;
  if (sourceOptions && !player.eme) {
    videojs.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin");
    return false;
  }
  return true;
};
var getVhsLocalStorage = function getVhsLocalStorage2() {
  if (!import_window6.default.localStorage) {
    return null;
  }
  var storedObject = import_window6.default.localStorage.getItem(LOCAL_STORAGE_KEY);
  if (!storedObject) {
    return null;
  }
  try {
    return JSON.parse(storedObject);
  } catch (e) {
    return null;
  }
};
var updateVhsLocalStorage = function updateVhsLocalStorage2(options) {
  if (!import_window6.default.localStorage) {
    return false;
  }
  var objectToStore = getVhsLocalStorage();
  objectToStore = objectToStore ? videojs.mergeOptions(objectToStore, options) : options;
  try {
    import_window6.default.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
  } catch (e) {
    return false;
  }
  return objectToStore;
};
var expandDataUri = function expandDataUri2(dataUri) {
  if (dataUri.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0) {
    return JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1));
  }
  return dataUri;
};
Vhs.supportsNativeHls = function() {
  if (!import_document.default || !import_document.default.createElement) {
    return false;
  }
  var video = import_document.default.createElement("video");
  if (!videojs.getTech("Html5").isSupported()) {
    return false;
  }
  var canPlay = [
    // Apple santioned
    "application/vnd.apple.mpegurl",
    // Apple sanctioned for backwards compatibility
    "audio/mpegurl",
    // Very common
    "audio/x-mpegurl",
    // Very common
    "application/x-mpegurl",
    // Included for completeness
    "video/x-mpegurl",
    "video/mpegurl",
    "application/mpegurl"
  ];
  return canPlay.some(function(canItPlay) {
    return /maybe|probably/i.test(video.canPlayType(canItPlay));
  });
}();
Vhs.supportsNativeDash = function() {
  if (!import_document.default || !import_document.default.createElement || !videojs.getTech("Html5").isSupported()) {
    return false;
  }
  return /maybe|probably/i.test(import_document.default.createElement("video").canPlayType("application/dash+xml"));
}();
Vhs.supportsTypeNatively = function(type2) {
  if (type2 === "hls") {
    return Vhs.supportsNativeHls;
  }
  if (type2 === "dash") {
    return Vhs.supportsNativeDash;
  }
  return false;
};
Vhs.isSupported = function() {
  return videojs.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
};
var Component = videojs.getComponent("Component");
var VhsHandler = function(_Component) {
  _inheritsLoose(VhsHandler2, _Component);
  function VhsHandler2(source, tech, options) {
    var _this;
    _this = _Component.call(this, tech, videojs.mergeOptions(options.hls, options.vhs)) || this;
    if (options.hls && Object.keys(options.hls).length) {
      videojs.log.warn("Using hls options is deprecated. Please rename `hls` to `vhs` in your options object.");
    }
    if (typeof options.initialBandwidth === "number") {
      _this.options_.bandwidth = options.initialBandwidth;
    }
    _this.logger_ = logger("VhsHandler");
    if (tech.options_ && tech.options_.playerId) {
      var _player = videojs(tech.options_.playerId);
      if (!_player.hasOwnProperty("hls")) {
        Object.defineProperty(_player, "hls", {
          get: function get7() {
            videojs.log.warn("player.hls is deprecated. Use player.tech().vhs instead.");
            tech.trigger({
              type: "usage",
              name: "hls-player-access"
            });
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      if (!_player.hasOwnProperty("vhs")) {
        Object.defineProperty(_player, "vhs", {
          get: function get7() {
            videojs.log.warn("player.vhs is deprecated. Use player.tech().vhs instead.");
            tech.trigger({
              type: "usage",
              name: "vhs-player-access"
            });
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      if (!_player.hasOwnProperty("dash")) {
        Object.defineProperty(_player, "dash", {
          get: function get7() {
            videojs.log.warn("player.dash is deprecated. Use player.tech().vhs instead.");
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      _this.player_ = _player;
    }
    _this.tech_ = tech;
    _this.source_ = source;
    _this.stats = {};
    _this.ignoreNextSeekingEvent_ = false;
    _this.setOptions_();
    if (_this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
      tech.overrideNativeAudioTracks(true);
      tech.overrideNativeVideoTracks(true);
    } else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {
      throw new Error("Overriding native HLS requires emulated tracks. See https://git.io/vMpjB");
    }
    _this.on(import_document.default, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], function(event) {
      var fullscreenElement = import_document.default.fullscreenElement || import_document.default.webkitFullscreenElement || import_document.default.mozFullScreenElement || import_document.default.msFullscreenElement;
      if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {
        _this.masterPlaylistController_.fastQualityChange_();
      } else {
        _this.masterPlaylistController_.checkABR_();
      }
    });
    _this.on(_this.tech_, "seeking", function() {
      if (this.ignoreNextSeekingEvent_) {
        this.ignoreNextSeekingEvent_ = false;
        return;
      }
      this.setCurrentTime(this.tech_.currentTime());
    });
    _this.on(_this.tech_, "error", function() {
      if (this.tech_.error() && this.masterPlaylistController_) {
        this.masterPlaylistController_.pauseLoading();
      }
    });
    _this.on(_this.tech_, "play", _this.play);
    return _this;
  }
  var _proto = VhsHandler2.prototype;
  _proto.setOptions_ = function setOptions_() {
    var _this2 = this;
    this.options_.withCredentials = this.options_.withCredentials || false;
    this.options_.handleManifestRedirects = this.options_.handleManifestRedirects === false ? false : true;
    this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
    this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
    this.options_.smoothQualityChange = this.options_.smoothQualityChange || false;
    this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== "undefined" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
    this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
    this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;
    this.options_.customTagParsers = this.options_.customTagParsers || [];
    this.options_.customTagMappers = this.options_.customTagMappers || [];
    this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
    if (typeof this.options_.blacklistDuration !== "number") {
      this.options_.blacklistDuration = 5 * 60;
    }
    if (typeof this.options_.bandwidth !== "number") {
      if (this.options_.useBandwidthFromLocalStorage) {
        var storedObject = getVhsLocalStorage();
        if (storedObject && storedObject.bandwidth) {
          this.options_.bandwidth = storedObject.bandwidth;
          this.tech_.trigger({
            type: "usage",
            name: "vhs-bandwidth-from-local-storage"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-bandwidth-from-local-storage"
          });
        }
        if (storedObject && storedObject.throughput) {
          this.options_.throughput = storedObject.throughput;
          this.tech_.trigger({
            type: "usage",
            name: "vhs-throughput-from-local-storage"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-throughput-from-local-storage"
          });
        }
      }
    }
    if (typeof this.options_.bandwidth !== "number") {
      this.options_.bandwidth = Config.INITIAL_BANDWIDTH;
    }
    this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH;
    ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "smoothQualityChange", "customTagParsers", "customTagMappers", "handleManifestRedirects", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "experimentalBufferBasedABR", "liveRangeSafeTimeDelta", "experimentalLLHLS", "useNetworkInformationApi", "useDtsForTimestampOffset", "experimentalExactManifestTimings", "experimentalLeastPixelDiffSelector"].forEach(function(option) {
      if (typeof _this2.source_[option] !== "undefined") {
        _this2.options_[option] = _this2.source_[option];
      }
    });
    this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
    this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
  };
  _proto.src = function src(_src, type2) {
    var _this3 = this;
    if (!_src) {
      return;
    }
    this.setOptions_();
    this.options_.src = expandDataUri(this.source_.src);
    this.options_.tech = this.tech_;
    this.options_.externVhs = Vhs;
    this.options_.sourceType = simpleTypeFromSourceType(type2);
    this.options_.seekTo = function(time) {
      _this3.tech_.setCurrentTime(time);
    };
    if (this.options_.smoothQualityChange) {
      videojs.log.warn("smoothQualityChange is deprecated and will be removed in the next major version");
    }
    this.masterPlaylistController_ = new MasterPlaylistController(this.options_);
    var playbackWatcherOptions = videojs.mergeOptions({
      liveRangeSafeTimeDelta: SAFE_TIME_DELTA
    }, this.options_, {
      seekable: function seekable3() {
        return _this3.seekable();
      },
      media: function media() {
        return _this3.masterPlaylistController_.media();
      },
      masterPlaylistController: this.masterPlaylistController_
    });
    this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);
    this.masterPlaylistController_.on("error", function() {
      var player = videojs.players[_this3.tech_.options_.playerId];
      var error = _this3.masterPlaylistController_.error;
      if (typeof error === "object" && !error.code) {
        error.code = 3;
      } else if (typeof error === "string") {
        error = {
          message: error,
          code: 3
        };
      }
      player.error(error);
    });
    var defaultSelector = this.options_.experimentalBufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
    this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
    this.masterPlaylistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
    this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;
    this.mediaSource = this.masterPlaylistController_.mediaSource;
    Object.defineProperties(this, {
      selectPlaylist: {
        get: function get7() {
          return this.masterPlaylistController_.selectPlaylist;
        },
        set: function set4(selectPlaylist) {
          this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);
        }
      },
      throughput: {
        get: function get7() {
          return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;
        },
        set: function set4(throughput) {
          this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput;
          this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;
        }
      },
      bandwidth: {
        get: function get7() {
          var playerBandwidthEst = this.masterPlaylistController_.mainSegmentLoader_.bandwidth;
          var networkInformation = import_window6.default.navigator.connection || import_window6.default.navigator.mozConnection || import_window6.default.navigator.webkitConnection;
          var tenMbpsAsBitsPerSecond = 1e7;
          if (this.options_.useNetworkInformationApi && networkInformation) {
            var networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1e3 * 1e3;
            if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {
              playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);
            } else {
              playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
            }
          }
          return playerBandwidthEst;
        },
        set: function set4(bandwidth2) {
          this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth2;
          this.masterPlaylistController_.mainSegmentLoader_.throughput = {
            rate: 0,
            count: 0
          };
        }
      },
      /**
       * `systemBandwidth` is a combination of two serial processes bit-rates. The first
       * is the network bitrate provided by `bandwidth` and the second is the bitrate of
       * the entire process after that - decryption, transmuxing, and appending - provided
       * by `throughput`.
       *
       * Since the two process are serial, the overall system bandwidth is given by:
       *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
       */
      systemBandwidth: {
        get: function get7() {
          var invBandwidth = 1 / (this.bandwidth || 1);
          var invThroughput;
          if (this.throughput > 0) {
            invThroughput = 1 / this.throughput;
          } else {
            invThroughput = 0;
          }
          var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
          return systemBitrate;
        },
        set: function set4() {
          videojs.log.error('The "systemBandwidth" property is read-only');
        }
      }
    });
    if (this.options_.bandwidth) {
      this.bandwidth = this.options_.bandwidth;
    }
    if (this.options_.throughput) {
      this.throughput = this.options_.throughput;
    }
    Object.defineProperties(this.stats, {
      bandwidth: {
        get: function get7() {
          return _this3.bandwidth || 0;
        },
        enumerable: true
      },
      mediaRequests: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaRequests_() || 0;
        },
        enumerable: true
      },
      mediaRequestsAborted: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;
        },
        enumerable: true
      },
      mediaRequestsTimedout: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;
        },
        enumerable: true
      },
      mediaRequestsErrored: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;
        },
        enumerable: true
      },
      mediaTransferDuration: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;
        },
        enumerable: true
      },
      mediaBytesTransferred: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;
        },
        enumerable: true
      },
      mediaSecondsLoaded: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;
        },
        enumerable: true
      },
      mediaAppends: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaAppends_() || 0;
        },
        enumerable: true
      },
      mainAppendsToLoadedData: {
        get: function get7() {
          return _this3.masterPlaylistController_.mainAppendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      audioAppendsToLoadedData: {
        get: function get7() {
          return _this3.masterPlaylistController_.audioAppendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      appendsToLoadedData: {
        get: function get7() {
          return _this3.masterPlaylistController_.appendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      timeToLoadedData: {
        get: function get7() {
          return _this3.masterPlaylistController_.timeToLoadedData_() || 0;
        },
        enumerable: true
      },
      buffered: {
        get: function get7() {
          return timeRangesToArray(_this3.tech_.buffered());
        },
        enumerable: true
      },
      currentTime: {
        get: function get7() {
          return _this3.tech_.currentTime();
        },
        enumerable: true
      },
      currentSource: {
        get: function get7() {
          return _this3.tech_.currentSource_;
        },
        enumerable: true
      },
      currentTech: {
        get: function get7() {
          return _this3.tech_.name_;
        },
        enumerable: true
      },
      duration: {
        get: function get7() {
          return _this3.tech_.duration();
        },
        enumerable: true
      },
      master: {
        get: function get7() {
          return _this3.playlists.master;
        },
        enumerable: true
      },
      playerDimensions: {
        get: function get7() {
          return _this3.tech_.currentDimensions();
        },
        enumerable: true
      },
      seekable: {
        get: function get7() {
          return timeRangesToArray(_this3.tech_.seekable());
        },
        enumerable: true
      },
      timestamp: {
        get: function get7() {
          return Date.now();
        },
        enumerable: true
      },
      videoPlaybackQuality: {
        get: function get7() {
          return _this3.tech_.getVideoPlaybackQuality();
        },
        enumerable: true
      }
    });
    this.tech_.one("canplay", this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));
    this.tech_.on("bandwidthupdate", function() {
      if (_this3.options_.useBandwidthFromLocalStorage) {
        updateVhsLocalStorage({
          bandwidth: _this3.bandwidth,
          throughput: Math.round(_this3.throughput)
        });
      }
    });
    this.masterPlaylistController_.on("selectedinitialmedia", function() {
      renditionSelectionMixin(_this3);
    });
    this.masterPlaylistController_.sourceUpdater_.on("createdsourcebuffers", function() {
      _this3.setupEme_();
    });
    this.on(this.masterPlaylistController_, "progress", function() {
      this.tech_.trigger("progress");
    });
    this.on(this.masterPlaylistController_, "firstplay", function() {
      this.ignoreNextSeekingEvent_ = true;
    });
    this.setupQualityLevels_();
    if (!this.tech_.el()) {
      return;
    }
    this.mediaSourceUrl_ = import_window6.default.URL.createObjectURL(this.masterPlaylistController_.mediaSource);
    this.tech_.src(this.mediaSourceUrl_);
  };
  _proto.createKeySessions_ = function createKeySessions_() {
    var _this4 = this;
    var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    this.logger_("waiting for EME key session creation");
    waitForKeySessionCreation({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
      mainPlaylists: this.playlists.master.playlists
    }).then(function() {
      _this4.logger_("created EME key session");
      _this4.masterPlaylistController_.sourceUpdater_.initializedEme();
    })["catch"](function(err) {
      _this4.logger_("error while creating EME key session", err);
      _this4.player_.error({
        message: "Failed to initialize media keys for EME",
        code: 3
      });
    });
  };
  _proto.handleWaitingForKey_ = function handleWaitingForKey_() {
    this.logger_("waitingforkey fired, attempting to create any new key sessions");
    this.createKeySessions_();
  };
  _proto.setupEme_ = function setupEme_() {
    var _this5 = this;
    var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    var didSetupEmeOptions = setupEmeOptions({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      media: this.playlists.media(),
      audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
    });
    this.player_.tech_.on("keystatuschange", function(e) {
      if (e.status !== "output-restricted") {
        return;
      }
      var masterPlaylist = _this5.masterPlaylistController_.master();
      if (!masterPlaylist || !masterPlaylist.playlists) {
        return;
      }
      var excludedHDPlaylists = [];
      masterPlaylist.playlists.forEach(function(playlist) {
        if (playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height >= 720) {
          if (!playlist.excludeUntil || playlist.excludeUntil < Infinity) {
            playlist.excludeUntil = Infinity;
            excludedHDPlaylists.push(playlist);
          }
        }
      });
      if (excludedHDPlaylists.length) {
        var _videojs$log;
        (_videojs$log = videojs.log).warn.apply(_videojs$log, ['DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.'].concat(excludedHDPlaylists));
        _this5.masterPlaylistController_.fastQualityChange_();
      }
    });
    this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
    this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_);
    if (videojs.browser.IE_VERSION === 11 || !didSetupEmeOptions) {
      this.masterPlaylistController_.sourceUpdater_.initializedEme();
      return;
    }
    this.createKeySessions_();
  };
  _proto.setupQualityLevels_ = function setupQualityLevels_() {
    var _this6 = this;
    var player = videojs.players[this.tech_.options_.playerId];
    if (!player || !player.qualityLevels || this.qualityLevels_) {
      return;
    }
    this.qualityLevels_ = player.qualityLevels();
    this.masterPlaylistController_.on("selectedinitialmedia", function() {
      handleVhsLoadedMetadata(_this6.qualityLevels_, _this6);
    });
    this.playlists.on("mediachange", function() {
      handleVhsMediaChange(_this6.qualityLevels_, _this6.playlists);
    });
  };
  VhsHandler2.version = function version$52() {
    return {
      "@videojs/http-streaming": version$4,
      "mux.js": version$3,
      "mpd-parser": version$2,
      "m3u8-parser": version$1,
      "aes-decrypter": version
    };
  };
  _proto.version = function version2() {
    return this.constructor.version();
  };
  _proto.canChangeType = function canChangeType() {
    return SourceUpdater.canChangeType();
  };
  _proto.play = function play() {
    this.masterPlaylistController_.play();
  };
  _proto.setCurrentTime = function setCurrentTime(currentTime) {
    this.masterPlaylistController_.setCurrentTime(currentTime);
  };
  _proto.duration = function duration5() {
    return this.masterPlaylistController_.duration();
  };
  _proto.seekable = function seekable3() {
    return this.masterPlaylistController_.seekable();
  };
  _proto.dispose = function dispose() {
    if (this.playbackWatcher_) {
      this.playbackWatcher_.dispose();
    }
    if (this.masterPlaylistController_) {
      this.masterPlaylistController_.dispose();
    }
    if (this.qualityLevels_) {
      this.qualityLevels_.dispose();
    }
    if (this.player_) {
      delete this.player_.vhs;
      delete this.player_.dash;
      delete this.player_.hls;
    }
    if (this.tech_ && this.tech_.vhs) {
      delete this.tech_.vhs;
    }
    if (this.tech_) {
      delete this.tech_.hls;
    }
    if (this.mediaSourceUrl_ && import_window6.default.URL.revokeObjectURL) {
      import_window6.default.URL.revokeObjectURL(this.mediaSourceUrl_);
      this.mediaSourceUrl_ = null;
    }
    if (this.tech_) {
      this.tech_.off("waitingforkey", this.handleWaitingForKey_);
    }
    _Component.prototype.dispose.call(this);
  };
  _proto.convertToProgramTime = function convertToProgramTime(time, callback2) {
    return getProgramTime({
      playlist: this.masterPlaylistController_.media(),
      time,
      callback: callback2
    });
  };
  _proto.seekToProgramTime = function seekToProgramTime$1(programTime, callback2, pauseAfterSeek, retryCount) {
    if (pauseAfterSeek === void 0) {
      pauseAfterSeek = true;
    }
    if (retryCount === void 0) {
      retryCount = 2;
    }
    return seekToProgramTime({
      programTime,
      playlist: this.masterPlaylistController_.media(),
      retryCount,
      pauseAfterSeek,
      seekTo: this.options_.seekTo,
      tech: this.options_.tech,
      callback: callback2
    });
  };
  return VhsHandler2;
}(Component);
var VhsSourceHandler = {
  name: "videojs-http-streaming",
  VERSION: version$4,
  canHandleSource: function canHandleSource(srcObj, options) {
    if (options === void 0) {
      options = {};
    }
    var localOptions = videojs.mergeOptions(videojs.options, options);
    return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
  },
  handleSource: function handleSource(source, tech, options) {
    if (options === void 0) {
      options = {};
    }
    var localOptions = videojs.mergeOptions(videojs.options, options);
    tech.vhs = new VhsHandler(source, tech, localOptions);
    if (!videojs.hasOwnProperty("hls")) {
      Object.defineProperty(tech, "hls", {
        get: function get7() {
          videojs.log.warn("player.tech().hls is deprecated. Use player.tech().vhs instead.");
          return tech.vhs;
        },
        configurable: true
      });
    }
    tech.vhs.xhr = xhrFactory();
    tech.vhs.src(source.src, source.type);
    return tech.vhs;
  },
  canPlayType: function canPlayType2(type2, options) {
    var simpleType = simpleTypeFromSourceType(type2);
    if (!simpleType) {
      return "";
    }
    var overrideNative = VhsSourceHandler.getOverrideNative(options);
    var supportsTypeNatively = Vhs.supportsTypeNatively(simpleType);
    var canUseMsePlayback = !supportsTypeNatively || overrideNative;
    return canUseMsePlayback ? "maybe" : "";
  },
  getOverrideNative: function getOverrideNative(options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$vhs = _options.vhs, vhs = _options$vhs === void 0 ? {} : _options$vhs, _options$hls = _options.hls, hls = _options$hls === void 0 ? {} : _options$hls;
    var defaultOverrideNative = !(videojs.browser.IS_ANY_SAFARI || videojs.browser.IS_IOS);
    var _vhs$overrideNative = vhs.overrideNative, overrideNative = _vhs$overrideNative === void 0 ? defaultOverrideNative : _vhs$overrideNative;
    var _hls$overrideNative = hls.overrideNative, legacyOverrideNative = _hls$overrideNative === void 0 ? false : _hls$overrideNative;
    return legacyOverrideNative || overrideNative;
  }
};
var supportsNativeMediaSources = function supportsNativeMediaSources2() {
  return browserSupportsCodec("avc1.4d400d,mp4a.40.2");
};
if (supportsNativeMediaSources()) {
  videojs.getTech("Html5").registerSourceHandler(VhsSourceHandler, 0);
}
videojs.VhsHandler = VhsHandler;
Object.defineProperty(videojs, "HlsHandler", {
  get: function get4() {
    videojs.log.warn("videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead.");
    return VhsHandler;
  },
  configurable: true
});
videojs.VhsSourceHandler = VhsSourceHandler;
Object.defineProperty(videojs, "HlsSourceHandler", {
  get: function get5() {
    videojs.log.warn("videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead.");
    return VhsSourceHandler;
  },
  configurable: true
});
videojs.Vhs = Vhs;
Object.defineProperty(videojs, "Hls", {
  get: function get6() {
    videojs.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead.");
    return Vhs;
  },
  configurable: true
});
if (!videojs.use) {
  videojs.registerComponent("Hls", Vhs);
  videojs.registerComponent("Vhs", Vhs);
}
videojs.options.vhs = videojs.options.vhs || {};
videojs.options.hls = videojs.options.hls || {};
if (!videojs.getPlugin || !videojs.getPlugin("reloadSourceOnError")) {
  registerPlugin = videojs.registerPlugin || videojs.plugin;
  registerPlugin("reloadSourceOnError", reloadSourceOnError);
}
var registerPlugin;
var video_es_default = videojs;

// node_modules/@videojs-player/vue/dist/videojs-player.esm.js
function g(e, n) {
  var t2 = {};
  for (var r2 in e) Object.prototype.hasOwnProperty.call(e, r2) && n.indexOf(r2) < 0 && (t2[r2] = e[r2]);
  if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
    var o = 0;
    for (r2 = Object.getOwnPropertySymbols(e); o < r2.length; o++) n.indexOf(r2[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r2[o]) && (t2[r2[o]] = e[r2[o]]);
  }
  return t2;
}
var d2 = { src: { type: String, onChange: function(e, n) {
  return e.src(n);
} }, width: { type: Number, onChange: function(e, n) {
  return e.width(n);
}, onEvent: function(e, n) {
  e.on(["playerresize", "resize"], function() {
    return n(e.width());
  });
} }, height: { type: Number, onChange: function(e, n) {
  return e.height(n);
}, onEvent: function(e, n) {
  e.on(["playerresize", "resize"], function() {
    return n(e.height());
  });
} }, preload: { type: String, onChange: function(e, n) {
  return e.preload(n);
} }, loop: { type: Boolean, onChange: function(e, n) {
  return e.loop(n);
} }, muted: { type: Boolean, onChange: function(e, n) {
  return e.muted(n);
}, onEvent: function(e, n) {
  return e.on("volumechange", function() {
    return n(e.muted());
  });
} }, poster: { type: String, onChange: function(e, n) {
  return e.poster(n);
}, onEvent: function(e, n) {
  return e.on("posterchange", function() {
    return n(e.poster());
  });
} }, controls: { type: Boolean, onChange: function(e, n) {
  return e.controls(n);
}, onEvent: function(e, n) {
  e.on("controlsenabled", function() {
    return n(true);
  }), e.on("controlsdisabled", function() {
    return n(false);
  });
} }, autoplay: { type: [Boolean, String], onChange: function(e, n) {
  return e.autoplay(n);
} }, crossorigin: { type: String, onChange: function(e, n) {
  return e.crossOrigin(n);
} }, crossOrigin: { type: String, onChange: function(e, n) {
  return e.crossOrigin(n);
} }, playsinline: { type: Boolean, onChange: function(e, n) {
  return e.playsinline(n);
} }, playsInline: { type: Boolean, onChange: function(e, n) {
  return e.playsinline(n);
} } };
var f = { id: { type: String }, sources: { type: Array, onChange: function(e, n) {
  return e.src(n);
} }, tracks: { type: Array, onChange: function(e, n) {
  for (var t2 = e.remoteTextTracks(), r2 = (null == t2 ? void 0 : t2.length) || 0; r2--; ) e.removeRemoteTextTrack(t2[r2]);
  e.ready(function() {
    n.forEach(function(n2) {
      return e.addRemoteTextTrack(n2, false);
    });
  });
} }, textTrackSettings: { type: Object, onChange: function(e, n) {
  return e.textTrackSettings.options(n);
} }, language: { type: String, onChange: function(e, n) {
  return e.language(n);
}, onEvent: function(e, n) {
  return e.on("languagechange", function() {
    return n(e.language());
  });
} }, languages: { type: Object }, playbackRates: { type: Array, onChange: function(e, n) {
  return e.playbackRates(null != n ? n : []);
}, onEvent: function(e, n) {
  e.on("playbackrateschange", function() {
    return n(e.playbackRates());
  });
} }, audioOnlyMode: { type: Boolean, onChange: function(e, n) {
  return e.audioOnlyMode(n);
} }, audioPosterMode: { type: Boolean, onChange: function(e, n) {
  return e.audioPosterMode(n);
} }, responsive: { type: Boolean, onChange: function(e, n) {
  return e.responsive(n);
} }, breakpoints: { type: Object, onChange: function(e, n) {
  return e.breakpoints(n);
} }, fluid: { type: Boolean, onChange: function(e, n) {
  return e.fluid(n);
} }, fill: { type: Boolean, onChange: function(e, n) {
  return e.fill(n);
} }, aspectRatio: { type: String, onChange: function(e, n) {
  return e.aspectRatio(n);
} }, fullscreen: { type: Object }, liveui: { type: Boolean }, liveTracker: { type: Object }, disablePictureInPicture: { type: Boolean, onChange: function(e, n) {
  return e.disablePictureInPicture(n);
} }, notSupportedMessage: { type: String }, normalizeAutoplay: { type: Boolean }, noUITitleAttributes: { type: Boolean }, preferFullWindow: { type: Boolean }, suppressNotSupportedError: { type: Boolean }, techCanOverridePoster: { type: Boolean }, reportTouchActivity: { type: Boolean }, techOrder: { type: Array }, inactivityTimeout: { type: Number }, userActions: { type: Object }, plugins: { type: Object }, restoreEl: { type: [Boolean, Object] }, "vtt.js": { type: String } };
var v = { children: { type: [Array, Object] }, controlBar: { type: Object, onChange: function(e, n) {
  return e.controlBar.options(n);
} } };
var y = { html5: { type: Object } };
var h2 = { volume: { type: Number, onChange: function(e, n) {
  return e.volume(n);
}, onEvent: function(e, n) {
  return e.on("volumechange", function() {
    return n(e.volume());
  });
} }, playbackRate: { type: Number, onChange: function(e, n) {
  e.playbackRate(n), e.defaultPlaybackRate(n);
}, onEvent: function(e, n) {
  e.on("ratechange", function() {
    n(e.playbackRate());
  });
} }, options: { type: Object } };
var b = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, d2), f), v), y), h2);
var m = Object.keys(b);
var O = Object.assign(Object.assign(Object.assign(Object.assign({}, { loadstart: "onLoadStart", suspend: "onSuspend", abort: "onAbort", error: "onError", emptied: "onEmptied", stalled: "onStalled", loadedmetadata: "onLoadedMetadata", loadeddata: "onLoadedData", canplay: "onCanPlay", canplaythrough: "onCanPlayThrough", playing: "onPlaying", waiting: "onWaiting", seeking: "onSeeking", seeked: "onSeeked", ended: "onEnded", durationchange: "onDurationChange", timeupdate: "onTimeUpdate", progress: "onProgress", play: "onPlay", pause: "onpause", ratechange: "onRateChange", resize: "onResize", volumechange: "onVolumeChange" }), { posterchange: "onPosterChange", languagechange: "onLanguageChange", fullscreenchange: "onFullscreenChange", playbackrateschange: "onPlaybackRatesChange", controlsdisabled: "onControlsDisabled", controlsenabled: "onControlsEnabled", enterFullWindow: "onEnterFullWindow", exitFullWindow: "onExitFullWindow", enterpictureinpicture: "onEnterPictureInPicture", leavepictureinpicture: "onLeavePictureInPicture", sourceset: "onSourceSet", texttrackchange: "onTextTrackChange", textdata: "onTextData", useractive: "onUserActive", userinactive: "onUserInactive", usingcustomcontrols: "onUsingCustomControls", usingnativecontrols: "onUsingNativeControls", dispose: "onDispose" }), { beforepluginsetup: "onBeforePluginSetup", pluginsetup: "onPluginSetup" }), { componentresize: "onComponentResize", playerresize: "onPlayerResize", ready: "onReady", tap: "onTap" });
var k = Object.keys(O);
Object.values(O);
var C = function(e) {
  var n, t2 = null == e ? void 0 : e.trim().replace(/\s+/g, " ");
  return t2 && null !== (n = t2.split(" ")) && void 0 !== n ? n : [];
};
var j = { src: { getter: function(e) {
  return e.src();
} }, currentSrc: { getter: function(e) {
  return e.currentSrc();
} }, currentSource: { getter: function(e) {
  return e.currentSource();
} }, width: { events: ["resize", "playerresize"], getter: function(e) {
  return e.width();
} }, height: { events: ["resize", "playerresize"], getter: function(e) {
  return e.height();
} }, currentWidth: { events: ["resize", "playerresize"], getter: function(e) {
  return e.currentWidth();
} }, currentHeight: { events: ["resize", "playerresize"], getter: function(e) {
  return e.currentHeight();
} }, videoWidth: { events: ["resize", "playerresize"], getter: function(e) {
  return e.videoWidth();
} }, videoHeight: { events: ["resize", "playerresize"], getter: function(e) {
  return e.videoHeight();
} }, controls: { events: ["controlsdisabled", "controlsenabled"], getter: function(e) {
  return e.controls();
} }, volume: { events: ["volumechange"], getter: function(e) {
  return e.volume();
} }, muted: { events: ["volumechange"], getter: function(e) {
  return e.muted();
} }, poster: { events: ["posterchange"], getter: function(e) {
  return e.poster();
} }, seeking: { events: ["seeking"], getter: function(e) {
  return e.seeking();
} }, paused: { events: ["pause", "play", "playing"], getter: function(e) {
  return e.paused();
} }, ended: { events: ["ended", "play"], getter: function(e) {
  return e.ended();
} }, currentTime: { events: ["timeupdate"], getter: function(e) {
  return e.currentTime();
} }, duration: { events: ["durationchange"], getter: function(e) {
  return e.duration();
} }, playbackRate: { events: ["ratechange"], getter: function(e) {
  return e.playbackRate();
} }, playbackRates: { events: ["playbackrateschange"], getter: function(e) {
  return e.playbackRates();
} }, isFullscreen: { events: ["fullscreenchange"], getter: function(e) {
  return e.isFullscreen();
} }, isInPictureInPicture: { events: ["enterpictureinpicture", "leavepictureinpicture"], getter: function(e) {
  return e.isInPictureInPicture();
} }, isLive: { getter: function(e) {
  var n;
  return null === (n = e.liveTracker) || void 0 === n ? void 0 : n.isLive();
} }, language: { events: ["languagechange"], getter: function(e) {
  return e.language();
} }, userActive: { events: ["useractive", "userinactive"], getter: function(e) {
  return e.userActive();
} }, readyState: { events: ["loadeddata"], getter: function(e) {
  return e.readyState();
} }, networkState: { events: ["loadeddata", "error"], getter: function(e) {
  return e.networkState();
} }, error: { events: ["loadeddata", "error"], getter: function(e) {
  return e.error();
} }, buffered: { events: ["progress"], getter: function(e) {
  return e.buffered();
} }, bufferedPercent: { events: ["progress"], getter: function(e) {
  return e.bufferedPercent();
} }, played: { events: ["timeupdate"], getter: function(e) {
  return e.played();
} }, seekable: { events: ["progress", "seeked"], getter: function(e) {
  return e.seekable();
} }, audioTracks: { getter: function(e) {
  var n;
  return null === (n = e.audioTracks) || void 0 === n ? void 0 : n.call(e);
} }, videoTracks: { getter: function(e) {
  var n;
  return null === (n = e.videoTracks) || void 0 === n ? void 0 : n.call(e);
} }, textTracks: { getter: function(e) {
  var n;
  return null === (n = e.textTracks) || void 0 === n ? void 0 : n.call(e);
} } };
var P = m.filter(function(e) {
  return Boolean(b[e].onEvent);
});
var S = function(e) {
  return "update:" + e;
};
var E = k.concat(P.map(S));
var T = m.reduce(function(e, n) {
  var t2, r2 = b[n], o = Array.isArray(r2.type) ? r2.type : [r2.type], a = Object.assign({}, r2);
  return o.includes(Boolean) && (a.default = void 0), Object.assign(Object.assign({}, e), ((t2 = {})[n] = a, t2));
}, {});
var B = defineComponent({ name: "VueVideoPlayer", props: Object.assign(Object.assign({}, T), { class: [String, Object, Array] }), emits: E.concat(["mounted"], ["unmounted"]), setup: function(e, d3) {
  var f2 = toRaw(e), v2 = f2.class, y2 = g(f2, ["class"]), h3 = shallowRef(false), O2 = shallowRef(null), E2 = shallowRef(null), T2 = computed(function() {
    return E2.value ? E2.value.player : null;
  }), B2 = ref(null), R2 = computed(function() {
    return B2.value ? readonly(B2.value) : null;
  });
  return onMounted(function() {
    var n, t2 = function(e2) {
      var n2, t3 = e2.props, r2 = e2.element, o = e2.className, a = e2.onEvent, i = t3.options;
      void 0 === i && (i = {});
      var u = g(t3, ["options"]), c = {};
      Object.keys(u).forEach(function(e3) {
        var n3 = u[e3];
        void 0 !== n3 && (c[e3] = n3);
      });
      var l = Object.assign(Object.assign({}, c), i), s = l.volume, d4 = l.playbackRate, f3 = g(l, ["volume", "playbackRate"]), v3 = Object.assign(Object.assign({}, f3), { playsinline: null !== (n2 = f3.playsinline) && void 0 !== n2 ? n2 : f3.playsInline }), y3 = video_es_default(r2, v3, function() {
        var e3 = this;
        k.forEach(function(n3) {
          e3.on(n3, function(e4) {
            a(n3, e4);
          });
        }), f3.src && !f3.sources && this.src(f3.src), s && Number.isFinite(s) && this.volume(s), d4 && Number.isFinite(d4) && (this.defaultPlaybackRate(d4), setTimeout(function() {
          e3.playbackRate(d4);
        }, 0));
      });
      o && C(o).map(function(e3) {
        return y3.addClass(e3);
      });
      var h4 = function(e3) {
        var n3;
        null === (n3 = y3.options) || void 0 === n3 || n3.call(y3, null != e3 ? e3 : {});
      };
      return { player: y3, dispose: function() {
        return y3.dispose();
      }, updateClassNames: function(e3, n3) {
        C(e3).map(function(e4) {
          return y3.removeClass(e4);
        }), C(n3).map(function(e4) {
          return y3.addClass(e4);
        });
      }, updateOptions: h4, updatePropOption: function(e3, n3) {
        var t4, r3, o2;
        h4(((t4 = {})[e3] = n3, t4)), null === (o2 = null === (r3 = b[e3]) || void 0 === r3 ? void 0 : r3.onChange) || void 0 === o2 || o2.call(r3, y3, n3);
      } };
    }({ element: O2.value, props: y2, onEvent: d3.emit });
    n = { player: t2.player, onEvent: d3.emit }, P.forEach(function(e2) {
      var t3, r2;
      null === (r2 = null === (t3 = b[e2]) || void 0 === t3 ? void 0 : t3.onEvent) || void 0 === r2 || r2.call(t3, n.player, function(t4) {
        n.onEvent(S(e2), t4);
      });
    }), watch(function() {
      return e.class;
    }, function(e2, n2) {
      var r2 = normalizeClass(n2), o = normalizeClass(e2);
      t2.updateClassNames(r2, o);
    }, { immediate: true }), watch(function() {
      return e.options;
    }, function(e2) {
      return t2.updateOptions(null != e2 ? e2 : {});
    }, { deep: true }), m.filter(function(e2) {
      return "options" !== e2;
    }).forEach(function(n2) {
      watch(function() {
        return e[n2];
      }, function(e2) {
        return t2.updatePropOption(n2, e2);
      }, { deep: true });
    }), function(e2, n2) {
      var t3 = Object.keys(j), r2 = t3.reduce(function(n3, t4) {
        var r3;
        return Object.assign(Object.assign({}, n3), ((r3 = {})[t4] = j[t4].getter(e2), r3));
      }, { playing: false, waiting: false }), o = function(e3, t4) {
        r2[e3] = t4, n2.onUpdate(e3, t4, Object.assign({}, r2));
      };
      e2.on(["pause", "ended"], function() {
        o("playing", false);
      }), e2.on(["play", "playing"], function() {
        o("playing", true);
      }), e2.on("waiting", function() {
        o("waiting", true);
        var n3 = e2.currentTime(), t4 = function() {
          n3 !== e2.currentTime() && (o("waiting", false), e2.off("timeupdate", t4));
        };
        e2.on("timeupdate", t4);
      }), t3.forEach(function(n3) {
        var t4, r3 = j[n3];
        e2.on(["loadstart", "loadedmetadata"].concat(null !== (t4 = r3.events) && void 0 !== t4 ? t4 : []), function() {
          o(n3, r3.getter(e2));
        });
      }), n2.onInit(Object.assign({}, r2));
    }(t2.player, { onInit: function(e2) {
      B2.value = e2;
    }, onUpdate: function(e2, n2) {
      B2.value && (B2.value[e2] = n2);
    } }), E2.value = t2, h3.value = true, d3.emit("mounted", { video: O2.value, player: T2.value, state: R2.value });
  }), onBeforeUnmount(function() {
    E2.value && (E2.value.dispose(), E2.value = null, B2.value = null, d3.emit("unmounted"));
  }), function() {
    var e2, n;
    return h("div", { "data-vjs-player": "", class: normalizeClass(v2) }, [h("video", { class: ["video-js", "v-video-player"], ref: O2 }), h3.value && (null === (n = (e2 = d3.slots).default) || void 0 === n ? void 0 : n.call(e2, { video: O2.value, player: T2.value, state: R2.value }))]);
  };
} });
var R = B;
var z = function(e) {
  e.component("VideoPlayer", B), e.component(B.name, B);
};
var w = { VideoPlayer: B, install: z };

// node_modules/vue-video-player/index.js
var vue_video_player_default = w;
export {
  R as VideoPlayer,
  vue_video_player_default as default,
  z as install
};
/*! Bundled license information:

keycode/index.js:
  (*!
   * Programatically add the following
   *)

@videojs/xhr/lib/index.js:
  (**
   * @license
   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
   * Copyright (c) 2014 David Björklund
   * Available under the MIT license
   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
   *)

m3u8-parser/dist/m3u8-parser.es.js:
  (*! @name m3u8-parser @version 4.8.0 @license Apache-2.0 *)

mpd-parser/dist/mpd-parser.es.js:
  (*! @name mpd-parser @version 0.22.1 @license Apache-2.0 *)

video.js/dist/video.es.js:
  (**
   * @license
   * Video.js 7.21.7 <http://videojs.com/>
   * Copyright Brightcove, Inc. <https://www.brightcove.com/>
   * Available under Apache License Version 2.0
   * <https://github.com/videojs/video.js/blob/main/LICENSE>
   *
   * Includes vtt.js <https://github.com/mozilla/vtt.js>
   * Available under Apache License Version 2.0
   * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
   *)
  (*! @name @videojs/http-streaming @version 2.16.3 @license Apache-2.0 *)
  (*! @name pkcs7 @version 1.0.4 @license Apache-2.0 *)
  (*! @name aes-decrypter @version 3.1.3 @license Apache-2.0 *)
*/
//# sourceMappingURL=vue-video-player.js.map
